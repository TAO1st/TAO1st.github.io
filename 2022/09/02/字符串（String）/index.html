

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/avatar.png">
  <link rel="icon" href="/img/avatar.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#98a5ac">
  <meta name="author" content="tao1st">
  <meta name="keywords" content="">
  
    <meta name="description" content="字符串 String 基础   242 Valid Anagram 有效的字母异位词 (Easy)  其实是个哈希表的题目    205 Isomorphic Strings 同构字符串 (Easy)  其实还是个哈希表的题目。 有点小坑，要同时利用两个哈希表。    696 Count Binary Substrings 计数二进制子串 (Easy) 思路题：重点在于子串中的0和1是成组连续的，">
<meta property="og:type" content="article">
<meta property="og:title" content="字符串（String）">
<meta property="og:url" content="https://tao1st.github.io/2022/09/02/%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88String%EF%BC%89/index.html">
<meta property="og:site_name" content="tao1st.github.io">
<meta property="og:description" content="字符串 String 基础   242 Valid Anagram 有效的字母异位词 (Easy)  其实是个哈希表的题目    205 Isomorphic Strings 同构字符串 (Easy)  其实还是个哈希表的题目。 有点小坑，要同时利用两个哈希表。    696 Count Binary Substrings 计数二进制子串 (Easy) 思路题：重点在于子串中的0和1是成组连续的，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205161418594.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205161501183.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202112271559574.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202112271610871.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202112271610179.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202112271610855.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202112271610897.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202112271611950.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205111123247.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205111539729.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205151303835.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205151303981.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205151304030.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205151304895.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205151305541.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205151305963.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205151305388.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205151305522.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205151305620.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205151306852.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205151306288.png">
<meta property="og:image" content="https://tao1st.github.io/assets/images/posts/algorithm-repeated-string-pattern/repeated-string-pattern-kmp-5-1.jpeg">
<meta property="og:image" content="https://tao1st.github.io/assets/images/posts/algorithm-repeated-string-pattern/repeated-string-pattern-kmp-5-2.jpeg">
<meta property="og:image" content="https://tao1st.github.io/assets/images/posts/algorithm-repeated-string-pattern/repeated-string-pattern-kmp-5-3.jpeg">
<meta property="og:image" content="https://tao1st.github.io/assets/images/posts/algorithm-repeated-string-pattern/repeated-string-pattern-kmp-5-4.jpeg">
<meta property="og:image" content="https://tao1st.github.io/assets/images/posts/algorithm-repeated-string-pattern/repeated-string-pattern-kmp-5-5.jpeg">
<meta property="og:image" content="https://tao1st.github.io/assets/images/posts/algorithm-repeated-string-pattern/repeated-string-pattern-kmp-5-6.jpeg">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205151307596.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205151307241.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205151307726.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205151307501.png">
<meta property="og:image" content="https://tao1st.github.io/assets/images/posts/algorithm-repeated-string-pattern/repeated-string-pattern-kmp-7-3.jpeg">
<meta property="og:image" content="https://tao1st.github.io/assets/images/posts/algorithm-repeated-string-pattern/repeated-string-pattern-kmp-7-4.jpeg">
<meta property="article:published_time" content="2022-09-02T09:45:47.000Z">
<meta property="article:modified_time" content="2022-10-13T15:17:50.324Z">
<meta property="article:author" content="tao1st">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205161418594.png">
  
  
  
  <title>字符串（String） - tao1st.github.io</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"tao1st.github.io","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":3},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>TAO1st</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/bk.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.5)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="字符串（String）"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-09-02 17:45" pubdate>
          2022年9月2日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          12k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          104 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">字符串（String）</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="字符串-String-2">字符串 String</h2>
<h3 id="基础-3">基础</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>242 Valid Anagram 有效的字母异位词 (Easy)</p>
<ul class="lvl-2">
<li class="lvl-4">其实是个<strong>哈希表</strong>的题目</li>
</ul>
</li>
<li class="lvl-2">
<p>205 Isomorphic Strings 同构字符串 (Easy)</p>
<ul class="lvl-2">
<li class="lvl-4">其实还是个<strong>哈希表</strong>的题目。</li>
<li class="lvl-4">有点小坑，要同时利用两个哈希表。</li>
</ul>
</li>
<li class="lvl-2">
<p>696 Count Binary Substrings 计数二进制子串 (Easy)</p>
<p>思路题：重点在于子串中的0和1是成组连续的，所以每当子串中的字符发生变换时，就可以对子串数进行统计。</p>
</li>
<li class="lvl-2">
<p>409 Longest Palindrome 最长回文串 (Easy)</p>
<ul class="lvl-2">
<li class="lvl-4">其实又是一个<strong>哈希表</strong>的题目。</li>
</ul>
</li>
<li class="lvl-2">
<p>2278 Percentage of Letter in String 字母在字符串中的百分比 (Easy)</p>
<p>简单模拟</p>
</li>
<li class="lvl-2">
<p>2296 Design a Text Editor 设计一个文本编辑器 (Hard)</p>
<p>数据结构设计题，详见<a href="##%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1">数据结构设计部分</a></p>
</li>
<li class="lvl-2">
<p>1108 IP地址无效化 (Easy)</p>
<p>简单弱智模拟。</p>
</li>
<li class="lvl-2">
<p><strong>522 Longest Uncommon Subsequence 最长特殊序列 II (Medium)</strong></p>
<p>题目的基本含义：找出<strong>最长的独有子序列</strong>。</p>
<p>解析题意：最长的独有子序列要求不能是任何其他字符串的子序列。然而我们考虑一个满足条件的最长独有子序列，在其前后加上若干任意字符后其仍为最长独有子序列。即，如果某个字符串的子序列是一个最长独有子序列，那么该字符串本身也必定为最长特殊子序列。所以我们只需要考虑每个字符串本身即可，而无需关心其子串。</p>
<p>所以最终的解决思路是：枚举每个字符串，查看其是否为其他字符串的subsequence。</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>首先，可以将字符按照长度顺序进行排序，这样当前字符串只需要与更长的串进行比较；</p>
</li>
<li class="lvl-4">
<p>判断subsequence的方法：双指针；</p>
</li>
</ul>
</li>
<li class="lvl-2">
<p>899 Orderly Queue 有序队列 (Hard)</p>
<p>巧解题，分两种情况讨论。</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>$k == 1$：就是每次将首个字母移到最末端。那么我们枚举所有结果，选出其中最小的即可。</p>
<p>一种巧妙地枚举办法是，在字符串后面一模一样拼接一个，然后从前到后挨个遍历就能得到所有结果。</p>
</li>
<li class="lvl-4">
<p>$k &gt; 1$：脑际急转弯的地方在于，$k&gt;1$ 的情况实际上结果一定会变为最小单词。</p>
<p>一种浅显的理解方式是，当$k==1$时，每次只移动一个字符，整体相当于一个循环队列，在这个队列中的逆序对是无法被全部消除的（除非题目正好能消除掉）。</p>
<p>而当 $k&gt;1$ 时，每次是从 $k$ 个里面选出最大的移到最后，并且移动次数为任意次，这意味着从前往后每 $k$ 个单词在若干次移动后应该被消除掉所有逆序对才是最终正确的结果。综上，最终整个字符串不应该还存在逆序对。</p>
<p>数学上的证明见官方题解。</p>
</li>
</ul>
</li>
</ul>
<h3 id="处理字符串中的字符">处理字符串中的字符</h3>
<blockquote>
<p>常用到C中的各种库函数，多查工具书。</p>
<ul class="lvl-1">
<li class="lvl-2"><code>cctype</code></li>
<li class="lvl-2">STL <code>string</code></li>
</ul>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>468 Validate IP Address 验证IP地址 (Medium)</p>
<p>“面向测试用例编程”、无脑模拟，考虑各种特殊情况、注意字符判断时使用的库函数。</p>
</li>
<li class="lvl-2">
<p>6079 Apply Discount to Prices 价格减免 (Medium)</p>
</li>
<li class="lvl-2">
<p>929 独特的电子邮件地址 (Easy)</p>
<p>简单模拟，或使用<strong>正则表达式</strong>。</p>
</li>
<li class="lvl-2">
<p>2288 Apply Discount to Prices (Medium)</p>
<p>考察将字符串中的浮点数转换为<code>double</code>后再按照固定格式转换回字符串。</p>
<p>用到如下函数：</p>
<ul class="lvl-2">
<li class="lvl-4">
<p><code>sprintf</code></p>
</li>
<li class="lvl-4">
<p><code>stod</code></p>
</li>
<li class="lvl-4">
<p><code>isdigit</code></p>
</li>
</ul>
</li>
<li class="lvl-2">
<p>811 Subdomain Visit Count 子域名访问计数 (Medium)</p>
</li>
</ul>
<h3 id="回文-Palindrome-2">回文 Palindrome</h3>
<p>回文子序列/子串的题型有多种变式，常见的解法（除暴力求解外）有以下三种（上面两道题都可以用以下算法解答）。</p>
<h4 id="解法一：中心拓展">解法一：中心拓展</h4>
<p>本质上还是暴力枚举，只不过<strong>枚举回文中心</strong>比<strong>枚举出所有子串</strong>方便的多。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>要区分两种情况：奇数回文串和偶数回文串。</p>
</li>
<li class="lvl-2">
<p>时间复杂度：$O(n^{2})$</p>
</li>
</ul>
<h4 id="解法二：Manacher">解法二：Manacher</h4>
<p>详见<a href="##Manacher%E7%AE%97%E6%B3%95">Manacher算法</a></p>
<h4 id="解法三：动态规划">解法三：动态规划</h4>
<h4 id="相关题目-14">相关题目</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>647 Palindromic Substrings 回文子串 (Medium)</p>
</li>
<li class="lvl-2">
<p>5 Longest Palindromic Substring 最长回文子串 (Medium)</p>
</li>
<li class="lvl-2">
<p>214 Shortest Palindrome 最短回文串 (Hard)</p>
<p>本题的解法实际上是字符串匹配，所以详见字符串匹配部分。</p>
</li>
</ul>
<h3 id="字符串匹配-2">字符串匹配</h3>
<p>跟字符串匹配相关的解法如下：</p>
<ol>
<li class="lvl-3">
<p>朴素匹配</p>
</li>
<li class="lvl-3">
<p><a href="##KMP%E7%AE%97%E6%B3%95">KMP算法</a></p>
</li>
<li class="lvl-3">
<p><strong>Robin-Karp算法</strong>，即<strong>滚动哈希</strong>。</p>
<p>本质上就是字符串哈希，即将字符串转换为一个整数从而方便比较。该算法有几个值得注意的点，在此指明：</p>
<ul class="lvl-2">
<li class="lvl-5">
<p>因为直接按照进制转换求值有可能会导致哈希值过大，无法在机器字长内表示，所以通常会模上一个大质数；</p>
</li>
<li class="lvl-5">
<p>对于转换的进制 $base$ 和模数 $mod$ 的选取：</p>
<p>一般来说，我们选取一个<strong>大于字符集大小</strong>（即字符串中可能出现的字符种类的数目）<strong>的质数</strong>作为 $base$，再选取一个在<strong>字符串长度平方级别左右的质数</strong>作为 $mod$，产生哈希碰撞的概率就会很低。</p>
<p>对于leetcode中的题目，大都以<strong>全小写字母形式</strong>的字符串出现，这种情况下常用如下设置：</p>
<ul class="lvl-4">
<li class="lvl-7">
<p>$base$：略大于字符集大小的质数，选定<strong>29</strong>或<strong>31</strong>（有大写的话就增加就行）；</p>
</li>
<li class="lvl-7">
<p>$mod$：所有跟哈希计算相关的值都设置为<code>unsigned long long</code>类型，则运算时相当于自动取模，而不会产生任何上下溢出，编译器会自动截断。</p>
</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-3">
<p>有限状态机</p>
</li>
</ol>
<p>基本上掌握 <strong>KMP</strong>和<strong>滚动哈希</strong>即可解决相关的大部分问题，且面试出现频率不高，相关题目如下：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>28 实现 strStr() Implement strStr() (Easy)</p>
</li>
<li class="lvl-2">
<p>796 Rotate String 旋转字符串 (Easy)</p>
<p>解法一：模拟</p>
<p>按照题目要求，进行旋转操作，并对比旋转后的结果；</p>
<p>主要的开销在于旋转操作，每次的旋转要去掉第一个字符，需要 $O(n)$ 的时间。</p>
<p>解法二：<strong>字符串匹配</strong></p>
<p>文本串 <strong>$s + s$</strong> 包含了所有 $s$ 可以通过旋转操作得到的字符串，只需要检查 $goal$ 是否为 $s + s$ 的子字符串即可。</p>
</li>
<li class="lvl-2">
<p><strong>214 Shortest Palindrome 最短回文串 (Hard)</strong></p>
<blockquote>
<p>首先思考如何找到该最短回文串，如下图所示：</p>
<p>我们要在 $s$ 前添加一个字符串，要求得到最短的回文串。实际的字符串构成如图所示，即将 $s$ 的一部分后缀 $s_2$ 反转得到 $\hat{s_2}$，并拼接在 $s$ 的前面。这里为了保证整体是回文串，就要求前缀 $s_1$ 部分必须也是回文的。</p>
<p>最简单的例子就是将整个字符串倒转后添加在前面，一定能得到一个回文串。而为了满足最短的要求，实际就是找到最短的 $\hat{s_2}$，同理就是【<strong>找到最长的 $s_1$ 满足其为回文串</strong>】。</p>
<p>由此可得，暴力解法即<strong>从后往前枚举每个元素，查看当前的前缀 $s_1$ 是否为回文串</strong>。该方法的时间复杂度显然为 $O(|s|^2)$ 。</p>
<p>优化的解法也是在这个思路的基础上进行优化。</p>
</blockquote>
<img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205161418594.png" srcset="/img/loading.gif" lazyload style="zoom: 50%;" />
<p>解法一：KMP算法</p>
<p>为了找到最长的 $s_1$，我们将 $s$ 作为pattern，将 $\hat{s}$ 作为text，进行模式匹配。如图所示，最后匹配的位置就能帮助我们获取到答案。</p>
<p><img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205161501183.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>解法二：Robin-Karp字符串哈希算法</p>
</li>
<li class="lvl-2">
<p><strong>1044 Longest Duplicate Substring 最长重复子串 (Hard)</strong></p>
<ul class="lvl-2">
<li class="lvl-4">
<p>首先，题目要求找到具有最长长度的子串，所以要对长度进行枚举 - $O(n)$</p>
<p>优化方法是采用二分，时间复杂度可以降至 $O(logn)$。</p>
</li>
<li class="lvl-4">
<p>在每一个长度下，要两两遍历子串来查询其是否有出现过 - $O(n^2)$</p>
<p>采用Robin-Karp算法，判断同一长度下是否有两个相同字符串只需要一趟扫描，即 $O(n)$。</p>
</li>
</ul>
</li>
<li class="lvl-2">
<p><strong>459 Repeated Substring Pattern 重复的子字符串 (Easy)</strong></p>
<p>解法一：暴力枚举</p>
<p>对子串长度进行枚举，检查子串符合要求的有两种思路：</p>
<ol>
<li class="lvl-5">
<p>拼接 $n$ 个字串（假设需要 $n$ 个），拼接后检查是否与原字符串相等。非常慢。</p>
</li>
<li class="lvl-5">
<p>假设当前子段长度为 $n$，从第二个字串开始到最后为止，检查 $s[i] == s[i - n]$ 。有任意一次不满足相等就可以直接剪枝。</p>
</li>
</ol>
<p>时间复杂度为 $O(n^2)$。</p>
<p>解法二：<strong>字符串匹配</strong></p>
<p>详见<a href="##%E5%91%A8%E6%9C%9F%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%A4%E5%88%AB%E9%97%AE%E9%A2%98">周期字符串判别问题</a>。</p>
</li>
<li class="lvl-2">
<p><em>2301 Match Substring After Replacement 替换字符后匹配 (Hard)</em></p>
<p>暴力模拟可以通过。即枚举所有长度跟目标串一致的子串，查看是否匹配。</p>
<p>注意使用<strong>哈希表</strong>加快替换字符的效率。</p>
</li>
<li class="lvl-2">
<p><strong>30 Substring with Concatenation of All Words 串联所有单词的子串 (Hard)</strong></p>
<p>虽然题面是字符串匹配，但实际上无需写匹配算法。</p>
<p>滑动窗口 + 哈希表。</p>
</li>
</ul>
<h3 id="其他-5">其他</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><em>316 Remove Duplicate Letters 去除重复字母 (Medium)</em></p>
<p>题目中的要求：去除重复字母，保证返回的字典序最小，且不能打乱字符的相对位置。</p>
<p>关于字符串的知识点在于：<strong>针对一个字符串，在其中删除哪个元素能保证结果字符串的字典序最小/大？</strong></p>
<p>详见[单调栈部分](###单调栈 Monotone Stack)。</p>
</li>
<li class="lvl-2">
<p><strong>227 Basic Calculator II 基本计算器 II  (Medium)</strong></p>
<p>详见<a href="###%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC">表达式求值</a>部分。</p>
</li>
<li class="lvl-2">
<p><strong>467 Unique Substrings in Wraparound String 环绕字符串中唯一的子字符串 (Medium)</strong></p>
<ul class="lvl-2">
<li class="lvl-4">统计以每种字母为结尾的最长连续子串即可，最大值即为其对最终答案的贡献（自动去重，无需担心前后出现相同的字符串重复统计）；</li>
<li class="lvl-4">最终对所有字母的贡献求和即可，即前缀和的思想。</li>
</ul>
</li>
<li class="lvl-2">
<p>1455 Check If a Word Occurs As a Prefix of Any Word in a Sentence 检查单词是否为句中其他单词的前缀 (Easy)</p>
</li>
</ul>
<h2 id="Manacher算法-2">Manacher算法</h2>
<p>比较特殊的算法，要背一下其实现，具体写不写的出其实问题不大。</p>
<blockquote>
<p>给定一个字符串，<strong>求其最长回文子串的长度</strong>。例如：</p>
<ol>
<li class="lvl-3"><code>s=&quot;abcd&quot;</code>，最长回文长度为 1；</li>
<li class="lvl-3"><code>s=&quot;ababa&quot;</code>，最长回文长度为 5；</li>
<li class="lvl-3"><code>s=&quot;abccb&quot;</code>，最长回文长度为 4，即 <code>bccb</code>。</li>
</ol>
<p>以上问题的传统思路大概是，遍历每一个字符，以该字符为中心向两边查找。其时间复杂度为 O(n2)，效率很差。</p>
<p>1975 年，一个叫 Manacher 的人发明了一个算法，<em>Manacher 算法</em>（中文名：<em>马拉车算法</em>），该算法可以把时间复杂度提升到 O(n)。</p>
<p>Manacher 算法依旧需要枚举字符串的每一个位置并先假设它是回文中心，但是它会<strong>利用已经计算出来的状态来更新 <code>p(i)</code></strong>，<strong>而不是向「中心拓展」一样盲目地拓展</strong>。</p>
</blockquote>
<p>算法分为三个重点处理部分：</p>
<h3 id="1-字符串预处理-2">1 字符串预处理</h3>
<blockquote>
<p>解决奇偶回文分类问题</p>
</blockquote>
<p>由于回文分为偶回文（比如 <code>bccb</code>）和奇回文（比如 <code>bcacb</code>），而在处理奇偶问题上会比较繁琐，所以这里我们使用一个技巧，具体做法是：</p>
<ol>
<li class="lvl-3">
<p>在字符串首尾及每个字符间都插入一个 “#”，这样可以使得原先的奇偶回文都变为奇回文；</p>
</li>
<li class="lvl-3">
<p>接着再在首尾两端各插入 “$” 和 “^”，这样中心扩展寻找回文的时候会自动退出循环，不需每次判断是否越界，可参见下面代码。</p>
</li>
<li class="lvl-3">
<p>上述新插入的三个字符，即 “#”、 “$” 和 “^”，必须各异，且不可以与原字符串中的字符相同。</p>
</li>
</ol>
<p>举个例子：<code>s=&quot;abbahopxpo&quot;</code>，转换为 <code>s_new=&quot;$#a#b#b#a#h#o#p#x#p#o#^&quot;</code>。如此，s 里起初有一个偶回文 <code>abba</code> 和一个奇回文 <code>opxpo</code>，被转换为 <code>#a#b#b#a#</code> 和 <code>#o#p#x#p#o#</code>，长度都转换成了奇数。</p>
<h3 id="2-引入辅助数组-2">2 引入辅助数组</h3>
<blockquote>
<p>记录每个字符为中心的最长回文半径</p>
</blockquote>
<p>定义一个辅助数组 <code>int p[]</code>，其中 <code>p[i]</code> 表示以 i 为中心的<strong>最长回文的半径</strong>，例如：</p>
<table>
<thead>
<tr>
<th>i</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
<th>12</th>
<th>13</th>
<th>14</th>
<th>15</th>
<th>16</th>
<th>17</th>
<th>18</th>
<th>19</th>
<th>20</th>
<th>21</th>
<th>22</th>
</tr>
</thead>
<tbody>
<tr>
<td>s_new[i]</td>
<td>$</td>
<td>#</td>
<td>a</td>
<td>#</td>
<td>b</td>
<td>#</td>
<td>b</td>
<td>#</td>
<td>a</td>
<td>#</td>
<td>h</td>
<td>#</td>
<td>o</td>
<td>#</td>
<td>p</td>
<td>#</td>
<td>x</td>
<td>#</td>
<td>p</td>
<td>#</td>
<td>o</td>
<td>#</td>
<td>^</td>
</tr>
<tr>
<td>p[i]</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>1</td>
<td>2</td>
<td>5</td>
<td>2</td>
<td>1</td>
<td>2</td>
<td>1</td>
<td>2</td>
<td>1</td>
<td>2</td>
<td>1</td>
<td>2</td>
<td>1</td>
<td>6</td>
<td>1</td>
<td>2</td>
<td>1</td>
<td>2</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>可以看出， <code>p[i] - 1</code> 正好是<strong>原字符串中最长回文串的长度</strong>，因为此时的半径是添加过预处理符号的半径 。</p>
<h3 id="3-求解辅助数组-2">3 求解辅助数组</h3>
<blockquote>
<p>实现线性复杂度的关键</p>
</blockquote>
<p>接下来的重点就是求解 p 数组，如下图：</p>
<p><img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202112271559574.png" srcset="/img/loading.gif" lazyload alt=""><br>
设置两个变量，mx 和 id 。mx 代表以 id 为中心的最长回文的右边界，也就是 <code>mx = id + p[id]</code>。</p>
<p>假设我们现在求 <code>p[i]</code>，也就是以 i 为中心的最长回文半径，如果 <code>i &lt; mx</code>，如上图，那么：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 求解辅助数组的核心</span><br><span class="hljs-keyword">if</span> (i &lt; mx)  <br>    p[i] = <span class="hljs-built_in">min</span>(p[<span class="hljs-number">2</span> * id - i], mx - i);<br></code></pre></td></tr></table></figure>
<p><code>2 * id - i</code> 为 i 关于 id 的对称点，即上图的 j 点，而 <strong><code>p[j]</code>表示以 j 为中心的最长回文半径</strong>，因此我们可以利用 <code>p[j]</code> 来加快查找。</p>
<p>根据回文的性质，<code>p[i]</code> 的值基于以下三种情况得出：</p>
<p>（1）<strong>j 的回文串有一部分在 id 的之外</strong>，如下图：<img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202112271610871.png" srcset="/img/loading.gif" lazyload alt=""><br>
上图中，黑线为 id 的回文，i 与 j 关于 id 对称，红线为 j 的回文。那么根据代码此时 <code>p[i] = mx - i</code>，即紫线。那么 <code>p[i]</code> 还可以更大么？答案是不可能！见下图：<img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202112271610179.png" srcset="/img/loading.gif" lazyload alt=""><br>
假设右侧新增的紫色部分是 <code>p[i]</code> 可以增加的部分，那么根据回文的性质，a 等于 d ，也就是说 id 的回文不仅仅是黑线，而是黑线+两条紫线，矛盾，所以假设不成立，故 <code>p[i] = mx - i</code>，不可以再增加一分。</p>
<p>（2）<strong>j 回文串全部在 id 的内部</strong>，如下图：<img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202112271610855.png" srcset="/img/loading.gif" lazyload alt=""><br>
根据代码，此时 <code>p[i] = p[j]</code>，那么 <code>p[i]</code> 还可以更大么？答案亦是不可能！见下图：<img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202112271610897.png" srcset="/img/loading.gif" lazyload alt=""><br>
假设右侧新增的红色部分是 <code>p[i]</code> 可以增加的部分，那么根据回文的性质，a 等于 b ，也就是说 j 的回文应该再加上 a 和 b ，矛盾，所以假设不成立。故 <code>p[i] = p[j]</code>，也不可以再增加一分。</p>
<p>（3）<strong>j 回文串左端正好与 id 的回文串左端重合</strong>，见下图：<img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202112271611950.png" srcset="/img/loading.gif" lazyload alt=""><br>
根据代码，此时 <code>p[i] = p[j]</code> 或 <code>p[i] = mx - i</code>，并且 <code>p[i]</code> 还可以继续增加，所以需要</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span> (s_new[i - p[i]] == s_new[i + p[i]]) <br>    p[i]++;<br></code></pre></td></tr></table></figure>
<h4 id="代码-2">代码</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">char</span> s[<span class="hljs-number">1000</span>];<br><span class="hljs-type">char</span> s_new[<span class="hljs-number">2000</span>];<br><span class="hljs-type">int</span> p[<span class="hljs-number">2000</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> len = <span class="hljs-built_in">strlen</span>(s);<br>    s_new[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;$&#x27;</span>;<br>    s_new[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;#&#x27;</span>;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>        s_new[j++] = s[i];<br>        s_new[j++] = <span class="hljs-string">&#x27;#&#x27;</span>;<br>    &#125;<br>    s_new[j++] = <span class="hljs-string">&#x27;^&#x27;</span>;  <span class="hljs-comment">// 别忘了哦</span><br>    s_new[j] = <span class="hljs-string">&#x27;\0&#x27;</span>;   <span class="hljs-comment">// 这是一个好习惯</span><br>    <span class="hljs-keyword">return</span> j;  <span class="hljs-comment">// 返回 s_new 的长度</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Manacher</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> len = <span class="hljs-built_in">Init</span>();  <span class="hljs-comment">// 取得新字符串长度并完成向 s_new 的转换</span><br>    <span class="hljs-type">int</span> max_len = <span class="hljs-number">-1</span>;  <span class="hljs-comment">// 最长回文长度</span><br>    <span class="hljs-type">int</span> id;<br>    <span class="hljs-type">int</span> mx = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; mx)<br>            p[i] = <span class="hljs-built_in">min</span>(p[<span class="hljs-number">2</span> * id - i], mx - i);  <br>        	<span class="hljs-comment">// 需搞清楚上面那张图含义，mx 和 2*id-i 的含义</span><br>        <span class="hljs-keyword">else</span><br>            p[i] = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span> (s_new[i - p[i]] == s_new[i + p[i]])  <span class="hljs-comment">// 不需边界判断，因为左有 $，右有 ^</span><br>            p[i]++;<br>        <span class="hljs-comment">// 我们每走一步 i，都要和 mx 比较，我们希望 mx 尽可能的远，</span><br>        <span class="hljs-comment">// 这样才能更有机会执行 if (i &lt; mx)这句代码，从而提高效率</span><br>        <span class="hljs-comment">// 更新 mx</span><br>        <span class="hljs-keyword">if</span> (mx &lt; i + p[i]) &#123;<br>            id = i;<br>            mx = i + p[i];<br>        &#125;<br>        max_len = <span class="hljs-built_in">max</span>(max_len, p[i] - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> max_len;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入字符串：&quot;</span>)) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, s);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;最长回文长度为 %d\n\n&quot;</span>, <span class="hljs-built_in">Manacher</span>());<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="算法复杂度分析-2">算法复杂度分析</h3>
<p>根据（1）（2）（3），很容易推出 Manacher 算法的最坏情况，即为字符串内全是相同字符的时候。在这里我们重点研究 <code>Manacher()</code> 中的 for 语句，推算发现 for 语句内平均访问每个字符 5 次，即时间复杂度为：$T_{worst}(n)=O(n)$</p>
<p>同理，我们也很容易知道最佳情况下的时间复杂度，即字符串内字符各不相同的时候。推算得平均访问每个字符 4 次，即时间复杂度为：$T_{best}(n)=O(n)$。</p>
<p>综上，<strong>Manacher 算法的时间复杂度为 O(n)</strong>。</p>
<h2 id="KMP算法-2">KMP算法</h2>
<p>解决字符串匹配问题，包括几个重点：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>求解next数组</p>
</li>
<li class="lvl-2">
<p>根据next数组来进行模式匹配</p>
</li>
</ul>
<h3 id="求解next数组-2">求解next数组</h3>
<p>next数组的<strong>定义</strong>：针对pattern模式串<code>s</code>，<em><code>next[i]</code> 表示子串<code>s[0...i]</code>的【最长相等前后缀】中【前缀的最后一位】的下标。</em></p>
<h5 id="手动模拟-2">手动模拟</h5>
<p>根据定义进行手动模拟即可，无对应相等前后缀的值赋 -1。</p>
<h5 id="递推求解-代码实现-2">递推求解 / 代码实现</h5>
<p>两个指针的含义：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>i</code>： 从1 ~ len - 1之间遍历，表示当前处理的字符；</p>
</li>
<li class="lvl-2">
<p><code>j</code>： 表示【当前的相等前后缀】中 【前缀】的最后一位 的下标；</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>判断 <code>s[i] == s[j + 1] </code>， 即判断当前相等前后缀是否能扩展到下一位；</p>
</li>
<li class="lvl-4">
<p>如果不能就要向前回溯，为了<strong>减少回溯次数</strong>（使找到的相等前后缀尽可能长，<code>j</code>尽可能大），每次回退使<code>j = next[j]</code> 直至其回退为 -1；</p>
<p>为什么回退时使 <code>j = next[j]</code> 能够最小化回溯次数？我们根据后面讲解的“实际求解过程”进行手动模拟，并结合下图的例子来实际理解（用图中的字符串做求解next数组的实例练习）：</p>
<img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205111123247.png" srcset="/img/loading.gif" lazyload style="zoom:33%;" />
<p>此时，最长的相等前后缀为 $aabaa$，并且在 $i$ 处失配。为了使回溯次数尽可能少，就要使得 $j$ 尽可能地大，方法就是寻找 $aabaa$ 中的最长相等前后缀的位置。根据next数组的含义，自然应该将 $j$ 移动到 $next[j]$ 的位置。</p>
</li>
</ul>
</li>
</ul>
<p>实际求解过程：</p>
<ol>
<li class="lvl-4">
<p>初始化 next 数组，令 <code>j = next[0] = -1</code>；</p>
</li>
<li class="lvl-4">
<p>让 <code>i</code> 在 1 ~ len - 1 范围之间遍历，对每个 <code>i</code> 执行第三步与第四步，以求解 <code>next[i]</code>；</p>
</li>
<li class="lvl-4">
<p>不断令 <code>j = next[j]</code>， 直到 <code>j</code> 回退为 -1，或是 <code>s[i] == s[j + 1]</code> 成立。</p>
</li>
<li class="lvl-4">
<p>如果 <code>s[i] == s[j + 1]</code> ， 则 <code>j</code> 自增 1 后 <code>next[i] = j</code>， 否则直接令 <code>next[i] = j</code>。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">getNext</span><span class="hljs-params">(string s)</span> </span>&#123;<br>	<span class="hljs-type">int</span> j = <span class="hljs-number">-1</span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">next</span><span class="hljs-params">(s.size())</span></span>;<br>    next[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-keyword">while</span>(j != <span class="hljs-number">-1</span> &amp;&amp; s[i] != s[j + <span class="hljs-number">1</span>]) &#123;<br>            j = next[j];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(s[i] == s[j + <span class="hljs-number">1</span>]) &#123;<br>        	j++;<br>        &#125;<br>        next[i] = j;<br>    &#125;<br>    <span class="hljs-keyword">return</span> next;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="模式匹配-2">模式匹配</h3>
<p>KMP的原则在于：<em>文本串的指针 <code>i</code> 绝对不回溯，而模式串的指针 <code>j</code>  也在回溯的过程中保持其尽可能大。</em></p>
<p>在模式匹配中，next数组的<strong>含义</strong>：<strong>当 j + 1 位失配时，j 应该回退到的位置</strong>。</p>
<p>模式匹配的求解过程与求解next数组非常相似，实际上求解next数组的过程就是模式串pattern进行自我匹配（并计算得到数组的值）的过程，而KMP算法是将pattern与目标串text进行匹配。</p>
<p>KMP算法进行模式匹配的作用不唯一，可以用于求解<strong>匹配是否成功</strong>，也可以用于求解<strong>模式串出现的次数</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 匹配是否成功</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">kmp</span><span class="hljs-params">(string text, string pattern)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = text.<span class="hljs-built_in">size</span>(), m = pattern.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">-1</span>;<br>    vector&lt;<span class="hljs-type">int</span>&gt; next = <span class="hljs-built_in">getNext</span>(pattern);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">while</span>(j != <span class="hljs-number">-1</span> &amp;&amp; text[i] != pattern[j + <span class="hljs-number">1</span>]) &#123;<br>            j = next[j];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(text[i] == pattern[j + <span class="hljs-number">1</span>]) &#123;<br>            j++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(j == m - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 统计模式串出现的次数</span><br><span class="hljs-comment">// 重点要注意模式串在文本串中多次的出现可能会【重叠】</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kmp</span><span class="hljs-params">(string text, string pattern)</span> </span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> n = text.<span class="hljs-built_in">size</span>()， m = pattern.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">-1</span>;<br>    vector&lt;<span class="hljs-type">int</span>&gt; next = <span class="hljs-built_in">getNext</span>(string pattern);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">while</span>(j != <span class="hljs-number">-1</span> &amp;&amp; text[i] != pattern[j + <span class="hljs-number">1</span>]) &#123;<br>            j = next[j];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(text[i] == pattern[j + <span class="hljs-number">1</span>]) &#123;<br>            j++;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 统计次数的代码唯一的区别如下</span><br>        <span class="hljs-keyword">if</span>(j == m - <span class="hljs-number">1</span>) &#123;<br>            ans++;<br>            j = next[j];		<span class="hljs-comment">// 因为模式串的出现可能会重叠，所以不能从头开始匹配，否则会少统计重叠的部分</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="优化-nextval数组-2">优化 - nextval数组</h3>
<p>next数组对应的模式匹配在失配的情况下，<code>j</code> 指针有可能产生多次无用的回溯（一直失配，直至 <code>j</code> 为-1）。具体情况如下，结合图示例子来理解：</p>
<img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205111539729.png" srcset="/img/loading.gif" lazyload style="zoom:33%;" />
<p>图中黑色的指针 $i, j$ 代表生成 $nextval$ 数组时的指针，红色的指针 $i, j$ 代表进行模式匹配时的指针。此处失配后，根据 $next$ 数组可以看到，会不断进行回退：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>第一次失配：此时 $j + 1 = 5$ 处为 $b$，先回退到 $j = next[4] = 2$， 显然此时仍然失配；</p>
</li>
<li class="lvl-2">
<p>第二次失配：此时 $j + 1 = 3$ 处仍然为 $b$，再回退到 $j = next[2] = 0$，显然此时再次失配；</p>
</li>
<li class="lvl-2">
<p>第三次失配：此时 $j + 1 = 1$ 处又一次为 $b$，继续回退到 $j = next[1] = -1$ 处，回退停止。</p>
</li>
</ul>
<p>综上三次失配与回退可以发现：每次回退之后的 $j + 1$ 处的字符都相等为 $b$ ，失配是显而易见的，白白进行了多次比较。</p>
<p>$nextval$ 数组就是避免了这种 <em>$patter[j + 1] == patter[next[j] + 1]$</em> 的情况，一次性跳跃到正确的比对位置。</p>
<p>在进行模式匹配时，模式串在 $i$ 处失配意味着 $i + 1$ 与文本串对应位置不符，即 $i + 1$ 处的字符有问题（上图例子中的$b$）。所以如果再次跳回一个同样的错误字符，即 $j + 1$ 处等于 $i + 1$处的失配字符时，肯定还需要再重复回退一次，所以具体实现代码如下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">getNextval</span><span class="hljs-params">(string pattern)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = pattern.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextval</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">-1</span>;<br>    nextval[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span>(j != <span class="hljs-number">-1</span> &amp;&amp; pattern[i] != pattern[j + <span class="hljs-number">1</span>]) &#123;		<br>        <span class="hljs-comment">// 根据nextval的定义，求解数组和模式匹配中的while都可以改成if，因为至多只会执行一次</span><br>        	j = <span class="hljs-built_in">nextval</span>(j)；    <br>        &#125;<br>        <span class="hljs-keyword">if</span>(pattern[i] == pattern[j + <span class="hljs-number">1</span>]) &#123;<br>            j++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(j == <span class="hljs-number">-1</span> || pattern[i + <span class="hljs-number">1</span>] != pattern[j + <span class="hljs-number">1</span>]) &#123;<br>            nextval[i] = j;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            nextval[i] = nextval[j];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>至此，$nextval$ 数组虽然失去了其定义中最大前后缀的含义，但是其指向了<strong>每次回退时的真正最佳位置</strong>，减少了无效的回退操作。</p>
<h3 id="时间复杂度-2">时间复杂度</h3>
<p><code>O(n + m)</code> ： 其中 <code>n</code>为目标字符串text的长度， <code>m</code> 为模式串pattern的长度</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>计算next数组需要 <code>O(m)</code>；</p>
</li>
<li class="lvl-2">
<p>进行模式匹配需要 <code>O(n)</code>；</p>
</li>
</ul>
<h2 id="周期字符串判别问题-2">周期字符串判别问题</h2>
<p><strong>周期字符串判别问题</strong>有两种常见解法：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>双倍字符串方法</p>
</li>
<li class="lvl-2">
<p>KMP 方法</p>
</li>
</ul>
<p>本题的难点在于证明与推演，其解题思路与代码都比较简单。</p>
<h3 id="问题-2">问题</h3>
<p>判断一个字符串是否由其一个子串重复多次构成。</p>
<p>例如：字符串 <code>&quot;abcabc&quot;</code> 是由子串 <code>&quot;abc&quot;</code> 重复两次构成的。</p>
<h3 id="双倍字符串方法-2">双倍字符串方法</h3>
<p>把字符串翻倍，掐头去尾，如果原字符串在其中，那么原字符串就是周期串 。</p>
<p>假设字符串是 <code>s</code> ，把它的头尾字符分别染上黄色和蓝色：</p>
<p><img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205151303835.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>把字符串 <code>s</code> 接到自身后面，然后掐头去尾，形成新字符串 <code>s'</code>：</p>
<p><img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205151303981.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h5 id="匹配意味着周期性-2">匹配意味着周期性</h5>
<p>下面讨论原字符串 <code>s</code> 在新字符串 <code>s'</code> 中存在的情况。</p>
<p>一步一步对各部分涂色，使得相等的字符串颜色一样 。</p>
<p><img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205151304030.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>经过几轮的染色，可以看到最终 <code>s</code> 确实是一个周期串。</p>
<p>是否巧合？可以做一般性说明。</p>
<p>下图，不妨设右边匹配的少一些。对其中的任一字符 <code>A</code> ，可以按照如下的规则推演：</p>
<p><img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205151304895.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>如此，任一此区间上的字符 <code>A</code> 会在 <code>s</code> 中周期性出现。</p>
<p>即说明字符串 <code>s</code> 是周期串。</p>
<h5 id="周期性意味着匹配-2">周期性意味着匹配</h5>
<p>反过来，如果一个字符串 <code>s</code> 是周期串，那么它一定在对应的 <code>s'</code> 中吗？</p>
<p>任何一个周期串可以表达为： 由某个模式子串的重复多次构成 。</p>
<p><img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205151305541.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>将周期串 <code>s</code> 的头字符对齐在第一个模式串后面， 每次右移一个模式串的长度。</p>
<p>可知，<code>s</code> 会在 <code>s'</code> 中有匹配，且可以有多个匹配。</p>
<p><img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205151305963.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>图中可看出， 因为模式串重复 <code>n</code> 次，所以会有 <code>n</code> 次匹配 。</p>
<p>构造双倍串 <code>s'</code> 时，移除头尾字符， 正是为了剔除最左和最右的两次必然匹配。 只有中间的 <code>n</code> 次匹配才用到了周期串重复模式串的性质。</p>
<h5 id="结论-2">结论</h5>
<p>综上两方面说明了充分性和必要性，结论：</p>
<p>如果字符串在其掐头去尾的双倍字符串中，它就是周期串 。</p>
<h3 id="KMP-方法-2">KMP 方法</h3>
<p>假设要判断的字符串叫做 <code>s</code> ，将其尾巴字符标记为蓝色。</p>
<p>取 <code>q</code> 为不包含尾巴字符的前缀。</p>
<p><img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205151305388.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>取 <code>c</code> 为 <code>q</code> 的最长前后公共缀。</p>
<p>前后公共缀的意思是，它是既出现在字符串的最前面，也出现在字符串的最后面的真子串 。</p>
<p>举例来说，比如 <code>s</code> 是字符串串 <code>&quot;abcabcabc&quot;</code> ，<code>q</code> 则是 <code>&quot;abcabcab&quot;</code> 。</p>
<p><code>q</code> 的最长前后公共缀 <code>c</code> 则是 <code>&quot;abcab&quot;</code> 。</p>
<p><img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205151305522.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>将说明，<code>s</code> 是周期串等价于 <code>len(s)</code> 是 <code>len(q)-len(c)</code> 的倍数 。</p>
<h5 id="必要性说明-2">必要性说明</h5>
<p>假设字符串 <code>s</code> 是一个周期串，它由模式串 <code>p</code> 重复多次构成。</p>
<p><img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205151305620.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>现在， 取 <code>c1</code> 为 <code>q</code> 中剔去一个模式串 <code>p</code> 后的后缀 。</p>
<p><img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205151306852.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>显然，字符串 <code>c1</code> 是 <code>q</code> 的一个 <a target="_blank" rel="noopener" href="https://writings.sh/post/algorithm-repeated-string-pattern#what-is-common-prefix-and-suffix">前后公共缀</a>。</p>
<p>比如周期串 <code>&quot;abcabcabc&quot;</code> ，对应的 <code>c1</code> 是 <code>&quot;abcab&quot;</code> 。</p>
<p><img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205151306288.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>可以证明，<code>c1</code> 就是 <code>q</code> <strong>最长的</strong>前后公共缀 <code>c</code> ，详细可展开下面内容。</p>
<details open="" style="padding: 0px; margin: 0px;"><summary style="padding: 0px; margin: 0px; color: rgb(197, 142, 4); outline: 0px; cursor: pointer;"><span class="MathJax_Preview" style="padding: 0px; margin: 0px; color: inherit;"></span><span id="MathJax-Element-1-Frame" class="mjx-chtml MathJax_CHTML" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mstyle displaystyle=&quot;true&quot;><mi>c</mi><mn>1</mn></mstyle></math>" role="presentation" style="padding: 1px 0px; margin: 0px; outline: 0px; display: inline-block; line-height: 0; text-indent: 0px; text-align: left; text-transform: none; font-style: normal; font-weight: normal; font-size: 20.4px; letter-spacing: normal; overflow-wrap: normal; word-spacing: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; position: relative;"><span id="MJXc-Node-1" class="mjx-math" aria-hidden="true" style="padding: 0px; margin: 0px; display: inline-block; border-collapse: separate; border-spacing: 0px;"><span id="MJXc-Node-2" class="mjx-mrow" style="padding: 0px; margin: 0px; display: inline-block; text-align: left; box-sizing: content-box !important;"><span id="MJXc-Node-3" class="mjx-mstyle" style="padding: 0px; margin: 0px; display: inline-block; text-align: left; box-sizing: content-box !important;"><span id="MJXc-Node-4" class="mjx-mrow" style="padding: 0px; margin: 0px; display: inline-block; text-align: left; box-sizing: content-box !important;"><span id="MJXc-Node-5" class="mjx-mi" style="padding: 0px; margin: 0px; display: inline-block; text-align: left; box-sizing: content-box !important;"><span class="mjx-char MJXc-TeX-math-I" style="padding: 0.199em 0px 0.297em; margin: 0px; display: block; text-align: left; box-sizing: content-box !important; white-space: pre; font-family: MJXc-TeX-math-I, MJXc-TeX-math-Ix, MJXc-TeX-math-Iw;">c</span></span><span id="MJXc-Node-6" class="mjx-mn" style="padding: 0px; margin: 0px; display: inline-block; text-align: left; box-sizing: content-box !important;"><span class="mjx-char MJXc-TeX-main-R" style="padding: 0.395em 0px 0.346em; margin: 0px; display: block; text-align: left; box-sizing: content-box !important; white-space: pre; font-family: MJXc-TeX-main-R, MJXc-TeX-main-Rw;">1</span></span></span></span></span></span><span class="MJX_Assistive_MathML" role="presentation" style="padding: 1px 0px 0px !important; margin: 0px; top: 0px; left: 0px; clip: rect(1px, 1px, 1px, 1px); user-select: none; position: absolute !important; border: 0px !important; height: 1px !important; width: 1px !important; overflow: hidden !important; display: block !important;"><math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mi>c</mi><mn>1</mn></mstyle></math></span></span><span>&nbsp;</span>就是<span>&nbsp;</span><span class="MathJax_Preview" style="padding: 0px; margin: 0px; color: inherit;"></span><span id="MathJax-Element-2-Frame" class="mjx-chtml MathJax_CHTML" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mstyle displaystyle=&quot;true&quot;><mi>q</mi></mstyle></math>" role="presentation" style="padding: 1px 0px; margin: 0px; outline: 0px; display: inline-block; line-height: 0; text-indent: 0px; text-align: left; text-transform: none; font-style: normal; font-weight: normal; font-size: 20.4px; letter-spacing: normal; overflow-wrap: normal; word-spacing: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; position: relative;"><span id="MJXc-Node-7" class="mjx-math" aria-hidden="true" style="padding: 0px; margin: 0px; display: inline-block; border-collapse: separate; border-spacing: 0px;"><span id="MJXc-Node-8" class="mjx-mrow" style="padding: 0px; margin: 0px; display: inline-block; text-align: left; box-sizing: content-box !important;"><span id="MJXc-Node-9" class="mjx-mstyle" style="padding: 0px; margin: 0px; display: inline-block; text-align: left; box-sizing: content-box !important;"><span id="MJXc-Node-10" class="mjx-mrow" style="padding: 0px; margin: 0px; display: inline-block; text-align: left; box-sizing: content-box !important;"><span id="MJXc-Node-11" class="mjx-mi" style="padding: 0px; margin: 0px; display: inline-block; text-align: left; box-sizing: content-box !important;"><span class="mjx-char MJXc-TeX-math-I" style="padding: 0.199em 0.014em 0.493em 0px; margin: 0px; display: block; text-align: left; box-sizing: content-box !important; white-space: pre; font-family: MJXc-TeX-math-I, MJXc-TeX-math-Ix, MJXc-TeX-math-Iw;">q</span></span></span></span></span></span><span class="MJX_Assistive_MathML" role="presentation" style="padding: 1px 0px 0px !important; margin: 0px; top: 0px; left: 0px; clip: rect(1px, 1px, 1px, 1px); user-select: none; position: absolute !important; border: 0px !important; height: 1px !important; width: 1px !important; overflow: hidden !important; display: block !important;"><math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mi>q</mi></mstyle></math></span></span><span>&nbsp;</span>最长的前后公共缀<span>&nbsp;</span><span class="MathJax_Preview" style="padding: 0px; margin: 0px; color: inherit;"></span><span id="MathJax-Element-3-Frame" class="mjx-chtml MathJax_CHTML" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mstyle displaystyle=&quot;true&quot;><mi>c</mi></mstyle></math>" role="presentation" style="padding: 1px 0px; margin: 0px; outline: 0px; display: inline-block; line-height: 0; text-indent: 0px; text-align: left; text-transform: none; font-style: normal; font-weight: normal; font-size: 20.4px; letter-spacing: normal; overflow-wrap: normal; word-spacing: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; position: relative;"><span id="MJXc-Node-12" class="mjx-math" aria-hidden="true" style="padding: 0px; margin: 0px; display: inline-block; border-collapse: separate; border-spacing: 0px;"><span id="MJXc-Node-13" class="mjx-mrow" style="padding: 0px; margin: 0px; display: inline-block; text-align: left; box-sizing: content-box !important;"><span id="MJXc-Node-14" class="mjx-mstyle" style="padding: 0px; margin: 0px; display: inline-block; text-align: left; box-sizing: content-box !important;"><span id="MJXc-Node-15" class="mjx-mrow" style="padding: 0px; margin: 0px; display: inline-block; text-align: left; box-sizing: content-box !important;"><span id="MJXc-Node-16" class="mjx-mi" style="padding: 0px; margin: 0px; display: inline-block; text-align: left; box-sizing: content-box !important;"><span class="mjx-char MJXc-TeX-math-I" style="padding: 0.199em 0px 0.297em; margin: 0px; display: block; text-align: left; box-sizing: content-box !important; white-space: pre; font-family: MJXc-TeX-math-I, MJXc-TeX-math-Ix, MJXc-TeX-math-Iw;">c</span></span></span></span></span></span><span class="MJX_Assistive_MathML" role="presentation" style="padding: 1px 0px 0px !important; margin: 0px; top: 0px; left: 0px; clip: rect(1px, 1px, 1px, 1px); user-select: none; position: absolute !important; border: 0px !important; height: 1px !important; width: 1px !important; overflow: hidden !important; display: block !important;"><math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mi>c</mi></mstyle></math></span></span><span>&nbsp;</span>的详细说明</summary><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;">采用反证法，假设存在一个字符串<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">c'</code><span>&nbsp;</span>也是<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">q</code><span>&nbsp;</span>的前后公共缀，而且它比<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">c1</code><span>&nbsp;</span>长一位。</p><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;">另外，假设尾巴字符叫做<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">A</code><span>&nbsp;</span>。</p><figure style="padding: 0px; margin: 30px auto; width: 768px;"><img class="post-img lazyload max-width-100 medium-zoom-image" src="https://writings.sh/assets/images/posts/algorithm-repeated-string-pattern/repeated-string-pattern-kmp-5-1.jpeg" data-src="/assets/images/posts/algorithm-repeated-string-pattern/repeated-string-pattern-kmp-5-1.jpeg" alt="" data-loaded="true" style="padding: 0px; margin: 0px auto; display: block; max-width: 100%; cursor: zoom-in; transition: transform 0.3s cubic-bezier(0.2, 0, 0.2, 1) 0s !important;"></figure><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;"></p><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;">现在有两条性质：</p><ol style="padding: 0px 0px 0px 30px; margin: 15px 0px; list-style: decimal;"><li style="padding: 0px; margin: 0px;">周期性质：字符串<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">s</code><span>&nbsp;</span>的周期性。</li><li style="padding: 0px; margin: 0px;">前后公共缀性质：<code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">c'</code><span>&nbsp;</span>是<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">q</code><span>&nbsp;</span>的前后公共缀。</li></ol><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;">以下，反复利用此两条性质：</p><ol style="padding: 0px 0px 0px 30px; margin: 15px 0px; list-style: decimal;"><li style="padding: 0px; margin: 0px;"><p style="padding: 0px; margin: 0px 0px 15px; letter-spacing: 0.5px;">由于「前后公共缀性质」，<code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">q</code><span>&nbsp;</span>的第一个字符也是<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">A</code>。</p><figure style="padding: 0px; margin: 30px auto; width: 738px;"><img class="post-img lazyload max-width-100 medium-zoom-image" src="https://writings.sh/assets/images/posts/algorithm-repeated-string-pattern/repeated-string-pattern-kmp-5-2.jpeg-small.svg" data-src="/assets/images/posts/algorithm-repeated-string-pattern/repeated-string-pattern-kmp-5-2.jpeg" alt="" style="padding: 0px; margin: 0px auto; display: block; max-width: 100%; cursor: zoom-in; transition: transform 0.3s cubic-bezier(0.2, 0, 0.2, 1) 0s !important;"></figure><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;"></p></li><li style="padding: 0px; margin: 0px;"><p style="padding: 0px; margin: 0px 0px 15px; letter-spacing: 0.5px;">由于「周期性质」，后续的循环子串中的第一个字符也是<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">A</code><span>&nbsp;</span>。</p><figure style="padding: 0px; margin: 30px auto; width: 738px;"><img class="post-img lazyload max-width-100 medium-zoom-image" src="https://writings.sh/assets/images/posts/algorithm-repeated-string-pattern/repeated-string-pattern-kmp-5-3.jpeg-small.svg" data-src="/assets/images/posts/algorithm-repeated-string-pattern/repeated-string-pattern-kmp-5-3.jpeg" alt="" style="padding: 0px; margin: 0px auto; display: block; max-width: 100%; cursor: zoom-in; transition: transform 0.3s cubic-bezier(0.2, 0, 0.2, 1) 0s !important;"></figure><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;"></p></li><li style="padding: 0px; margin: 0px;"><p style="padding: 0px; margin: 0px 0px 15px; letter-spacing: 0.5px;">由于「前后公共缀性质」，<code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">q</code><span>&nbsp;</span>的第二个字符也是<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">A</code>。</p><figure style="padding: 0px; margin: 30px auto; width: 738px;"><img class="post-img lazyload max-width-100 medium-zoom-image" src="https://writings.sh/assets/images/posts/algorithm-repeated-string-pattern/repeated-string-pattern-kmp-5-4.jpeg-small.svg" data-src="/assets/images/posts/algorithm-repeated-string-pattern/repeated-string-pattern-kmp-5-4.jpeg" alt="" style="padding: 0px; margin: 0px auto; display: block; max-width: 100%; cursor: zoom-in; transition: transform 0.3s cubic-bezier(0.2, 0, 0.2, 1) 0s !important;"></figure><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;"></p></li><li style="padding: 0px; margin: 0px;"><p style="padding: 0px; margin: 0px 0px 15px; letter-spacing: 0.5px;">由于「周期性质」，后续的循环子串中的第二个字符也是<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">A</code><span>&nbsp;</span>。</p><figure style="padding: 0px; margin: 30px auto; width: 738px;"><img class="post-img lazyload max-width-100 medium-zoom-image" src="https://writings.sh/assets/images/posts/algorithm-repeated-string-pattern/repeated-string-pattern-kmp-5-5.jpeg-small.svg" data-src="/assets/images/posts/algorithm-repeated-string-pattern/repeated-string-pattern-kmp-5-5.jpeg" alt="" style="padding: 0px; margin: 0px auto; display: block; max-width: 100%; cursor: zoom-in; transition: transform 0.3s cubic-bezier(0.2, 0, 0.2, 1) 0s !important;"></figure><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;"></p></li><li style="padding: 0px; margin: 0px;"><p style="padding: 0px; margin: 0px 0px 15px; letter-spacing: 0.5px;">如上反复进行，最终，推断整个<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">q</code><span>&nbsp;</span>以及<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">s</code><span>&nbsp;</span>都由字符<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">A</code><span>&nbsp;</span>构成。</p><figure style="padding: 0px; margin: 30px auto; width: 738px;"><img class="post-img lazyload max-width-100 medium-zoom-image" src="https://writings.sh/assets/images/posts/algorithm-repeated-string-pattern/repeated-string-pattern-kmp-5-6.jpeg-small.svg" data-src="/assets/images/posts/algorithm-repeated-string-pattern/repeated-string-pattern-kmp-5-6.jpeg" alt="" style="padding: 0px; margin: 0px auto; display: block; max-width: 100%; cursor: zoom-in; transition: transform 0.3s cubic-bezier(0.2, 0, 0.2, 1) 0s !important;"></figure><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;"></p><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;">此时的模式串<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">p</code><span>&nbsp;</span>即单个字符<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">A</code><span>&nbsp;</span>。</p><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;">根据<span>&nbsp;</span><a target="_blank" rel="noopener" href="https://writings.sh/post/algorithm-repeated-string-pattern#kmp-c1-definition" style="padding: 0px; margin: 0px; color: rgb(197, 142, 4); text-decoration: none;">前面的定义</a><span>&nbsp;</span>可以知道，此时的<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">c1</code><span>&nbsp;</span>如上图，长度是<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">len(q)-1</code><span>&nbsp;</span>。</p><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;">前后公共缀是真子串，显然，不会存在比它更长的前后公共缀，造成矛盾。</p></li></ol><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;">因此，所定义的<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">c1</code><span>&nbsp;</span>就是<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">q</code><span>&nbsp;</span>的最长前后公共缀<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">c</code><span>&nbsp;</span>。</p></details>
<p>根据 <a target="_blank" rel="noopener" href="https://writings.sh/post/algorithm-repeated-string-pattern#kmp-c1-definition">前面的定义</a> ，可知周期长度是 <code>len(p) = len(q)-len(c)</code> 。</p>
<p>因为字符串 <code>s</code> 是周期串，所以其长度一定是周期长度的倍数。</p>
<p>必要性得到说明。</p>
<h5 id="充分性说明-2">充分性说明</h5>
<p>令 <code>d = len(q)-len(c)</code> ， 如果 <code>s</code> 的长度是 <code>d</code> 的倍数，是否 <code>s</code> 一定是周期串？</p>
<p>此时 <code>s</code> 一定可以每 <code>d</code> 个字符一份，切分为整数个小份串：</p>
<p><img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205151307596.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>同样假设尾巴字符是蓝色的 <code>A</code> ， 剔除尾巴字符后 <code>q</code> 和 其最长前后公共缀 <code>c</code> 如下所示：</p>
<p><img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205151307241.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>首先，显然 <code>len(c)+1</code> 是 <code>d</code> 的倍数。</p>
<details open="" style="padding: 0px; margin: 0px;"><summary style="padding: 0px; margin: 0px; color: rgb(197, 142, 4); outline: 0px; cursor: pointer;"><span class="MathJax_Preview" style="padding: 0px; margin: 0px; color: inherit;"></span><span id="MathJax-Element-4-Frame" class="mjx-chtml MathJax_CHTML" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mstyle displaystyle=&quot;true&quot;><mi>c</mi></mstyle></math>" role="presentation" style="padding: 1px 0px; margin: 0px; outline: 0px; display: inline-block; line-height: 0; text-indent: 0px; text-align: left; text-transform: none; font-style: normal; font-weight: normal; font-size: 20.4px; letter-spacing: normal; overflow-wrap: normal; word-spacing: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; position: relative;"><span id="MJXc-Node-17" class="mjx-math" aria-hidden="true" style="padding: 0px; margin: 0px; display: inline-block; border-collapse: separate; border-spacing: 0px;"><span id="MJXc-Node-18" class="mjx-mrow" style="padding: 0px; margin: 0px; display: inline-block; text-align: left; box-sizing: content-box !important;"><span id="MJXc-Node-19" class="mjx-mstyle" style="padding: 0px; margin: 0px; display: inline-block; text-align: left; box-sizing: content-box !important;"><span id="MJXc-Node-20" class="mjx-mrow" style="padding: 0px; margin: 0px; display: inline-block; text-align: left; box-sizing: content-box !important;"><span id="MJXc-Node-21" class="mjx-mi" style="padding: 0px; margin: 0px; display: inline-block; text-align: left; box-sizing: content-box !important;"><span class="mjx-char MJXc-TeX-math-I" style="padding: 0.199em 0px 0.297em; margin: 0px; display: block; text-align: left; box-sizing: content-box !important; white-space: pre; font-family: MJXc-TeX-math-I, MJXc-TeX-math-Ix, MJXc-TeX-math-Iw;">c</span></span></span></span></span></span><span class="MJX_Assistive_MathML" role="presentation" style="padding: 1px 0px 0px !important; margin: 0px; top: 0px; left: 0px; clip: rect(1px, 1px, 1px, 1px); user-select: none; position: absolute !important; border: 0px !important; height: 1px !important; width: 1px !important; overflow: hidden !important; display: block !important;"><math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mi>c</mi></mstyle></math></span></span><span>&nbsp;</span>的长度加一是<span>&nbsp;</span><span class="MathJax_Preview" style="padding: 0px; margin: 0px; color: inherit;"></span><span id="MathJax-Element-5-Frame" class="mjx-chtml MathJax_CHTML" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mstyle displaystyle=&quot;true&quot;><mi>d</mi></mstyle></math>" role="presentation" style="padding: 1px 0px; margin: 0px; outline: 0px; display: inline-block; line-height: 0; text-indent: 0px; text-align: left; text-transform: none; font-style: normal; font-weight: normal; font-size: 20.4px; letter-spacing: normal; overflow-wrap: normal; word-spacing: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; position: relative;"><span id="MJXc-Node-22" class="mjx-math" aria-hidden="true" style="padding: 0px; margin: 0px; display: inline-block; border-collapse: separate; border-spacing: 0px;"><span id="MJXc-Node-23" class="mjx-mrow" style="padding: 0px; margin: 0px; display: inline-block; text-align: left; box-sizing: content-box !important;"><span id="MJXc-Node-24" class="mjx-mstyle" style="padding: 0px; margin: 0px; display: inline-block; text-align: left; box-sizing: content-box !important;"><span id="MJXc-Node-25" class="mjx-mrow" style="padding: 0px; margin: 0px; display: inline-block; text-align: left; box-sizing: content-box !important;"><span id="MJXc-Node-26" class="mjx-mi" style="padding: 0px; margin: 0px; display: inline-block; text-align: left; box-sizing: content-box !important;"><span class="mjx-char MJXc-TeX-math-I" style="padding: 0.493em 0.003em 0.297em 0px; margin: 0px; display: block; text-align: left; box-sizing: content-box !important; white-space: pre; font-family: MJXc-TeX-math-I, MJXc-TeX-math-Ix, MJXc-TeX-math-Iw;">d</span></span></span></span></span></span><span class="MJX_Assistive_MathML" role="presentation" style="padding: 1px 0px 0px !important; margin: 0px; top: 0px; left: 0px; clip: rect(1px, 1px, 1px, 1px); user-select: none; position: absolute !important; border: 0px !important; height: 1px !important; width: 1px !important; overflow: hidden !important; display: block !important;"><math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mi>d</mi></mstyle></math></span></span><span>&nbsp;</span>的倍数的说明</summary><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;">根据<span>&nbsp;</span><a target="_blank" rel="noopener" href="https://writings.sh/post/algorithm-repeated-string-pattern#kmp-d-definition" style="padding: 0px; margin: 0px; color: rgb(197, 142, 4); text-decoration: none;"><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">d</code><span>&nbsp;</span>的定义</a>， 得<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">len(c) + 1 = len(q) - d + 1</code><span>&nbsp;</span>。</p><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;">又因<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">len(q) = len(s) - 1</code><span>&nbsp;</span>，且<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">len(s)</code><span>&nbsp;</span>可以写作<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">len(s) = k*d</code><span>&nbsp;</span>。</p><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;">所以<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">len(c) + 1 = k*d - d = (k-1)*d</code><span>&nbsp;</span>，是<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">d</code><span>&nbsp;</span>的倍数。</p></details>
<p>因此，在下图中， <code>c</code> 必然上下对齐于某个 <a target="_blank" rel="noopener" href="https://writings.sh/post/algorithm-repeated-string-pattern#kmp-small-pattern-p">小份串</a> 的开头。</p>
<p>又因 <code>len(c)+1 = (k-1)*d</code> ，所以 <code>c</code> 就是 <code>q</code> 中剔除第一个小份串 <code>p1</code> 的后缀 。</p>
<p><img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205151307726.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>下面将说明，<code>s</code> 是一个周期串。</p>
<p>在最后一个小份串，从尾部取倒数第 <code>j</code> 个字符 <code>B</code> ，反复推演， 可以知道前面的所有小份串的相同位置，都是字符 <code>B</code> 。</p>
<p><img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205151307501.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>上面的图中：</p>
<ol>
<li class="lvl-3">
<p>① 号推演，由于上面后缀和下面前缀相等。</p>
</li>
<li class="lvl-3">
<p>② 号推演，由于下面的小份串和上面的自身相等。</p>
</li>
<li class="lvl-3">
<p>如此，反复进行。</p>
</li>
</ol>
<p>对最后一个小份串上的所有字符， 都会在前面的小份串相同位置重复，那么 <code>s</code> 是一个周期串。</p>
<details open="" style="padding: 0px; margin: 0px;"><summary style="padding: 0px; margin: 0px; color: rgb(197, 142, 4); outline: 0px; cursor: pointer;">推演的一个细节处理</summary><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;">上面推演中的一个细节是，无法推演小份串的倒数第一个字符。</p><figure style="padding: 0px; margin: 30px auto; width: 768px;"><img class="post-img lazyload max-width-100 medium-zoom-image" src="https://writings.sh/assets/images/posts/algorithm-repeated-string-pattern/repeated-string-pattern-kmp-7-3.jpeg" data-src="/assets/images/posts/algorithm-repeated-string-pattern/repeated-string-pattern-kmp-7-3.jpeg" alt="" data-loaded="true" style="padding: 0px; margin: 0px auto; display: block; max-width: 100%; cursor: zoom-in; transition: transform 0.3s cubic-bezier(0.2, 0, 0.2, 1) 0s !important;"></figure><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;"></p><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;">原因在于，尾巴字符不在最长前后公共缀的范围内。</p><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;">细节处理就是，需要判断一次尾巴字符<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">A</code><span>&nbsp;</span>是否和 上一个小份串对应位置的字符相等。</p><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;">一旦此细节满足，即可完成整体推演过程，<code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">s</code><span>&nbsp;</span>就一定是一个周期串。</p><figure style="padding: 0px; margin: 30px auto; width: 768px;"><img class="post-img lazyload max-width-100 medium-zoom-image" src="https://writings.sh/assets/images/posts/algorithm-repeated-string-pattern/repeated-string-pattern-kmp-7-4.jpeg" data-src="/assets/images/posts/algorithm-repeated-string-pattern/repeated-string-pattern-kmp-7-4.jpeg" alt="" data-loaded="true" style="padding: 0px; margin: 0px auto; display: block; max-width: 100%; cursor: zoom-in; transition: transform 0.3s cubic-bezier(0.2, 0, 0.2, 1) 0s !important;"></figure><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;"></p></details>
<p>至此，充分性也说明完毕。</p>
<h5 id="KMP-算法求解-2">KMP 算法求解</h5>
<p>KMP 算法中的 Next 数组的含义就是前后公共缀的长度 ，即 <code>len(c) = next[n-1]</code> 。</p>
<p>由 KMP 算法预处理的时间复杂度 可知，此方法的时间复杂度是 <code>O(n)</code> ，空间复杂度是 <code>O(n)</code> 。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              

              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/09/15/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/" title="二叉搜索树">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">二叉搜索树</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/09/02/Algorithm/" title="算法基础">
                        <span class="hidden-mobile">算法基础</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>2022</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>TAO1st</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.1/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
