

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/avatar.png">
  <link rel="icon" href="/img/avatar.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#98a5ac">
  <meta name="author" content="tao1st">
  <meta name="keywords" content="">
  
    <meta name="description" content="区间信息的维护与查询 关注有关区间信息的一些列操作：   静态操作： 单点查询、前缀和查询、区间和查询、范围最值查询（Range Minimum Query, RMQ）；   动态操作： 单点修改、区间修改，以及修改后的所有查询问题。   以上这些问题，在不同使用场景下灵活使用以下的不同数据结构。 在线与离线 在区间查询、区间修改之类的问题中，描述题目输入时经常会用到“在线”、“离线”这些术语。">
<meta property="og:type" content="article">
<meta property="og:title" content="区间信息的维护与查询">
<meta property="og:url" content="https://tao1st.github.io/2022/02/23/%E5%8C%BA%E9%97%B4%E4%BF%A1%E6%81%AF%E7%9A%84%E7%BB%B4%E6%8A%A4%E4%B8%8E%E6%9F%A5%E8%AF%A2/index.html">
<meta property="og:site_name" content="tao1st.github.io">
<meta property="og:description" content="区间信息的维护与查询 关注有关区间信息的一些列操作：   静态操作： 单点查询、前缀和查询、区间和查询、范围最值查询（Range Minimum Query, RMQ）；   动态操作： 单点修改、区间修改，以及修改后的所有查询问题。   以上这些问题，在不同使用场景下灵活使用以下的不同数据结构。 在线与离线 在区间查询、区间修改之类的问题中，描述题目输入时经常会用到“在线”、“离线”这些术语。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202204241054724.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202204261027731.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205011625893.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205011711572.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205021237853.png">
<meta property="article:published_time" content="2022-02-23T06:42:49.000Z">
<meta property="article:modified_time" content="2022-12-26T04:55:49.176Z">
<meta property="article:author" content="tao1st">
<meta property="article:tag" content="前缀和">
<meta property="article:tag" content="差分数组">
<meta property="article:tag" content="树状数组(BIT)">
<meta property="article:tag" content="线段树(Segment Tree)">
<meta property="article:tag" content="分块">
<meta property="article:tag" content="RMQ问题(Range Maximum&#x2F;Minimum Query)">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202204241054724.png">
  
  
  
  <title>区间信息的维护与查询 - tao1st.github.io</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"tao1st.github.io","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":3},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>TAO1st</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/bk.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.5)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="区间信息的维护与查询"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-02-23 14:42" pubdate>
          2022年2月23日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          12k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          97 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">区间信息的维护与查询</h1>
            
            
              <div class="markdown-body">
                
                <h1>区间信息的维护与查询</h1>
<p>关注有关区间信息的一些列操作：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>静态操作：</p>
<p>单点查询、前缀和查询、区间和查询、范围最值查询（Range Minimum Query, RMQ）；</p>
</li>
<li class="lvl-2">
<p>动态操作：</p>
<p>单点修改、区间修改，以及修改后的所有查询问题。</p>
</li>
</ul>
<p>以上这些问题，在不同使用场景下灵活使用以下的不同数据结构。</p>
<h2 id="在线与离线">在线与离线</h2>
<p>在区间查询、区间修改之类的问题中，描述题目输入时经常会用到“在线”、“离线”这些术语。</p>
<p>在线和离线的含义其实和名字很贴近，关注的是<em>对于所有的输入是否要全部读入完毕后再进行处理</em>。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>在线</strong>：无需了解所有的输入操作，可以“走一步、做一步”，边读入边执行；</p>
<p>更多的设计类型题目都是在线算法思路更简明直接，尤其是带有“可持久化”字样的（主席树、可持久化线段树、可持久化字典树等）。</p>
<p><strong>强制在线</strong>：前后的输入存在耦合，无法使用离线思路来解决问题。比如当前读入的数据需要与上次的结果进行运算后使用。</p>
</li>
<li class="lvl-2">
<p><strong>离线</strong>：与在线相反，需要知道所有的操作输入，即“记录所有操作，最后再进行处理”。</p>
<p>代码量小，思路相对复杂。</p>
</li>
</ul>
<p>[(21条消息) <a target="_blank" rel="noopener" href="https://blog.csdn.net/jacksonhhhh/article/details/120812832">ACM] 在线 离线 强制在线_jacksonhhhh的博客-CSDN博客_强制在线</a></p>
<h2 id="前缀和与积分图">前缀和与积分图</h2>
<blockquote>
<p>适合没有值修改的<strong>静态</strong>数组使用。</p>
<p>前缀和针对一维的数组，积分图针对二维的数组，二者都是进行打表存储区间和，加速查询。</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>303 Range Sum Query - Immutable 区域和检索 - 数组不可变 (Easy)</p>
<p><strong>静态</strong>数组 + <strong>前缀和</strong>查询：简单的统计前缀和即可，只有初始化操作复杂度为 $O(n)$，每次查询都是 $O(1)$，$n$次操作的均摊时间复杂度为 $O(1)$。</p>
<p>一个值得注意的技巧是 <code>partial_sum</code> 函数，能够一行代码计算出数组的前缀和。</p>
<p>该函数详情见：<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/algorithm/partial_sum">std::partial_sum - cppreference.com</a></p>
</li>
<li class="lvl-2">
<p>304 Range Sum Query 2D - Immutable 二维区域和检索 - 矩阵不可变 (Medium)</p>
<p>静态二维数组 + <strong>积分图</strong>查询：仔细注意积分图的求解逻辑即可。</p>
</li>
<li class="lvl-2">
<p><em>560 Subarray Sum Equals K 和为K的子数组 (Medium)</em></p>
<p>首先明确一个概念，这里的subarray即substring，是<strong>连续的子序列</strong>（区分于 subsequence），全部枚举出来的复杂度为$O(n^2)$。</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>解法一：枚举</p>
<p>即枚举两侧边界，全部枚举的复杂度为$O(n^2)$。枚举的过程中对子数组的和进行加减，这样每次枚举的耗费为$O(1)$，所以总的复杂度为 $O(n^2)$。</p>
</li>
<li class="lvl-4">
<p><strong>解法二：前缀和 + 哈希表</strong>的优化。比较巧的解法，需要背一背。</p>
</li>
</ul>
<p>一些思路和坑：</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>滑动窗口：因为数组中存在负值，所以没办法确定两侧指针谁来移动。如果全部是正值，则可以使用滑动窗口一次扫描完成；</p>
</li>
</ul>
</li>
<li class="lvl-2">
<p>437 Path Sum III 路径总和 III (Medium)</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>解法一：穷举，见<a href="###%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92">二叉树部分</a>。</p>
</li>
<li class="lvl-4">
<p>解法二：前缀和+先序遍历+回溯</p>
<p>二叉树中的前缀和：树中每条自顶向下的路径也是唯一的，实际上也是一个一维的前缀和问题。</p>
</li>
</ul>
</li>
<li class="lvl-2">
<p><strong>467 Unique Substrings in Wraparound String 环绕字符串中唯一的子字符串 (Medium)</strong></p>
<ul class="lvl-2">
<li class="lvl-4">统计以每种字母为结尾的最长连续子串即可，最大值即为其对最终答案的贡献（自动去重，无需担心前后出现相同的字符串重复统计）；</li>
<li class="lvl-4">最终对所有字母的贡献求和即可，即前缀和的思想。</li>
</ul>
</li>
<li class="lvl-2">
<p><em>2281 Sum of Total Strength of Wizards 巫师的总力量和 (Hard)</em></p>
<p>终极前缀和之——前缀和的前缀和。</p>
<p>详见[单调栈部分](##单调栈 Monotone Stack)</p>
</li>
</ul>
<h2 id="差分数组">差分数组</h2>
<blockquote>
<p><strong>差分数组</strong>与<strong>前缀和</strong>其实是一对逆运算。对差分数组求前缀和，可以得到原数组；对前缀和数组求差分，也可以得到原数组。</p>
<p>差分数组主要用于<strong>区间修改（$O(1)$）<strong>与</strong>单点查询（$O(n)$）</strong>。</p>
</blockquote>
<h3 id="定义">定义</h3>
<p>类似前缀和的定义，假设原数组 $num$ ，定义差分数组 $d$ ，则对于 $i \in [2, n]$ ，都有 $d[i] = num[i] - num[i - 1]$ 。</p>
<h3 id="用法">用法</h3>
<ol>
<li class="lvl-3">
<p><strong>单点查询</strong> $O(n)$</p>
<p>$num[i]$即为从 $0$ 到 $i$ 的前缀和。即令 $S_n$ 为 $d[i]$ 的前缀和，则 $num[i] = S_i$ 。</p>
</li>
<li class="lvl-3">
<p><strong>区间查询</strong> $O(1)$<br>
$$<br>
sum_x = \sum_{i = 1}^{x} num[i] = \sum_{i=1}^x S_i = \sum_{i=1}^x \sum_{j=1}^i d[i] = \sum_{i=1}^x (x-i+1) d[i]<br>
$$</p>
</li>
<li class="lvl-3">
<p><strong>区间修改</strong></p>
</li>
</ol>
<h2 id="树状数组-BIT">树状数组 BIT</h2>
<blockquote>
<p>又称二叉索引树（Binary Indexed Tree）、Fenwick树（发明者的命名）。</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>适用场景及性能分析</p>
<p>适用于<strong>点更新</strong>后的<strong>前缀和查询</strong>、<strong>区间和查询</strong>：</p>
<ul class="lvl-3">
<li class="lvl-4">
<p>点更新：树状数组 $O(logn)$，普通数组 $O(1)$；</p>
</li>
<li class="lvl-4">
<p>前缀和/区间和查询：树状数组 $O(logn)$，普通数组 $O(n)$。</p>
</li>
</ul>
<p>并<em>不</em>适用于<strong>点查询</strong> 以及 <strong>区间更新</strong>：</p>
<ul class="lvl-3">
<li class="lvl-4">
<p>点查询：普通数组只要 $O(1)$，树状数组需要 $O(logn)$；</p>
</li>
<li class="lvl-4">
<p>区间更新：普通数组 $O(n)$，树状数组 $O(nlogn)$。</p>
</li>
</ul>
</li>
<li class="lvl-2">
<p>常见应用：求解逆序对数（剑指offer 51）</p>
</li>
</ul>
</blockquote>
<h3 id="引入">引入</h3>
<p>通过引入树状数组维护前缀和，能够使单点修改和区间和计算都达到$O(logn)$，即树高。</p>
<p>树状数组巧妙地利用了下标的二进制位特性，所以这里用到了一个重要的位运算操作，定义为 $lowbit(x)$，即保留最低有效位（最低的一个1）后的值。</p>
<h3 id="定义-2">定义</h3>
<p>首先来看树状数组的特征与含义：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>含义：维护一组树状区间和数组 $bit[i]$ ，其包含的区间和范围为$[i - lowbit[i] + 1,\space i]$，即<strong>以 $i$ 为左边界，长度为 $lowbit[i]$ 的区间</strong>。即 $bit_i = \sum \limits^{i} <em>{j=i-lowbit(i)+1}A</em>{j}$。如图所示。</p>
</li>
<li class="lvl-2">
<p>特征：</p>
<ul class="lvl-2">
<li class="lvl-4">每一层节点的 $lowbit$ 值都是相同的。且 $lowbit$ 从树叶向上到根，越靠近根值越大；</li>
<li class="lvl-4">值得注意的是，树状数组因为借助了二进制位的性质，其下标是从1开始的。</li>
</ul>
</li>
</ul>
<img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202204241054724.png" srcset="/img/loading.gif" lazyload style="zoom: 33%;" />
<ul class="lvl-0">
<li class="lvl-2">
<p>效率：</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>单点修改：如图黄色轨迹所示，向上的下标变3换为 $i+ lowbit[i]$ ；</p>
</li>
<li class="lvl-4">
<p>求区间和：如图灰色轨迹所示，向上的下标变换为 $i - lowbit[i]$ ；</p>
<p>时间复杂度显然均为树的高度；</p>
</li>
</ul>
</li>
</ul>
<p>具体实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*--</span><br><span class="hljs-comment">	a[i] 	: 0 &lt;= i &lt; n</span><br><span class="hljs-comment">	bit[i]	: 0 &lt; i &lt;= n </span><br><span class="hljs-comment">--*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BIT</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; bit;<br>    <span class="hljs-type">int</span> size;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">BIT</span>(<span class="hljs-type">int</span> n) : <span class="hljs-built_in">size</span>(n), <span class="hljs-built_in">tree</span>(n + <span class="hljs-number">1</span>) &#123;&#125;<br>    <br>    <span class="hljs-type">int</span> lowbit（<span class="hljs-type">int</span> x) &#123;							<span class="hljs-comment">// 求lowbit就是位运算中保留最低有效位</span><br>        <span class="hljs-keyword">return</span> x &amp; (-x);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            bit[i] = a[i - <span class="hljs-number">1</span>];		<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> index = i - <span class="hljs-number">1</span> - <span class="hljs-number">1</span>; i &gt;= i - <span class="hljs-built_in">lowbit</span>(i); i--) &#123;	<span class="hljs-comment">// 长度为 lowbit[i] 的区间</span><br>                bit[i] += a[index];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> val)</span> </span>&#123;				<span class="hljs-comment">// 将第index个元素的值修改为x</span><br>        <span class="hljs-type">int</span> diff = val - a[index + <span class="hljs-number">1</span>];<br>        <br>        <span class="hljs-keyword">while</span>(index &lt;= n) &#123;<br>            bit[index] += diff;<br>            index += <span class="hljs-built_in">lowbit</span>(index);<br>        &#125;<br>      <br>        <span class="hljs-comment">// for(int i = index; i &lt;= n; i += lowbit(i)) &#123;</span><br>        <span class="hljs-comment">//     bit[i] += diff;</span><br>        <span class="hljs-comment">// &#125;</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">prefix_sum</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> </span>&#123;							<span class="hljs-comment">// 查询前k项和</span><br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = k; i &gt; <span class="hljs-number">0</span>; i -= lowbit[i]) &#123;<br>            sum += bit[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">range_sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;					<span class="hljs-comment">// 查询[a, b]的区间和（左闭右闭）</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">prefix_sum</span>(b) - <span class="hljs-built_in">prefix_sum</span>(a - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="相关题目">相关题目</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><em>剑指Offer 51. 数组中的逆序对 (Hard)</em></p>
<blockquote>
<p>首先，按照逆序对的定义，来统计数组中的逆序对的方法有两种形式：</p>
<ul class="lvl-3">
<li class="lvl-2">统计每一位的前面有几个更大的元素；</li>
<li class="lvl-2">统计每一位的后面有几个更小的元素；</li>
</ul>
<p>二者本质一样，按照具体解题方法来选择即可。</p>
<p>第一反应的暴力解法使用两种形式均可，两层循环达到$O(n^2)$级别复杂度（上限也就5000），题目中50000规模的输入显然会TLE。</p>
</blockquote>
<p>逆序对数有两种常见的优化解法：</p>
<ul class="lvl-2">
<li class="lvl-4">
<p><em>解法一：桶 + 树状数组 + 数组离散化</em></p>
<ul class="lvl-4">
<li class="lvl-6">
<p>基本思想是【<strong>建桶</strong>】来统计每个元素出现的次数，则该桶的<strong>前缀和</strong>即为小于该元素的元素数量。</p>
</li>
<li class="lvl-6">
<p>考虑到前缀和给出的是更小的元素的数量，我们选择第二种形式统计，即统计每一位的后面有几个更小的元素：</p>
<p>下标就要从大到小进行循环，对每个位置的值对应的桶自增一，并统计当前桶的前缀和（即已经处理过的、后面的更小元素值的数量）。</p>
<p>反复计算前缀和/区间和问题显然可以使用树状数组来进行优化。</p>
</li>
<li class="lvl-6">
<p>同时在空间上，因为元素的值可能非常大，因此对最大值进行建桶会导致空间利用率低，且内存可能并不足够。对于这种<strong>稀疏且只关心相对大小</strong>的桶，可以使用<strong>离散化</strong>来增加空间利用率，也避免出现 MLE。</p>
<p>**离散化就是将数组内元素排序，按照大小分配成从 1 到 $n$的值。**具体实现如下：</p>
<ol>
<li class="lvl-9">
<p>复制一个一模一样的临时数组，并对其进行排序 — 耗费 $O(nlogn)$</p>
</li>
<li class="lvl-9">
<p>从前往后对原数组每个位置进行访问，利用二分查找在临时数组中查找其排序后的位置，并利用该位置修改其值。</p>
</li>
</ol>
</li>
</ul>
</li>
<li class="lvl-4">
<p>解法二：归并排序</p>
<p>归并排序每一次 <b>合并</b> 的时候，观察左右两个子序列 $[l_1, \space r_1], [l_2, \space r_2]$ （此时均为有序序列）。</p>
<p>假设当前状态如上述，指向两个子序列的指针为 $lPtr$ 与 $rPtr$ ：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">    l_1      r_1       l_2      r_2<br>     |<span class="hljs-string">        </span>|<span class="hljs-string">         </span>|<span class="hljs-string">        </span>|<br>L = [2, 3, 6, 7]   R = [0, 1, 4, 5]       Merge = []<br>     |<span class="hljs-string">                  </span>|<br>    lPtr               rPtr<br></code></pre></td></tr></table></figure>
<ul class="lvl-4">
<li class="lvl-6">
<p>$lPtr$ 指向的元素小于 $rPtr$ 指向的元素，即 $lPtr$ 应右移</p>
<p>此时，$rPtr$ 左侧的元素均小于 $lPtr$ 所指向的元素，且在原数组中位于其后。统计该部分长度为 $rPtr - l_2 + 1$ ，即代表 $lPtr$ 元素位所贡献的逆序对数：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">    l_1      r_1       l_2      r_2<br>     |<span class="hljs-string">        </span>|<span class="hljs-string">         </span>|<span class="hljs-string">        </span>|<br>L = [2, 3, 6, 7]   R = [0, 1, 4, 5]      Merge = [0, 1]<br>     |<span class="hljs-string">                        </span>|<br>    lPtr                     rPtr<br></code></pre></td></tr></table></figure>
</li>
<li class="lvl-6">
<p>$rPtr$ 指向的元素小于 $lPtr$ 指向的元素，即 $rPtr$ 应右移</p>
<p>和上述同理，但关注 $L$ 中更大的元素部分。统计 $rPtr$ 元素位所贡献的逆序对数为 $r_1 - lPtr + 1$。</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">    l_1      r_1       l_2      r_2<br>     |<span class="hljs-string">        </span>|<span class="hljs-string">         </span>|<span class="hljs-string">        </span>|<br>L = [2, 3, 6, 7]   R = [0, 1, 4, 5]      Merge = [0, 1, 2, 3]<br>           |<span class="hljs-string">                  </span>|<br>          lPtr               rPtr<br></code></pre></td></tr></table></figure>
</li>
</ul>
<p>两种方式取任意都可，第二种的代码相对简洁。</p>
<img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202204261027731.png" srcset="/img/loading.gif" lazyload style="zoom: 50%;" />
</li>
</ul>
</li>
<li class="lvl-2">
<p>315 计算右侧小于当前元素的个数 (Hard)</p>
<p>跟剑指offer51一模一样的题目，换个形式而已。</p>
</li>
</ul>
<h2 id="线段树-Segment-Tree">线段树 Segment Tree</h2>
<blockquote>
<p>线段树基于分治思想，将区间不断进行二分，可以维护区间的多种信息，如<strong>区间和</strong>、<strong>区间最值</strong>等等。</p>
</blockquote>
<h3 id="定义-3">定义</h3>
<p>线段树（Segment Tree）是一个基于分治思想的二叉树：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>每个非叶节点对应一个区间，并存储对应的该区间信息；</p>
</li>
<li class="lvl-2">
<p>每个左右孩子节点二分父节点的区间；</p>
</li>
<li class="lvl-2">
<p>对于节点区间$[l,r]$而言，所有叶节点代表所有的单个元素，及$l=r$的情况。</p>
</li>
</ul>
<p>树的具体结构与定义如图所示（以维护区间最值为例）：</p>
<p><img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205011625893.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h3 id="存储方式">存储方式</h3>
<p>据上可得，线段树除了最后一层，其他上层均为满二叉树，选用顺序存储方式，用数组来存放这颗树，下标从1开始。</p>
<p>值得注意的是，该数组开辟的大小与输入规模 $n$ 的关系应该是怎样的：</p>
<p><img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205011711572.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>根据图上可得：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>规定数组总大小为 $N$，则 $N=n_0 + n_2 + n_{blank}$，其中：</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>$n_0 = n$，即输入的 $n$ 个元素均为叶节点；</p>
</li>
<li class="lvl-4">
<p>$n_2 = n_0 - 1 = n - 1$，这是根据二叉树的定义而得：</p>
<p>$N=n_0 + n_1 + n_2, \space N - 1 = 2 \times n_2 + n_1$，即 $n_0 + \cancel{n_1} + n_2 = 2 \times n_2 + \cancel{n_1} + 1$</p>
</li>
<li class="lvl-4">
<p>$n_{blank} = 2n-4$，如图所示。</p>
</li>
</ul>
</li>
<li class="lvl-2">
<p>综上可得，$N = n + (n - 1) + (2n-4) = 4n-5$，即<strong>需要给线段树数组开辟【 $4n$ 】的空间来防止溢出</strong>。</p>
</li>
</ul>
<h3 id="懒标记-区间修改">懒标记 - 区间修改</h3>
<blockquote>
<p>普通的线段树操作适合<strong>单点修改</strong>后的区间信息维护与查询。</p>
<p>而对于 <em>区间修改</em> ，需要引入**懒标记（lazy tag）**来进一步降低时间复杂度。</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>处理流程</p>
<p>懒标记的处理流程如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span> <span class="hljs-keyword">if</span>(目标区间完全覆盖当前区间)			<span class="hljs-comment">// cover!</span><br>       更新区间信息;<br>       对当前节点打上懒标记;<br><span class="hljs-number">2.</span> <span class="hljs-keyword">if</span>(未完全覆盖 &amp;&amp; 存在懒标记)<br>       向下传递懒标记;<br><span class="hljs-number">3.</span> <span class="hljs-keyword">if</span>(左儿子有交集)<br>       向左下进入递归;<br>   <span class="hljs-keyword">if</span>(右儿子有交集)<br>       向右下进入递归；<br></code></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p>作用：对区间整体进行修改时的效率提升</p>
<p>不加懒标记的单点更新时，需要向下递归搜索至叶节点，并在向上返回的过程中不断完成修改。根据上面的流程可以发现，增加懒标记后，每次向下递归无需搜索至叶节点，而是对被覆盖的区间加一个懒标记后，直接对区间进行修改并增加懒标记。而该节点以下的子节点区间都先不做修改，而是等到<strong>下一次需要访问其子区间时</strong>按需<strong>向下传递懒标记</strong>再进行更改，从而实现<strong>效率的提升</strong>。</p>
<p>同时，由于叶节点无法继续向下传递，无需对其设置懒标记。</p>
</li>
<li class="lvl-2">
<p>内容</p>
<p>显然，根据懒标记的作用，其存放的内容是当前节点的儿子们更新时所需要做的操作。</p>
</li>
</ul>
<p>向下递归的过程如图所示（不包含向上返回的过程）：</p>
<p><img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205021237853.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h3 id="动态开点-在线操作">动态开点 - 在线操作</h3>
<blockquote>
<p>默认情况下，用随机存取的数组形式来存放二叉树。数组的大小为了防止越界需要提前设置为 $4n$ 。</p>
<p>适用场景：</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>搜索范围非常大（叶节点数量十分庞大）而实际搜索的次数并不多，只占整个值域的一小部分；</p>
<p>这种情况下的搜素范围过大很可能MLE。</p>
<p>解决空间问题可以对数据进行 <b>离散化</b>，即将分散的数据映射到连续的小空间（因为实际搜索次数并不多）。但是离散化要求必须是离线处理的题目。如果题目是强制在线则无法使用。</p>
</li>
<li class="lvl-2">
<p><b>在线</b> 处理的题目。这里的在线是指的是会想线段树中不断插入新节点。</p>
<p>从空间上来看，提前开好 总不如 按需开点。在搜索远少于值域的情况下，空间的节省格外明显。</p>
<p>例如，LeetCode 729等（日程安排表系列）</p>
</li>
</ul>
</blockquote>
<div class="danger">
<p><b>不需要动态开点的情况</b></p>
<p>值得注意的是，如果题目只存在查询与更新，而 <b>不存在插入新节点的情况</b>，则完全没有必要使用动态开点。</p>
<p>比如 LeetCode 307。</p>
</div>
<p>灵活运用动态开点线段树是非常重要的。很多题目要求<strong>强制在线</strong>，这意味着无法对值域 $n$ 进行离散化。通常这种情况下实际的搜索次数 $m$ 也并不会很大，而每次搜索的路径即为树高，即 $O(logn)$，所以实际所需区间约为 $O(mlogn)$。</p>
<p>综上显然，动态开点的线段树从最完整的 $O(4 * n)$ 降至实际需要的$O(mlogn)$的提升是非常大的。考虑到连续插入时常数的上界定为4，我们这里也可以为了安全起见增加一个常数，取4-6之间均可。</p>
<h3 id="效率">效率</h3>
<p>任意的查询与更新的单次操作的复杂度都是 $O(logn)$。</p>
<p>增加了懒标记的区间更新的渐进复杂度也为 $O(logn)$。</p>
<h3 id="代码实现">代码实现</h3>
<h5 id="无懒标记-携带区间范围信息">无懒标记 + 携带区间范围信息</h5>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; num;			<span class="hljs-comment">// 原数组，这里假设从下标为1处开始</span><br><span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>(); 					<span class="hljs-comment">// n为输入规模，即元素总个数</span><br><br><span class="hljs-comment">// 结构定义</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    <span class="hljs-type">int</span> l, r, mx;		<span class="hljs-comment">// l，r为区间做右端点，也有不携带区间信息的写法</span><br>    					<span class="hljs-comment">// 区间信息此处以区间最大值为例</span><br>&#125; tree[n * <span class="hljs-number">4</span>];<br><br><span class="hljs-comment">/*--</span><br><span class="hljs-comment">创建线段树：</span><br><span class="hljs-comment">	按照树的定义，递归形式创建</span><br><span class="hljs-comment">--*/</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> root, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    tree[root].l = l;<br>    tree[root].r = r;<br>    <span class="hljs-comment">// recursive base</span><br>    <span class="hljs-keyword">if</span>(l == r) &#123;<br>        tree[root].mx = num[l];<br>    	<span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 向左右儿子进入递归</span><br>    <span class="hljs-type">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>；<br>    <span class="hljs-type">int</span> left = root &lt;&lt; <span class="hljs-number">1</span>, right = root &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">build</span>(left, l, mid);<br>    <span class="hljs-built_in">build</span>(right, mid + <span class="hljs-number">1</span>, r);<br>    <br>    <span class="hljs-comment">// 更新区间信息，此处以更新区间最大值为例</span><br>    tree[root].mx = <span class="hljs-built_in">max</span>(tree[left].mx, tree[right].mx);<br>    <span class="hljs-comment">// tree[root] = push_up(tree[left], tree[right]);</span><br>&#125;<br><br><br><span class="hljs-comment">/*--</span><br><span class="hljs-comment">点更新:</span><br><span class="hljs-comment">	递归寻找目标节点，找到后更改，并向上修改	</span><br><span class="hljs-comment">--*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> root, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>    <span class="hljs-comment">// recursive base</span><br>    <span class="hljs-keyword">if</span>(root.l == root.r &amp;&amp; root.l == index) &#123;<br>   		<span class="hljs-comment">// 更新区间信息，此处以更新区间最大值为例</span><br>        tree[l].mx = val;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 向左右儿子进入递归</span><br>    <span class="hljs-type">int</span> mid = root.l + (root.r - root.l) / <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> left = root &lt;&lt; <span class="hljs-number">1</span>, right = root &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(index &lt;= mid) &#123;<br>        <span class="hljs-built_in">update</span>(left, index, val);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">update</span>(right, index, val);<br>    &#125;<br>    tree[root].mx = <span class="hljs-built_in">max</span>(tree[left].mx, tree[right].mx);<br>&#125;<br><br><span class="hljs-comment">/*--</span><br><span class="hljs-comment">区间信息查询:</span><br><span class="hljs-comment">	1. 区间覆盖式查询</span><br><span class="hljs-comment">	2. 区间相等式查询</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">--*/</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query_cover</span><span class="hljs-params">(<span class="hljs-type">int</span> root, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-comment">// recursive base</span><br>	<span class="hljs-keyword">if</span>(l &lt;= root.l &amp;&amp; root.r &lt;= r) &#123;	<span class="hljs-comment">// 查询区间完全覆盖了当前区间</span><br>        <span class="hljs-keyword">return</span> tree[root].mx;<br>    &#125; <br>    <span class="hljs-type">int</span> mid = root.l + (root.l - root.r) / <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> lmax, rmax;<br>    <span class="hljs-keyword">if</span>(l &lt;= mid) &#123;<br>        lmax = <span class="hljs-built_in">query</span>(root &lt;&lt; <span class="hljs-number">1</span>, l, r);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(r &gt; mid) &#123;<br>        rmax = <span class="hljs-built_in">query</span>(root &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, l, r);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(lmax, rmax);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query_equal</span><span class="hljs-params">(<span class="hljs-type">int</span> root, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-comment">// recursive </span><br>    <span class="hljs-keyword">if</span>(root.l == l &amp;&amp; root.r == r) &#123;<br>        <span class="hljs-keyword">return</span> tree[root].mx;<br>    &#125;<br>    <span class="hljs-type">int</span> mid = root.l + (root.r - root.l) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(r &lt;= mid) &#123;<br>    	<span class="hljs-keyword">return</span> <span class="hljs-built_in">query_equal</span>(root &lt;&lt; <span class="hljs-number">1</span>, l, r);<br>    &#125; <br>    <span class="hljs-keyword">if</span>(l &gt; mid) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">query_equal</span>(root &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, l, r);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">query_equal</span>(root &lt;&lt; <span class="hljs-number">1</span>, l, mid), <span class="hljs-built_in">query_equal</span>(root &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r);<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="带懒标记-携带区间范围信息">带懒标记 + 携带区间范围信息</h5>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 此处指定维护的区间信息为区间和</span><br>vector&lt;<span class="hljs-type">int</span>&gt; nums;<br><span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">struct</span>&#123;<br>    <span class="hljs-type">int</span> l, r, sum, lz;<br>&#125;tree[<span class="hljs-number">4</span> * n];<br><br><span class="hljs-comment">// 维护的区间信息 并 添加懒标记</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">lazy</span><span class="hljs-params">(<span class="hljs-type">int</span> root, <span class="hljs-type">int</span> delta)</span> </span>&#123;<br>    tree[root].sum += delta * (tree[root].r - tree[root].l + <span class="hljs-number">1</span>);  <span class="hljs-comment">// 对其下区间所有元素都增加 delta, 所以该点增加 其区间长度 * delta</span><br>    tree[root].lz += delta;			<span class="hljs-comment">// 设置懒标记，代表向下传递时，每个叶节点都要加delta</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> root)</span> </span>&#123;		<span class="hljs-comment">// 访问到子节点，需要向下传递懒标记</span><br>    <span class="hljs-built_in">lazy</span>(root &lt;&lt; <span class="hljs-number">1</span>, tree[root].lz);<br>    <span class="hljs-built_in">lazy</span>(root &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, tree[root].lz);<br>    tree[root].lz = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">range_update</span><span class="hljs-params">(<span class="hljs-type">int</span> root, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> delta)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(l &lt;= tree[root].l &amp;&amp; tree[root].r &lt;= r) &#123;<br>        <span class="hljs-built_in">lazy</span>(root, delta);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 重要：当前区间大于查询区间，意味着要向下访问子区间，此时如果有懒标记，则要向下对子区间进行更新！</span><br>    <span class="hljs-keyword">if</span>(tree[root].lz) &#123; 		<span class="hljs-comment">// tree[root].lz != 0</span><br>        <span class="hljs-built_in">pushdown</span>(root);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(l &lt;= mid) &#123;<br>        <span class="hljs-built_in">range_update</span>(root &lt;&lt; <span class="hljs-number">1</span>, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> delta);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(r &gt; mid) &#123;<br>        <span class="hljs-built_in">range_update</span>(root &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> delta);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> root, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(l &lt;= tree[root].l &amp;&amp; tree[root].r &lt;= r) &#123;<br>        <span class="hljs-keyword">return</span> tree[root].sum;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(tree[root].lz) &#123;<br>        <span class="hljs-built_in">pushdown</span>(root);<br>    &#125;<br>    <span class="hljs-type">int</span> lsum，rsum;<br>    <span class="hljs-keyword">if</span>(l &lt;= mid) &#123;<br>        lsum = <span class="hljs-built_in">query</span>(root &lt;&lt; <span class="hljs-number">1</span>, l, r);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(mid &lt; r) &#123;<br>        rsum = <span class="hljs-built_in">query</span>(root &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, l, r);<br>    &#125;<br>    <span class="hljs-keyword">return</span> lsum + rsum;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="动态开点-无懒标记">动态开点 + 无懒标记</h5>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 以记录区间求和信息为例</span><br><span class="hljs-type">int</span> n, m, cnt = <span class="hljs-number">0</span>; 			<span class="hljs-comment">// n为值域取对数，m为查询次数的上限, cnt为当前线段树节点个数</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    <span class="hljs-type">int</span> lc, rc;		<span class="hljs-comment">// 要与区间信息区分开，这里的lc和rc是指其动态建立的左右子儿子的下标，区间信息仍然在函数参数中进行传递</span><br>&#125;tree[n * m];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; root, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> val)</span> </span>&#123;		<span class="hljs-comment">// 为了实现开点，第一个参数必须引用</span><br>	<span class="hljs-keyword">if</span>(root == <span class="hljs-number">0</span>) &#123;<br>        root = ++cnt;			<span class="hljs-comment">// 开点</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>(l == r) &#123;<br>        tree[root].val = val;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(index &lt;= mid) &#123;<br>        <span class="hljs-built_in">update</span>(tree[root].lc, l, mid, index, val);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">update</span>(tree[root].rc, mid + <span class="hljs-number">1</span>, r, index, val);<br>    &#125;<br>    tree[root].val = tree[tree[root].lc].val + tree[tree[root].rc].val;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> root, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-number">0</span>) &#123;		<span class="hljs-comment">// 此处还未开点，说明没有数据，直接返回0</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;	<br>    &#125;<br>    <span class="hljs-keyword">if</span>(left &lt;= l &amp;&amp; r &lt;= right) &#123;<br>        <span class="hljs-keyword">return</span> tree[root].val;<br>    &#125;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(left &lt;= mid) &#123;<br>        sum += <span class="hljs-built_in">query</span>(tree[root].lc, l, mid, left, right);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(mid &lt; right) &#123;<br>        sum += <span class="hljs-built_in">query</span>(tree[root].rc, mid + <span class="hljs-number">1</span>, r, left, right);<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="动态开点-懒标记">动态开点 + 懒标记</h5>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br></code></pre></td></tr></table></figure>
<h3 id="扩展">扩展</h3>
<h5 id="主席树-可持久化线段树">主席树 - 可持久化线段树</h5>
<h2 id="倍增、ST表、最长公共祖先-LCA、分块">倍增、ST表、最长公共祖先 LCA、分块</h2>
<p>出现次数少，按需补全。</p>
<p>分块：几乎可以解决所有<strong>区间更新</strong>和<strong>区间查询</strong>问题，但<strong>效率比线段树差一些</strong>。</p>
<h2 id="相关题目-2">相关题目</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>303 Range Sum Query - Immutable 区域和检索 - 数组不可变 (Easy)</p>
</li>
<li class="lvl-2">
<p>304 Range Sum Query 2D - Immutable 二维区域和检索 - 矩阵不可变(Medium)</p>
</li>
<li class="lvl-2">
<p><em>307 Range Sum Query - Mutable 区域和检索 - 数组可修改 (Medium)</em></p>
<p>典型的使用场景：<strong>单点修改</strong> + <strong>区间和查询</strong></p>
<ul class="lvl-2">
<li class="lvl-4">
<p>解法一：线段树</p>
<p>不存在区间修改，所以无需懒标记。</p>
</li>
<li class="lvl-4">
<p>解法二：树状数组</p>
</li>
<li class="lvl-4">
<p>解法三：分块</p>
<p>未完成，按需补。</p>
</li>
</ul>
</li>
<li class="lvl-2">
<p>308 Range Sum Query 2D - Mutable 二维区域和检索 - 可变 (Hard)</p>
<p>未做，超纲，按需补</p>
</li>
<li class="lvl-2">
<p><em>2286 Booking Concert Tickets in Groups 以组为单位订音乐会的门票 (Hard)</em></p>
<p>难点：两种操作分别需要记录两种信息的<strong>两颗线段树</strong>来加速对可否分配的判断。同时还要动态对剩余座位进行记录。</p>
<ul class="lvl-2">
<li class="lvl-4">
<p><code>gather</code>：需要找到编号最小的能够容纳的行。</p>
<p>引入<strong>记录最大值的线段树</strong>，其内容为区间内每一行中最多空余的座位数。</p>
<p>对该线段树进行二分，加速查找。</p>
</li>
<li class="lvl-4">
<p><code>scatter</code>： 判断是否能够在<code>maxRow</code>前有足够的空间容纳；</p>
<p>显然需要计算区间和，引入<strong>记录区间和的线段树</strong>，其内容为<strong>剩余的座位总数</strong>。</p>
</li>
</ul>
<p>共同的操作：</p>
<ul class="lvl-2">
<li class="lvl-4">
<p><code>allocate</code>：安排好座位后，更新两颗线段树的值。</p>
</li>
</ul>
</li>
<li class="lvl-2">
<p><em>699 Falling Squares 掉落的方块 (Hard)</em></p>
<ul class="lvl-2">
<li class="lvl-4">
<p>解法一：暴力枚举</p>
<p>每落下一块，都统计前面所有和当前下落的块有重合的块高度，计算出当前落下块的最终高度。最后在从前往后取前 $i$ 块的最大值即可获得结果。</p>
<p>值得注意的点：</p>
<ul class="lvl-4">
<li class="lvl-6">
<p>如何判断两个块是否重合？</p>
</li>
<li class="lvl-6">
<p>题目规模显然在 $O(n^2)$ 的暴力解法下能够通过，就先使用暴力解法计算。</p>
</li>
</ul>
</li>
<li class="lvl-4">
<p>解法二：使用map有序集合来加快计算高度</p>
<p>显然，暴力枚举的时间消耗主要在落下时，要对前面的所有块进行访问。</p>
<p>这里引入有序集合map来记录当前已经放置好的块的包络（外边界），这样在有序集合中寻找当前下落的块所在的范围可以使用 <code>upper_bound</code> 从而实现 $O(logn)$ 的时间内来确定当前落下块最终的高度。</p>
<p>要注意如何对有序集合进行更新，注意边界和细节处理。</p>
<p>该解法属于巧解，没有具体写过，了解加快的思路即可。</p>
</li>
<li class="lvl-4">
<p>解法三：线段树 + 动态开点</p>
</li>
</ul>
</li>
<li class="lvl-2">
<p>715 Range Module Range 模块 (Hard)</p>
<p>线段树动态开点 + 懒标记</p>
<p>其中线段树维护区间和，但由于每个元素的值只能为1或者0，所以实际维护值的含义为<em>当前区间内跟踪的元素个数</em>；</p>
<p>懒标记的含义也比较特殊：</p>
<ul class="lvl-2">
<li class="lvl-4">
<p><code>1</code> 代表跟踪区间；</p>
</li>
<li class="lvl-4">
<p><code>-1</code> 代表取消区间跟踪。</p>
</li>
</ul>
</li>
<li class="lvl-2">
<p>729 My Calendar I 我的日程安排表 I (Medium)</p>
</li>
<li class="lvl-2">
<p>731 My Calendar II 我的日程安排表 II (Medium)</p>
</li>
<li class="lvl-2">
<p>731 My Calendar III 我的日程安排表 III (Medium)</p>
<p>三道题都一个味，常规线段树直接秒，存储不同的值即可。</p>
<p>这种全部修改都是区间整体修改的显然也可以用<strong>差分数组</strong>，但是确定区间内是否有重合的时候要进行朴素遍历，所以整体时间复杂度会达到 $O(n^2)$，效率与暴力相比并无本质的提升。</p>
</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" class="category-chain-item">数据结构与算法</a>
  
  

      </span>
    
  
    
      <span class="category-chain">
        
  <a href="/categories/LeetCode/" class="category-chain-item">LeetCode</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%89%8D%E7%BC%80%E5%92%8C/">#前缀和</a>
      
        <a href="/tags/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/">#差分数组</a>
      
        <a href="/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84-BIT/">#树状数组(BIT)</a>
      
        <a href="/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91-Segment-Tree/">#线段树(Segment Tree)</a>
      
        <a href="/tags/%E5%88%86%E5%9D%97/">#分块</a>
      
        <a href="/tags/RMQ%E9%97%AE%E9%A2%98-Range-Maximum-Minimum-Query/">#RMQ问题(Range Maximum/Minimum Query)</a>
      
    </div>
  
</div>


              

              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/06/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-Dynamic-Programming/" title="动态规划（Dynamic Programming）">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">动态规划（Dynamic Programming）</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/03/08/C++_OOP/" title="C++：OOP">
                        <span class="hidden-mobile">C++：OOP</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>2022</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>TAO1st</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.1/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
