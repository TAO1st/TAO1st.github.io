<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>链表-Linked-List</title>
    <link href="/2023/03/09/%E9%93%BE%E8%A1%A8-Linked-List/"/>
    <url>/2023/03/09/%E9%93%BE%E8%A1%A8-Linked-List/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数组 Array</title>
    <link href="/2023/03/09/%E6%95%B0%E7%BB%84-Array/"/>
    <url>/2023/03/09/%E6%95%B0%E7%BB%84-Array/</url>
    
    <content type="html"><![CDATA[<h1>数组 Array</h1><h2 id="一维">一维</h2><ul class="lvl-0"><li class="lvl-2"><p>448 Find All Numbers Disappeared in an Array 找到所有数组中消失的数字 (Easy)</p><p>题目要求空间上原地完成。结合数组大小为 $n$ 的信息，使用<b>原地哈希</b>。</p></li><li class="lvl-2"><p>769 Max Chunks To Make Sorted 最多能完成排序的块 (Medium)</p><p>见[单调栈](###单调栈 Monotone Stack)部分</p></li></ul><h2 id="矩阵-2">矩阵</h2><blockquote><p>即二维数组。</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p><strong>48 Rotate Image 旋转图像 (Medium)</strong></p><p>纯矩阵坐标转换数学题。</p><p>解法一：</p><ol><li class="lvl-5"><p>坐标转换公式：规律为第一行 变 倒数第一列，第二行 变 倒数第二列，依次类推。即从原坐标$(x,y)$到新坐标$(x’,y’)$的变换公式为：</p><p>$$<br>x’ = y \ y’ = n - 1 -x<br>$$<br>每次进行四次翻转，根据上述坐标翻转公式计算新的位置坐标：</p><img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202204061409369.png" style="zoom:50%;" />$$\left\{ \begin{array}{ll}temp&= &matrix[y][n - 1 - x] \\matrix[y][n-1-x] &= &matrix[x][y] \\matrix[x][y] &= &matrix[n - 1 - y][x] \\matrix[n - 1 - y][x] &= &matrix[n - 1 - x][n - 1 -y]\\matrix[n - 1-x][n - 1 -y] &= &matrix[y][n - 1 - x]\end{array}\right.$$四个值为一组组成一次循环，用一个中间变量来防止覆盖即可，从环路的哪一处开始结果都是一样的。</li><li class="lvl-5"><p>确定翻转的范围，分为 $n$ 为奇数和 $n$ 为偶数两种情况。</p><img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202204061102316.png" style="zoom: 25%;" /><img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202204061102867.png" style="zoom:25%;" /></li></ol><p>解法二：先水平翻转，再按照对角线翻转，即可得结果。</p></li><li class="lvl-2"><p>240 Search in a Matrix II 搜索二维矩阵 II (Medium)</p><ul class="lvl-2"><li class="lvl-4"><p>解法一：逐行搜索，对列进行二分。</p><p>二分可以直接使用库函数<code>lower_bound(v.begin(), v.end(), target)</code>，也可以手写二分。</p><p>复杂度从$O(mn)$降至$O(mlogn)$。</p></li><li class="lvl-4"><p>解法二：利用矩阵的特性，从<strong>右上</strong>开始搜索。即当前元素的右侧以及上侧的元素均为扫描过的元素。</p><ul class="lvl-4"><li class="lvl-6"><p>如果当前元素比目标元素小，则当前行可以排除，因为当前行前面（左侧）的元素都只会更小；</p></li><li class="lvl-6"><p>如果当前元素比目标元素大，则当前列可以排除，因为当前列下面（下侧）的元素都只会更大；</p></li></ul><p>根据该大小关系特性，一次可以消去一行的数据，复杂度进一步降至线性 $O(m+n)$。</p></li></ul></li><li class="lvl-2"><p>566 Reshape the Matrix 重塑矩阵 (Easy)</p><p>普通的二维数组模拟题，一个可以使用的小技巧是 $flatten$ 操作，即将二维数组的坐标映射到一个一维数组上。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Executable and Linkable Format - ELF</title>
    <link href="/2023/03/04/ELF/"/>
    <url>/2023/03/04/ELF/</url>
    
    <content type="html"><![CDATA[<h1>ELF文件格式</h1><p><a href="https://blog.csdn.net/shanandqiu/article/details/115206426">ELF 格式详解_elf格式_shanandqiu的博客-CSDN博客</a></p><p><a href="https://www.cnblogs.com/gongxianjin/p/16906719.html">ELF文件格式简介 — 见过最细致的ELF讲解 - 易先讯 - 博客园 (cnblogs.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Makefile</title>
    <link href="/2023/02/25/Makefile/"/>
    <url>/2023/02/25/Makefile/</url>
    
    <content type="html"><![CDATA[<div class="tips"><p><a href="https://makefiletutorial.com/#getting-started">Makefile Tutorial By Example</a></p><p><a href="https://seisman.github.io/how-to-write-makefile/index.html">跟我一起写Makefile — 跟我一起写Makefile 1.0 文档 (seisman.github.io)</a></p></div><h2 id="Makefile-是什么？">Makefile 是什么？</h2><ul class="lvl-0"><li class="lvl-2"><p>自动化编译：一个 <code>make</code> 命令就能使整个工程完全自动编译。</p></li><li class="lvl-2"><p>适合大型项目</p></li></ul><h2 id="Makefile-的书写规则">Makefile 的书写规则</h2><p>规则包含两个部分：一个是 <b>依赖关系（prerequisites）</b>，一个是 <b>生成目标的方法（在 command 中编写）</b>。</p><h3 id="规则的语法">规则的语法</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">target ... : prerequisites ...<br>    command<br>    ...<br>    ...<br></code></pre></td></tr></table></figure><ol><li class="lvl-3"><p><b>target</b></p><p>顾名思义，目标文件，即编译的目标。</p><ul class="lvl-2"><li class="lvl-5"><p>内容即为空格分开的文件名，文件名中可以使用通配符。</p></li><li class="lvl-5"><p>使用伪目标的时候，target 代表一个标签（label）。</p></li></ul></li><li class="lvl-3"><p><b>prerequisites</b></p><p>先决条件 / 前提 / 依赖：生成目标文件所需的内容。</p></li><li class="lvl-3"><p><b>command</b></p><p>该 target 要执行的命令。其内容可以是任意的 shell 命令。</p><ul class="lvl-2"><li class="lvl-5"><p>如果单起一行书写：必须以 tab 作为行开头，不能用空格代替；</p><p>如果在同一行书写：前面以分号作为分割。</p></li><li class="lvl-5"><p>如果命令太长，想要分多行书写，可以使用反斜杠 <code>\</code> 作为换行符。</p></li></ul></li></ol><p>根据上述规则，总结一下 makefile 的基本含义：</p><p><strong>目标 中的一个或多个目标文件 依赖于 先决条件 中的若干文件，生成目标的规则定义在 命令部分。</strong></p><p>即，<strong>先决条件中如果有一个及其以上的文件有更新（更晚的修改日期）、或者 目标本身还不存在 的话，命令部分 所定义的命令就会被执行。</strong></p><h3 id="规则的顺序">规则的顺序</h3><p>Makefile 中应该有 <b>一个最终目标</b>。无论依赖关系是怎样错综复杂，一定要让<code>make</code>命令明确哪一个是最终目标。而这个最终目标的选取由规则的顺序而定。</p><p>一般来说，尽管定义在 Makefile 中的目标会有很多，但是 <b>第一条规则中的目标将被确立为最终的目标</b>。</p><h3 id="在规则中使用通配符">在规则中使用通配符</h3><p>在 Makefile 中随处可以使用通配符来匹配一系列文件。</p><p>比较特殊的是，在变量中使用通配符。要记住，makefile中的变量的本质就是一个宏定义/别名：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 下面的命令中，通配符 * 并不会展开，但是该变量的实际使用处可能会最终将其展开</span><br>objects = *.o<br><br><span class="hljs-comment"># 如果想要在变量中就直接展开通配符</span><br>objects := <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> *.o)</span><br><br><span class="hljs-comment"># 注意两个关键字：wildcard, patsubst</span><br>objects := <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %.c,%.o,$(<span class="hljs-built_in">wildcard</span> *.c)</span>)<br></code></pre></td></tr></table></figure><h3 id="文件搜寻-VPATH-vpath">文件搜寻 VPATH &amp; vpath</h3><p>大型工程可能会有大量的来自不同文件夹中的源文件，如果一一将其具体路径写出来会比较麻烦。我们可以设置一个路径告诉 <code>make</code>， 让命令去该目录下自动寻找。</p><p>所以，搜索依赖文件的目录按照优先级从高到低如下：</p><ol><li class="lvl-3"><p>当前目录。即按照显式声明的相对路径来定位；</p></li><li class="lvl-3"><p>显式声明的绝对路径；</p></li><li class="lvl-3"><p>如下设置的两种特殊路径。</p></li></ol><p>共有两种设定特殊路径的方式：</p><ol><li class="lvl-3"><p>VPATH 全大写</p><p>VPATH为一个特殊变量。其值指定多个目录时通过冒号 <code>:</code> 分隔。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">VPATH = path1:/path2<br><span class="hljs-comment"># 指定了 path1 与 /path2 两个路径</span><br></code></pre></td></tr></table></figure></li><li class="lvl-3"><p>vpath 全小写</p><p>vpath为 <code>make</code> 命令的一个关键字而非变量，使用更加灵活，可以指定不同的文件在不同的搜索目录中。</p><p>使用方法有如下三种：</p><ul class="lvl-2"><li class="lvl-5"><p><code>vpath &lt;pattern&gt; &lt;directories&gt;</code></p><p>为 符合模式&lt;pattern&gt;的文件 指定 搜索目录&lt;directories&gt;。</p><p>其中，文件名要包含 <code>%</code> 字符，匹配0个或若干个字符。</p></li><li class="lvl-5"><p><code>vpath &lt;pattern&gt;</code></p><p>清除符合模式&lt;pattern&gt;的文件的搜索目录。</p></li><li class="lvl-5"><p><code>vpath</code></p><p>清除所有已被设置好了的文件搜索目录。</p></li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 在 &quot;../headers&quot; 目录下 搜索所有 .h 结尾的文件（如果当前目录下没有找到）</span><br><span class="hljs-keyword">vpath</span> %.h ../headers<br><br><span class="hljs-comment"># 多个语句重复的相同 pattern，从前到后挨个搜索</span><br><span class="hljs-keyword">vpath</span> %.c foo<br><span class="hljs-keyword">vpath</span> % blish     <span class="hljs-comment"># 所有文件都在 blish 下搜素</span><br><span class="hljs-keyword">vpath</span> %.c bar<br><span class="hljs-comment"># .c 结尾的文件，先在 &quot;foo&quot; ，然后 &quot;blish&quot; 最后在 &quot;bar&quot; 中搜索。</span><br><br><span class="hljs-keyword">vpath</span> %.c foo:bar<br><span class="hljs-keyword">vpath</span> % blish<br><span class="hljs-comment"># 先 &quot;foo&quot; 再 &quot;bar&quot; 最后 &quot;blish&quot; </span><br></code></pre></td></tr></table></figure></li></ol><h3 id="多目标">多目标</h3><h2 id="make-命令的工作流程">make 命令的工作流程</h2><blockquote><p>总的来讲，<code>make</code> 命令会在当前目录下寻找名为 “Makefile” 或 “makefile” 的文件，并解析层层依赖，生成文件中的第一个 target 。</p><p>如果在解析依赖的过程中发生错误，比如某个被依赖的文件没有找到，<code>make</code>会直接退出；如果 command 部分的命令有错误，或者编译过程失败，则与 <code>make</code> 无关。即，<code>make</code> 命令 <b>只关心文件的依赖关系</b> 而 <b>不关心命令内容</b>。</p></blockquote><p>GNU make 的具体工作步骤如下：</p><ol><li class="lvl-3"><p>读入所有的Makefile。</p><p>默认情况下，GNU make 命令会在 当前目录下 按顺序寻找 文件名为 “GNUmakefile”、“makefile”、“Makefile” 的文件。通常，大多数 make 都支持 “makefile” 与 “Makefile” 两种默认文件名。</p><p>通过 make 的 <code>-f</code> 和 <code>--file</code> 参数，可以指定特定文件名的 Makefile 。例如：<code>make -f Make.Linux</code></p></li><li class="lvl-3"><p>读入被include的其它Makefile。</p><p>如果文件没有指定绝对路径或相对路径，会按照如下顺序搜索：</p><ul class="lvl-2"><li class="lvl-5"><p>当前目录；</p></li><li class="lvl-5"><p>make 使用 <code>-I</code> / <code>--include-dir</code> 参数来指定的目录；</p></li><li class="lvl-5"><p>一个特定目录 <code>&lt;prefix&gt;/include</code> ，其中 <code>prefix</code> 一般是 <code>/usr/local/bin</code> 或 <code>/usr/include</code> 。</p></li></ul><p>如果有文件没有找到的话：</p><ul class="lvl-2"><li class="lvl-5"><p>make会生成一条警告信息，但不会马上出现致命错误；</p></li><li class="lvl-5"><p>此时会继续载入其它的文件，一旦完成makefile的读取，make会再重试这些没有找到，或是不能读取的文件，如果还是不行，make才会出现一条致命信息。</p></li></ul><p>如果你想让make不理那些无法读取的文件，而继续执行，你可以在include前加一个减号“-”。如：<code>-include &lt;filename&gt;</code>。其表示，无论include过程中出现什么错误，都不要报错继续执行。和其它版本make兼容的相关命令是sinclude，其作用和这一个是一样的。</p><p>除此之外，如果当前环境中定义了环境变量 <code>MAKEFILES</code> ，那么make会把这个变量中的值做一个类似于 <code>include</code> 的动作。这个变量中的值是其它的Makefile，用空格分隔。只是，它和 <code>include</code> 不同的是，从这个环境变量中引入的Makefile的“目标”不会起作用，如果环境变量中定义的文件发现错误，make也会不理。</p><p>建议不要使用这个环境变量，因为只要这个变量一被定义，那么当你使用make时，所有的Makefile都会受到它的影响。也许有时候Makefile出现了怪事，就应该去看看当前环境中有没有定义这个变量。</p></li><li class="lvl-3"><p>初始化文件中的变量。</p></li><li class="lvl-3"><p>推导隐晦规则，并分析所有规则。</p></li><li class="lvl-3"><p>为所有的目标文件创建依赖关系链。</p></li><li class="lvl-3"><p>根据依赖关系，决定哪些目标要重新生成。</p></li><li class="lvl-3"><p>执行生成命令。</p></li></ol><p>1-5步为第一个阶段，6-7为第二个阶段。</p><p>第一个阶段中，如果定义的变量被使用了，那么，make会把其展开在使用的位置。但make并不会完全马上展开，make使用的是拖延战术，如果变量出现在依赖关系的规则中，那么仅当这条依赖被决定要使用了，变量才会在其内部展开。</p><h2 id="Makefile-中的内容">Makefile 中的内容</h2><p>Makefile里主要包含了五个内容：<b>显式规则</b>、<b>隐晦规则</b>、<b>变量定义</b>、<b>文件指示</b> 和 <b>注释</b>。</p><h3 id="显式规则">显式规则</h3><p>即 基本规则 中规定的部分。由编写者明确指出想要生成的文件、依赖关系以及生成的命令。</p><h3 id="隐晦规则-自动推导">隐晦规则 / 自动推导</h3><p>GNU的make很强大，它可以自动推导文件以及文件依赖关系后面的命令。这种规则方便我们比较简略的书写 Makefile。</p><p>只要make看到一个 <code>.o</code> 文件：</p><ul class="lvl-0"><li class="lvl-2"><p>prerequisites: 会自动的把 <code>.c</code> 文件加在依赖关系中，例如：</p><p>如果make找到一个 <code>whatever.o</code> ，那么 <code>whatever.c</code> 就会是 <code>whatever.o</code> 的依赖文件。</p></li><li class="lvl-2"><p>command: 默认的编译语句也会被自动加入，例如：</p><p><code>cc -c whatever.c</code> 也会被推导出来。</p></li></ul><h3 id="变量">变量</h3><p>类似于 Linux 中的变量（<code>$</code>）和C语言中的宏，某些文件可能多次出现在 makefile 中，为了简化多次重复记录，引入变量。其本质就是个字符串/别名。</p><ul class="lvl-0"><li class="lvl-2"><p>定义：<code>obj = 1.o 2.o 3.o</code></p></li><li class="lvl-2"><p>使用：<code>$(obj)</code></p></li></ul><h3 id="文件指示">文件指示</h3><p>文件指示分为三种情况：</p><ol><li class="lvl-3"><p>使用 <code>include</code> 关键字，实现在一个Makefile中引用另一个Makefile。类似于C中的 <code>#include</code> ，被包含的文件会原模原样的放在当前文件的包含位置。语法实例如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">include</span> &lt;filename&gt;<br><span class="hljs-comment"># filename 可以是当前shell的文件名模式，可以包含 路径 与 通配符</span><br><span class="hljs-comment"># include 关键字前不能以 tab 键开始，可以有空格</span><br><br><span class="hljs-comment"># 假设文件夹下存在: a.mk, b.mk, c.mk</span><br>bar = e.mk f.mk<br><span class="hljs-keyword">include</span> foo.make *.mk <span class="hljs-variable">$(bar)</span><br><span class="hljs-comment"># 上述语句等价于</span><br><span class="hljs-keyword">include</span> foo.make a.mk b.mk c.mk e.mk f.mk<br></code></pre></td></tr></table></figure></li><li class="lvl-3"><p>根据情况指定 Makefile 中的有效部分，类似于 C语言中的 <code>#if</code> ；</p></li><li class="lvl-3"><p>定义一个多行的命令。</p></li></ol><h3 id="注释">注释</h3><p>注释由 <code>#</code> 打头。所以使用 # 字符时需要加上反斜杠进行转义。</p><h2 id="clean">clean</h2><ul class="lvl-0"><li class="lvl-2"><p>clean 相当于一个标签，并不对应实际的文件。</p></li><li class="lvl-2"><p>作用：清空目标文件（<code>.o</code> 以及执行文件）。这种设计是为了保持文件清洁，是一种程序员的“基本修养”。</p></li><li class="lvl-2"><p>不成文的规则是：clean 总是放在文件的最后。</p><p>这也是避免被放在文件开头的情况。</p></li><li class="lvl-2"><p>clean 常常与伪目标连用。</p></li></ul><h2 id="伪目标">伪目标</h2><ul class="lvl-0"><li class="lvl-2"><p>伪目标不是一个文件，而是一个标签。用于实现某种特殊功能。</p></li><li class="lvl-2"><p>既然伪目标不是文件，那么make 无法根据依赖关系来判断其是否执行。</p><p>执行伪目标需要显式的指定该目标。</p></li><li class="lvl-2"><p>注意伪目标名不要与文件名重名，否则失去伪目标本身的用处。</p><p>为了防止伪目标与文件重名的情况，使用标记 <code>.PHONY</code> 来显式指明一个目标是伪目标。无论是否有这个同名文件，都按照伪目标方式，仅执行命令部分。</p></li></ul><p>两种常用的伪目标：</p><ol><li class="lvl-3"><p><code>all</code></p></li><li class="lvl-3"><p><code>clean</code></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Makefile</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GCC</title>
    <link href="/2023/02/25/GCC/"/>
    <url>/2023/02/25/GCC/</url>
    
    <content type="html"><![CDATA[<h1>GCC</h1><p>GNU Compiler Collection<br>A set of compilers for various languages, provides all of the infrastructure for building software in those languages from source code to assembly.</p><p><code>gcc [flags] [infile(s)]</code></p><h2 id="Flags">Flags</h2><p>除了上述几个编译过程分离化的之外，一些常用的Flags:</p><ul class="lvl-0"><li class="lvl-2"><p><code>-Ox</code> : Code optimization 设置优化级别。</p><p>在执行时间上优化：</p><p>从0到3，从默认的不优化（编译耗时最短，执行耗时最多）到最高级优化（编译耗时最多，执行效率最高）。</p><ul class="lvl-2"><li class="lvl-4"><p><code>-O0</code> : Compile as fast as possible, don’t optimize [this is the default]</p></li><li class="lvl-4"><p><code>-O1</code>, <code>-O2</code>，<code>-O3</code>: Optimize for reduced execution time [higher numbers are more optimized]</p></li></ul><p>在执行时间优化的基础上，保证<code>objdump</code>的可读性以便于Debug：</p><ul class="lvl-2"><li class="lvl-4"><p><code>-Og</code> : Optimize for execution time, but try to avoid making interactive debugging harder</p></li></ul><p>在代码体积上，而非时间上进行优化：</p><ul class="lvl-2"><li class="lvl-4"><p><code>-Os</code> : Optimize for code size instead of execution time</p></li></ul></li><li class="lvl-2"><p><code>-g</code> : 输出 debug 信息/注释，便于使用 gdb 时确定变量与代码。</p><p>produce “debug info”: annotate assembly so gdb can find variables and source code</p><blockquote><p>如果不包含-g flag，生成的可执行文件并不支持使用GDB进行调试。因为GDB调试需要一些必要的调试信息，比如代码行号，符号表等，而普通情况下生成的可执行文件中则没有。</p></blockquote></li><li class="lvl-2"><p><code>-Wall</code> : 输出更多的警告信息。</p><ul class="lvl-2"><li class="lvl-4"><p>enable many “warning” messages that should be on by default, but aren’t</p></li><li class="lvl-4"><p>Does NOT turn on all of the warning messages GCC can produce.</p></li><li class="lvl-4"><p>See <a href="https://gcc.gnu.org/onlinedocs/gcc-4.8.0/gcc/Warning-Options.html">https://gcc.gnu.org/onlinedocs/gcc-4.8.0/gcc/Warning-Options.html</a> for many more</p></li></ul></li><li class="lvl-2"><p><code>-Werror</code> : turns all warnings into errors 把警告变成错误</p></li><li class="lvl-2"><p><code>-std=c99</code> : use the 1999 version of the C standard and disable some (not all!) extensions</p></li></ul><h2 id="内联汇编-Inline-Assembly">内联汇编 Inline Assembly</h2><p>某些使用场景下，汇编语言的效率要高于高级语言，因为很多机器特性是 C 等高级语言所访问不到的。这就引出了把 C 程序和汇编代码结合起来的需求。</p><p>两种实现方式：</p><ol><li class="lvl-3"><p>编写完整的功能函数，放入独立的汇编代码文件中（.s结尾）：汇编器和连接器最终会对所有文件进行合并。</p></li><li class="lvl-3"><p>使用 GCC 的内联汇编：使用 <b>asm伪指令</b>，在程序中包含简短的汇编代码。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>gcc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>15-213: Representing and Manipulating Information</title>
    <link href="/2023/02/15/15-213-Representing-and-Manipulating-Information/"/>
    <url>/2023/02/15/15-213-Representing-and-Manipulating-Information/</url>
    
    <content type="html"><![CDATA[<h2 id="Floating-Point-2">Floating Point</h2><blockquote><h4 id="基本二进制表示与IEEE-754标准-2">基本二进制表示与IEEE 754标准</h4><p>Fractional Binary Numbers ：小数部分分数表示</p><ul class="lvl-1"><li class="lvl-2"><p>只能表示一部分分数（除以2的次幂），其他的都是无限循环的位级表示。</p></li><li class="lvl-2"><p>总位数有限，小数点的位置比较重要</p><ul class="lvl-3"><li class="lvl-4">左移：小数位数增加，整数位数减少，数据的表示范围变小</li><li class="lvl-4">右移：小数位数减少，整数位数增加，数据的表示精度变小</li></ul></li></ul><p>基本的表示法肯定不适用，所以使用IEEE754表示方法来平衡精度和范围的问题。</p><ul class="lvl-1"><li class="lvl-2"><p>IEEE 754 is hard to make fast in hardware. Numerical analysts predominated over hardware designers in defining standard.</p><p>更注重功能性，从硬件层面来看速度很慢。</p></li></ul></blockquote><h3 id="组成-2">组成</h3><p>IEEE 754标准由三部分组成，长度分布如图所示。</p><p><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/pics-master/20211210152223.png" alt=""></p><blockquote><p>区分数值（Numerical Form）与编码（Encoding）</p></blockquote><h4 id="1-Sign-标志位-2">1 Sign 标志位</h4><blockquote><p>MSB $s$ is sign bit s.</p></blockquote><p>一位的正负标志位，没什么可说的。</p><h4 id="2-Significand-尾数-2">2 Significand 尾数</h4><blockquote><p>$frac$ field encodes Significand M (but is not equal to M)</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>原模原样抄下来的<strong>原码</strong>位数。</p></li><li class="lvl-2"><p>前面有<strong>隐含1</strong>，即位数M的值为 <strong>$1.frac$</strong></p></li></ul><h4 id="3-Exponent-指数-2">3 Exponent 指数</h4><blockquote><p>$exp$ field encodes exponent E (but is not equal to E)</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>在规格化状态下，采用<strong>移码</strong>表示：</p><p>$exp = E + bias$，其中 $bias = 2^{n-1} - 1$， $n$ 为指数的位数（8/11），即值为127/1023。</p><p>采用移码的目的是为所有的指数加上一个偏置，从而使得指数域全部为整数，方便在计算的时候进行<strong>对阶</strong>。</p></li><li class="lvl-2"><p>指数<strong>编码</strong>为特殊值如全0和全1有特别含义，见<a href="###%E7%8A%B6%E6%80%81">状态部分</a>。</p></li></ul><h3 id="状态-2">状态</h3><p>根据**指数域（exp）**的不同来划分为三种状态，这三种状态对于encoding的解读是不一样的。</p><h4 id="1-Normalized-规格化-2">1 Normalized 规格化</h4><blockquote><p>$exp\neq000\ldots0$ 且 $exp\neq111\ldots1$</p><p>表示正常区间的浮点数。</p></blockquote><h5 id="指数部分-3">指数部分</h5><ul class="lvl-0"><li class="lvl-2"><p>移码表示，见[指数部分](####Exponent 指数)。</p></li><li class="lvl-2"><p>表示范围：</p><ul class="lvl-2"><li class="lvl-4">编码 exp域： $000\ldots01$ ~ $111\ldots10$</li><li class="lvl-4">数值 E：<ul class="lvl-4"><li class="lvl-6">Single precision: -126 ~ 127</li><li class="lvl-6">Double precision: -1022 ~ 1023</li></ul></li></ul></li></ul><h5 id="尾数部分-3">尾数部分</h5><ul class="lvl-0"><li class="lvl-2"><p>前有隐含1，见[尾数部分](####Significand 尾数)。</p></li><li class="lvl-2"><p>表示范围：</p><ul class="lvl-2"><li class="lvl-4">最小时 $M=1$ ，即 $frac = 000\ldots0$ ；</li><li class="lvl-4">最大时 $M = 2 - \epsilon$ ，即 $frac = 111\ldots1$ 。</li></ul></li></ul><h4 id="2-Denormalized-非规格化-2">2 Denormalized 非规格化</h4><blockquote><p>$exp = 000\ldots0$ ，即<strong>指数域全0</strong>。</p><p>表示接近0的情况。</p></blockquote><h5 id="指数部分-4">指数部分</h5><p>$E=1-bias$ 而非 $0-bias$，即此时指数 $E$ 为固定值：</p><ul class="lvl-0"><li class="lvl-2"><p>Single precision: $E = -126$</p></li><li class="lvl-2"><p>Double precision: $E = -1022$</p></li></ul><p>均为指数域最小值，用于表示接近0的实数域，即 $0.xx \times 2^{-126/-1022}$。</p><h5 id="尾数部分-4">尾数部分</h5><ul class="lvl-0"><li class="lvl-2"><p>前有<strong>隐含0</strong>（而非隐含1），以用于表示接近0的实数域；</p></li><li class="lvl-2"><p>$frac=000\ldots0$ 表示0，根据标志位的正负存在正零和负零；</p><ul class="lvl-2"><li class="lvl-4">正零和整数Integer的表示是完全一致的，即编码为<strong>全零</strong>。</li></ul></li><li class="lvl-2"><p>$frac \neq000\ldots0$ 表示最接近0的实数域部分，该部分为<strong>等间距的（equispaced）</strong>，关于间距问题详见<a href="####%E9%97%B4%E8%B7%9D">间距部分</a>。</p></li></ul><h4 id="3-Special-特殊值-2">3 Special 特殊值</h4><blockquote><p>$exp=111\ldots1$，即指数域全1。</p><p>用于表示<strong>无穷大</strong>与<strong>非法值（NaN）</strong>。</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>$frac =000\ldots0$ ：表示无穷大。</p><ul class="lvl-2"><li class="lvl-4">当运算出现<strong>溢</strong>出时即为无穷大；</li><li class="lvl-4">根据标志位的正负，分为正无穷大和负无穷大；</li><li class="lvl-4">对无穷大进行任何操作结果仍为无穷大；</li><li class="lvl-4">除0的结果也是正负无穷大，符号取决于操作数符号。</li></ul></li><li class="lvl-2"><p>$frac = 111\ldots1$ ：表示<strong>NaN (Not a number)</strong>，即非法值。</p><ul class="lvl-2"><li class="lvl-4">用于一些非法操作，无法决定数字的值的情况，例如：<ul class="lvl-4"><li class="lvl-6">$sqrt(-1)$， $\infty - \infty$， $\infty \times 0$， $\ldots$</li></ul></li><li class="lvl-4">从编码上看（视为无符号数），<strong>NaN比其他值都要更大</strong>（全1或符号位为0其余位全1）见分布部分的<a href="####Visualization"><strong>数轴</strong></a>。</li></ul></li><li class="lvl-2"><p>$frac$ 尾数部分不会为其他值，无意义。</p></li></ul><h3 id="分布-2">分布</h3><h4 id="Visualization-2">Visualization</h4><p>通过数轴图来直观地感受IEEE 754在整个实数中的分布及其表示范围</p><p><a href="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/pics-master/20211210152318.png">https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/pics-master/20211210152318.png</a></p><p><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/pics-master/20211210152318.png" alt=""></p><h4 id="间距-2">间距</h4><p><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/pics-master/20211210164457.png" alt=""></p><h4 id="临界点-2">临界点</h4><h3 id="计算-2">计算</h3><h4 id="Comparison-比较-2">Comparison 比较</h4><blockquote><p>Can (Almost) use unsigned integer comparison</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>首先比较符号位</p><ul class="lvl-2"><li class="lvl-4">特殊情况：正零与负零是相等的。</li></ul></li><li class="lvl-2"><p>比较指数位：对阶</p></li><li class="lvl-2"><p>NaN在编码上比其他值都大（$111\ldots1$ 或 $011\ldots1$）</p><ul class="lvl-2"><li class="lvl-4">NaN与其他数的比较的结果？还没查</li></ul></li><li class="lvl-2"><p>其他情况与无符号数基本一致。</p><ul class="lvl-2"><li class="lvl-4">Denorm vs. normalized : 对阶时denorm为全0</li><li class="lvl-4">Normalized vs. infinity</li></ul></li></ul><h4 id="Rounding-舍入-2">Rounding 舍入</h4><blockquote><p>Basic idea:</p><ul class="lvl-1"><li class="lvl-2">First compute exact result</li><li class="lvl-2">Make it fit into desired precision<ul class="lvl-3"><li class="lvl-4">Possibly overflow, if exponent too large</li><li class="lvl-4">Possibly round to fit into $frac$</li></ul></li></ul><p>先计算出实际值，然后在尽可能保留精度的前提下进行舍入。</p></blockquote><p>四种舍入模式（可以在汇编语言中选择使用的模式）：</p><ul class="lvl-0"><li class="lvl-2"><p>Towards zero 靠近0的舍入：即大于0时向下舍入，小于0时向上舍入</p></li><li class="lvl-2"><p>Round down 向下舍入：存在偏低的统计偏差 under-estimated</p></li><li class="lvl-2"><p>Round up 向上舍入：存在偏高的统计偏差 over-estimated</p></li><li class="lvl-2"><p><strong>Nearest even</strong> 正中间的值向偶数舍入</p><ul class="lvl-2"><li class="lvl-4"><p>Default mode：默认的舍入模式，只有通过汇编才能改变为其他模式</p></li><li class="lvl-4"><p>可以避免统计偏差（statistically biased）</p></li><li class="lvl-4"><p>舍入更近的值，当值正好在正中间时，选择使得<strong>最低有效位为偶数</strong>的舍入方式。 When exactly halfway between two possible values, round so that least significant digit is even.</p><p>从二进制的角度来看：</p><ul class="lvl-4"><li class="lvl-6"><p>Even 偶数： 即LSB为0</p></li><li class="lvl-6"><p>Halfway 正中间的值：形如 $100\ldots_{2}$</p></li></ul></li></ul></li></ul><h4 id="Addition-加法-2">Addition 加法</h4><h5 id="1-计算步骤-3">1 计算步骤</h5><ul class="lvl-0"><li class="lvl-2"><p>对阶：将指数小的进行左移至二者指数相同后再相加，最终结果的指数跟着指数大的走。</p><p>assume $E_{1} &gt; E_{2}$ :</p><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/pics-master/20211210221731.png" style="zoom:50%;" /></li><li class="lvl-2"><p>Exact Result 计算实际的值</p><ul class="lvl-2"><li class="lvl-4">符号位 $s$ 与尾数 $M$ 根据对阶后的值进行有符号数加法；</li></ul></li><li class="lvl-2"><p>Fixing 修改数值使其符合IEEE 754标准</p><ul class="lvl-2"><li class="lvl-4">修正尾数：<ul class="lvl-4"><li class="lvl-6">If $M \geq 2$, shift $M$ right, increment $E$</li><li class="lvl-6">If $M &lt; 1$, shift $M$ left $k$ positions, decrement $E$ by $k$</li></ul></li><li class="lvl-4">Overflow 溢出：指数 $E$ 过大</li><li class="lvl-4">对尾数 $M$ 进行舍入（按照前面提到的[舍入方式](####Rounding 舍入)）。</li></ul></li></ul><h5 id="2-Mathematical-Properties-数学性质-3">2 Mathematical Properties 数学性质</h5><ul class="lvl-0"><li class="lvl-2"><p>Closed under addition 加法封闭</p></li><li class="lvl-2"><p>Commutative 符合交换律</p></li><li class="lvl-2"><p>Associative 不符合结合律</p><p>如果大数和小数相差太大（从指数上来看），尾数的位数可能并不够表示（中间需要太多0）<br>$$<br>(3.14+1e10)-1e10=0, \space\space 3.14 + (1e10-1e10) = 3.14<br>$$</p></li><li class="lvl-2"><p>0 is additive identity. 0为加法恒等元，意味着对于群内任意值 $a$， 有 $a+0=a$。</p></li><li class="lvl-2"><p>Every element has <strong>additive inverse</strong>, except for infinities &amp; NaNs.</p><p>除了特殊值情况（无穷大与非法值）之外，其他元素均存在逆元。</p></li><li class="lvl-2"><p>Monotonicity, except for infinities &amp; NaNs.</p><p>除了特殊值情况（无穷大与非法值）之外，均符合单调性。即 $a\geq b\space \Rightarrow a+c \geq b+c $ 。</p></li></ul><h4 id="Multiplication-乘法-2">Multiplication 乘法</h4><h5 id="1-计算步骤-4">1 计算步骤</h5><ul class="lvl-0"><li class="lvl-2"><p>Exact Result 实际计算值</p><ul class="lvl-2"><li class="lvl-4">Sign 标志位：$s_{1}$ ^ $s_{2}$</li><li class="lvl-4">Significand 尾数：$M_{1} \times M_{2}$</li><li class="lvl-4">Exponent 指数：$E_{1} + E_{2}$</li></ul></li><li class="lvl-2"><p>Fixing 修改数值使其符合IEEE 754标准</p><ul class="lvl-2"><li class="lvl-4">如果尾数$M$计算后大于等于2 （即$M=10.xx\ldots_{2}$），则对 $M$ 进行右移使其符合隐含1的格式，并相应的增加指数 $E$ 。</li><li class="lvl-4">Overflow: 如果指数 $E$ 过大则溢出。</li><li class="lvl-4">对尾数 $M$ 进行舍入（按照前面提到的[舍入方式](####Rounding 舍入)）。</li></ul></li><li class="lvl-2"><p>Implementation 具体实现</p><ul class="lvl-2"><li class="lvl-4">对硬件计算资源要求最多的还是尾数相乘（使用乘法器）。</li></ul></li></ul><h5 id="2-Mathematical-Properties-数学性质-4">2 Mathematical Properties 数学性质</h5><ul class="lvl-0"><li class="lvl-2"><p>Closed under multiplication 乘法封闭</p><p>但有可能结果产生特殊值（infinity or NaN）</p></li><li class="lvl-2"><p>Commutative 符合交换律</p></li><li class="lvl-2"><p>Associative 不符合结合律</p><p>出现溢出与精度舍入的情况会导致结果不同</p></li><li class="lvl-2"><p>1 is multiplicative identity. 1为乘法恒等元</p></li><li class="lvl-2"><p>Multiplication <strong>does not</strong> distribute over addition. 不满足加法上的分配律</p><p>出现溢出与精度舍入的情况会导致结果不同</p></li><li class="lvl-2"><p>Monotonicity 单调性</p><p>除了特殊值情况之外都满足。</p></li></ul><h3 id="C语言中的表示-2">C语言中的表示</h3><p>提供了两种类型，即单精度float与双精度double。</p><h4 id="Conversion-and-casting-类型转换-2">Conversion and casting 类型转换</h4><p>C中要注意的是<strong>不同类型之间的转换</strong>：</p><ul class="lvl-0"><li class="lvl-2"><p>在<code>int</code>, <code>float</code>,<code>double</code>之间进行转换会对二进制位表示产生影响。</p><p>Casting between <code>int</code>, <code>float</code>,<code>double</code> <strong>changes bit representation</strong>.</p><p>区分于<code>unsigned</code>与<code>int</code>之间的转换，其二进制位表示并没有任何变化，只是对位的含义解读产生了变化。</p></li><li class="lvl-2"><p><code>double</code>/<code>float</code> $\rightarrow$ <code>int</code></p><ul class="lvl-2"><li class="lvl-4">Truncates fractional part</li><li class="lvl-4">Not defined when out of range or NaN: Generally sets to <code>TMin</code>.</li></ul></li><li class="lvl-2"><p><code>int</code> $\rightarrow$ <code>double</code></p><ul class="lvl-2"><li class="lvl-4"><p>Exact conversion, as long as <code>int</code> has $\leq$ 53 bit word size.</p><p>double尾数为52位，再多需要舍入。</p></li></ul></li><li class="lvl-2"><p><code>int</code> $\rightarrow$ <code>float</code></p><ul class="lvl-2"><li class="lvl-4">Will round according to rounding m</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>15-213</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>15-213: Machine-Level Representation</title>
    <link href="/2023/02/15/15-213-Machine-Level-Representation/"/>
    <url>/2023/02/15/15-213-Machine-Level-Representation/</url>
    
    <content type="html"><![CDATA[<p>关注 x86-64 汇编语言：语法及其实际执行过程。</p><h2 id="机器代码-Machine-Level-Code-2">机器代码 Machine-Level Code</h2><h3 id="两种抽象机制-2">两种抽象机制</h3><h4 id="指令集体系结构-Instruction-Architecture-2">指令集体系结构 Instruction Architecture</h4><p>即 ISA。对 CPU 的抽象。定义了处理器的状态、指令格式、指令对处理器状态的影响等等。机器级代码能够接触到很多对C语言隐藏的特性，其中很重要的一个就是CPU中的 <b>寄存器</b>。</p><h4 id="虚拟存储器-Virtual-Memory-2">虚拟存储器 Virtual Memory</h4><p>按字节寻址的一个大数组。<br>x86-64的虚拟地址由64位指定。目前的实现中，<b>高地址的16位必须置 0</b> ，所以一个地址实际能指向的范围是 $2^{48}$ 或 256TB 个字节。</p><h3 id="x86-64-汇编-2">x86-64 汇编</h3><h4 id="CISC-2">CISC</h4><p>x86-64 属于 CISC 风格汇编语言。特性是指令长度不定长，从 1 到 15 个字节不等。常用的指令以及操作数较少的指令所需的字节数少，而那些不太常用或操作数较多的指令所需字节数较多。</p><h4 id="C程序与汇编代码的结合-2">C程序与汇编代码的结合</h4><ol><li class="lvl-3"><p>写单独的 .s 汇编文件编写完整的函数，放进独立的汇编代码文件中（.s），让 <b>汇编器</b> 和 <b>链接器</b> 来合并。</p></li><li class="lvl-3"><p>GCC 的内联汇编（inline assembly）用 asm 伪指令在 C 程序中包含简短的汇编代码。可以大大减少与机器相关的代码量。</p></li></ol><p>需要注意的是，C 代码与汇编代码相结合会使得 这部分代码与特定机器相关。所以尽量减少这种方法的使用，除非当前机器的某些特性只能通过该种方式来访问。</p><h4 id="ATT-与-Intel-格式-2">ATT 与 Intel 格式</h4><p>下文均采用 ATT 格式表述。</p><h2 id="数据格式-Data-Formats-2">数据格式 Data Formats</h2><p>如下表所示，为 x86-64 下 C语言中数据类型的相关信息。其中，通过在指令后加相应的后缀来指明操作数的大小：字节（<code>b</code>）、字（<code>w</code>）、双字（<code>l</code>） 与 四字（<code>q</code>）。</p><table><thead><tr><th>C declaration</th><th>Intel data type</th><th style="text-align:center">Assembly-code suffix</th><th style="text-align:center">Size (bytes)</th></tr></thead><tbody><tr><td>char</td><td>Byte</td><td style="text-align:center">b</td><td style="text-align:center">1</td></tr><tr><td>short</td><td>Word</td><td style="text-align:center">w</td><td style="text-align:center">2</td></tr><tr><td>int</td><td>Double word</td><td style="text-align:center">l</td><td style="text-align:center">4</td></tr><tr><td>long</td><td>Quad word</td><td style="text-align:center">q</td><td style="text-align:center">8</td></tr><tr><td>char*</td><td>Quad word</td><td style="text-align:center">q</td><td style="text-align:center">8</td></tr><tr><td>float</td><td>Single precision</td><td style="text-align:center">s</td><td style="text-align:center">4</td></tr><tr><td>double</td><td>Double precision</td><td style="text-align:center">l</td><td style="text-align:center">8</td></tr></tbody></table><p>浮点数与上述格式略有不同，<code>float</code>对应独有的后缀 <code>s</code>；而<code>double</code>对应的指令后缀也为<code>l</code>。这并不会与上述双字的情况产生歧义，因为 <b>浮点数采用的是一组完全不同的指令和寄存器</b>。</p><h2 id="数据访问-Accessing-Data-2">数据访问 Accessing Data</h2><p>访问的数据来源有两个：</p><ol><li class="lvl-3"><p>一组 16 个 存储 64 位值的 <b>通用目的寄存器（general-purpose）</b>。</p></li><li class="lvl-3"><p>内存。</p></li></ol><h3 id="寄存器-Register-2">寄存器 Register</h3><p>如图所示，其中：</p><ul class="lvl-0"><li class="lvl-2"><p><code>%r8</code>到<code>%r15</code>是 x86-64 新增的 8 个寄存器；</p></li><li class="lvl-2"><p>不同后缀的指令进行不同大小规模的操作，修改对应大小的寄存器位。对于指令生成的结果小于 64 位 / 8 字节的情况，剩余高位部分的填充按照如下规则：</p><ol><li class="lvl-5">生成 1 字节 或 2 字节结果的指令：保持剩下的高位字节不变；</li><li class="lvl-5">生成 4 字节 / 32位结果的指令：<b>将剩下的高位 4 个字节全部置0</b>。该规则是向前继承 IA32 时采用的特性。</li></ol></li></ul><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/202303061120011.png" style="zoom: 50%;" /><h4 id="功能约定-2">功能约定</h4><p>不同的寄存器扮演不同的功能角色（如上图中右侧注释）。有一组标准的编程规范控制着如何使用寄存器。</p><ul class="lvl-0"><li class="lvl-2"><p>返回值：<code>%rax</code></p></li><li class="lvl-2"><p>参数：按顺序从前到后，<code>%rdi</code>、<code>%rsi</code>、<code>%rdx</code>、<code>%rcx</code>、<code>%r8</code>、<code>%r9</code></p></li><li class="lvl-2"><p>局部变量</p></li></ul><h3 id="内存-Memory-2">内存 Memory</h3><p>从程序的角度访问的是专属的虚拟内存，分布如图。地址从下往上增大。</p><ul class="lvl-0"><li class="lvl-2"><p>高地址处存放操作系统内核保留区域；</p></li><li class="lvl-2"><p>栈：向下增长，低地址为栈顶；</p></li><li class="lvl-2"><p>堆：向上增长，新元素地址更大；</p></li></ul><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/202303061120825.png" style="zoom:50%;" /><h3 id="操作数-Operand-2">操作数 Operand</h3><h4 id="操作数格式-2">操作数格式</h4><p>操作数格式分为三种：</p><ol><li class="lvl-3"><p>立即数 immediate</p><p>表示常数值。书写方式为 <code>$</code> 符号后跟一个整数。不同指令允许的立即数值范围肯定不同，汇编器会自动选择最紧凑的方式来进行数值编码。</p></li><li class="lvl-3"><p>寄存器 register</p><p>书写方式为 <code>R[%xxx]</code></p></li><li class="lvl-3"><p>内存引用 memory reference</p><p>书写方式为 <code>M[ea]</code>。表示根据计算出来的有效地址（Effective Address, EA） 来访问对应位置的内存。</p></li></ol><p>不同指令操作数不同，通常为一个或多个，我们按照 源操作数 与 目的操作数 两种类型来讨论。</p><ul class="lvl-0"><li class="lvl-2"><p>源操作数：可以是立即数、也可以是寄存器或内存读出；</p></li><li class="lvl-2"><p>目的操作数：存放在寄存器或者内存中。</p></li></ul><h4 id="寻址模式-2">寻址模式</h4><p>操作数具体的寻址格式如下表：</p><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/202303061120834.png" style="zoom: 33%;" /><h3 id="数据传送指令-Data-Management-Instructions-2">数据传送指令 Data Management Instructions</h3><ul class="lvl-0"><li class="lvl-2"><p>将数据从一个位置复制到另一个位置的指令。</p></li><li class="lvl-2"><p>源操作数：可以是 立即数、寄存器、或内存引用；</p><p>目的操作数：可以是 寄存器、内存引用；</p><p>传送指令的两个操作数不能同时指向内存。即<b>不能实现内存到内存的直接移动</b>，而需要寄存器来作中继。</p></li><li class="lvl-2"><p>操作数大小要与指令后缀指定的大小相匹配，指令也只会更新对应大小的位；</p><p>唯一的例外就是：<b>当目的操作数为 双字 / long word / 32bits 大小的寄存器时，高位会全部置 0。</b></p></li></ul><h4 id="基础传送指令类-2">基础传送指令类</h4><p>首先是最基础的 MOV 指令类，将数据简单的从源位置复制到目的位置，不作任何修改：</p><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/202303061120141.png" style="zoom: 50%;" /><p><code>movabsq</code> 是一个特殊为 64 位立即数设置的指令。这是因为 <code>movq</code> 指令的源操作数只能接受 32 位补码立即数，然后将该值符号扩展得到 64 位的值后送入目的位置。而 <code>movabsq</code> 则可以直接以任意 64 位立即数值作为源操作数，并且只能以（64位）寄存器作为目的操作数。</p><h4 id="扩展传送指令类-2">扩展传送指令类</h4><p>扩展传送指令即，将 尺寸较小的源值 复制到 尺寸较大的目的 中时使用。扩展时根据扩展形式分为以下两种：</p><ol><li class="lvl-3"><p>零扩展传送指令</p><p>即剩余高位全补 0 。</p><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/202303061121018.png" style="zoom: 50%;" /><ul class="lvl-2"><li class="lvl-5"><p>z 代表 zero，后两位为大小指示符。</p></li><li class="lvl-5"><p>不存在 <code>movzlq</code> 指令。因为对源为 long word 的情况，高位会自动补0。直接使用 <code>movl</code> 指令即可达到同样的效果。</p></li></ul></li><li class="lvl-3"><p>符号扩展传送指令</p><p>即对剩余高位进行符号扩展。</p><p>注意一个特殊的指令：</p><ul class="lvl-2"><li class="lvl-5"><p><code>cltq</code>（convert long to quad）：总是将 <code>%eax</code> 作为源，将 <code>%rax</code> 作为目的。即32位符号扩展至64位。</p><p>其效果与指令 <code>movslq %eax, %rax</code> 完全一致，但编码更为紧凑。</p></li></ul><p><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/202303061121707.png" alt=""></p></li></ol><blockquote><p>数据传送指令的一些注意事项（练习3.4）：</p><ul class="lvl-1"><li class="lvl-2"><p>扩展传送指令的选择（符号扩展还是零扩展？），主要取决于源操作数：</p><ul class="lvl-3"><li class="lvl-4">源操作数为 无符号，则采用零扩展；</li><li class="lvl-4">源操作数为 有符号，则采用符号扩展。</li></ul></li><li class="lvl-2"><p>同时存在 符号变化 与 大小变化 的情况下，先转换大小、再转换符号（2.2.6节+练习题3.4，见书）。</p><p>这个规则是C语言标准要求的。</p></li><li class="lvl-2"><p>仅大小转换的情况，先完全读出，再按照大小存储（练习题3.4）。</p></li></ul></blockquote><h3 id="压入和弹出栈指令-2">压入和弹出栈指令</h3><p>首先关注<strong>程序栈（Program Stack）</strong>：</p><ul class="lvl-0"><li class="lvl-2"><p><b>内存</b> 的一部分，可以通过标准内存的寻址方式访问。栈的位置通过栈顶指针 <code>%rsp</code> 来确定；</p></li><li class="lvl-2"><p>对于处理 <b>过程调用</b> 至关重要；</p></li><li class="lvl-2"><p>栈向下增长，栈顶元素处于低地址；</p></li></ul><p>具体指令见下表：</p><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/202303061121967.png" style="zoom:50%;" /><p>两条指令的效果如上表中所述，压入和弹出栈指令与如下指令组合等价：</p><ul class="lvl-0"><li class="lvl-2"><p><code>pushq %source</code>:</p><ul class="lvl-2"><li class="lvl-4"><code>subq %8, %rsp</code></li><li class="lvl-4"><code>movq %source, (%rsp)</code></li></ul></li><li class="lvl-2"><p><code>popq</code></p><ul class="lvl-2"><li class="lvl-4"><code>movq (%rsp), %rax</code></li><li class="lvl-4"><code>addq %8, %rsp</code></li></ul></li></ul><p>栈相关指令的优势就在于编码长度更短。</p><h2 id="算术与逻辑操作-2">算术与逻辑操作</h2><p>针对整数的算术与逻辑操作，如下：</p><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/202303061121100.png" style="zoom:33%;" /><h3 id="加载有效地址-LEA-2">加载有效地址 LEA</h3><p>加载有效地址（load effective address）指令其实就是数据传送指令的简单变形。唯一的区别在于：<code>mov</code>指令根据寻址模式计算出地址后，读取或存储相应地址空间的数据；而 <code>lea</code> 指令则计算出地址后，直接操作地址数据（即有效地址EA），并没有任何访存相关的操作。</p><p>该指令的作用非常灵活：</p><ul class="lvl-0"><li class="lvl-2"><p>为内存引用产生 <b>指针</b>。毕竟指针的本质就也是地址。</p></li><li class="lvl-2"><p>编译器常常会利用该指令进行一些<b>普通的算术运算</b>，这也是实际汇编代码中最常见的用途。该种用途与有效地址计算完全无关，只是利用了该指令的灵活性计算一些常见算术运算（<b>加法</b> 以及 <b>有限形式的乘法</b>）。</p></li><li class="lvl-2"><p>目的操作数必须为寄存器，即计算结果存放至寄存器中。</p></li></ul><h3 id="一元与二元算术操作-2">一元与二元算术操作</h3><p>没什么特别的。</p><h3 id="移位操作-2">移位操作</h3><p>移位操作的操作数上有一定的功能性约束：</p><ul class="lvl-0"><li class="lvl-2"><p>第一个操作数 $k$：代表位移量，约束为两种格式：</p><ol><li class="lvl-5"><p>立即数。</p></li><li class="lvl-5"><p>单字节寄存器<code>%cl</code></p><p>移位操作如果想要使用寄存器中的数作为位移量，只能使用该特定寄存器。</p><p>形式上来说，单字节对位移量编码，则位移量最大范围可以达到 $2^8 - 1 = 255$ 位。实际进行唯一操作时，会根据数据类型长度来缩减位移量，只采用寄存器中的低位，高位会被忽略。</p></li></ol></li><li class="lvl-2"><p>第二个操作数：要进行移位的目的数。可以是寄存器或者内存引用。</p></li></ul><p>根据逻辑移位和算术移位分为两种移位指令：</p><ul class="lvl-0"><li class="lvl-2"><p>逻辑左移和算术左移完全一致，因为低位肯定都补零；</p></li><li class="lvl-2"><p>逻辑右移和算术右移有区别：逻辑右移高位补零，算术右移高位补符号位。</p></li></ul><h3 id="支持128位数的操作-2">支持128位数的操作</h3><p>64位数的<b>乘除法运算</b>会涉及128位数，Intel 将 128 位数按照规则命名为八字（octal word）。<br>128位数的存放通常使用两个寄存器分别存放高 64 与 低 64 位，如下表为相关的支持指令（均为<b>单操作数指令</b>）：</p><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/202303061122701.png" style="zoom: 33%;" /><p>主要分为 乘法、除法 与 扩展三种操作，相关特点如下：</p><ul class="lvl-0"><li class="lvl-2"><p>乘法：乘法指令有两种不同形式，即双操作数与单操作数两种情况。汇编器会根据操作数的数目分辨出实际为哪条指令。</p></li><li class="lvl-2"><p>除法：无符号除法操作下，<code>%rdx</code> 通常会事先设置为 0。</p></li><li class="lvl-2"><p>扩展：另外一个特殊的指令为 <code>cqto</code> 指令（convert quad to octal）：对于 64 位除法运算，被除数虽然最大能够接受 128 位，但其常常仅为一个 64 位的值。此时我们应该将 64 位的值扩展至 128 位。低 64 位通常存放在 <code>%rax</code> 中，扩展规则如下：</p><ul class="lvl-2"><li class="lvl-4"><p>对于无符号数，将 <code>%rdx</code> 置零；</p></li><li class="lvl-4"><p>对于有符号数，将<code>%rax</code>中的符号位扩展至 <code>%rdx</code>。</p></li></ul><p>以上的扩展操作，可以用指令 <code>cqto</code> 轻松完成。该条指令无需操作数，对于符号扩展可以隐含读取 <code>%rax</code> 中的符号位并复制到 <code>%rdx</code> 中的所有位。</p></li></ul><h2 id="控制-Control-2">控制 Control</h2><p>机器代码提供了两种基本的低级机制来实现有条件的行为：测试数据值，然后通过测试的结果来改变控制流或者数据流。</p><h3 id="基本机制-2">基本机制</h3><h4 id="条件码-Condition-Code-2">条件码 Condition Code</h4><p>除了上述介绍的整数寄存器外，CPU 还维护了一组单个位的 <b>条件码（condition code）寄存器</b> 。条件码寄存器中的内容包括一系列 标志位，其描述了一系列最近的算术或者逻辑操作的属性。最常用的条件码为：</p><ul class="lvl-0"><li class="lvl-2"><p>CF（Carry Flag）：操作得到的结果产生了进位。可用于检查<b>无符号操作</b>的溢出。</p></li><li class="lvl-2"><p>ZF（Zero Flag）：操作得到的结果为0；</p></li><li class="lvl-2"><p>SF（Sign Flag）：操作得到的结果为负数；</p></li><li class="lvl-2"><p>OF（Overflow Flag）：操作导致补码溢出，可以分为正溢出与负溢出。</p></li></ul><h4 id="设置条件码-CMP-TEST-2">设置条件码 CMP &amp; TEST</h4><p>指令的结果会影响条件码的值，不同类型的指令作用结果不同。</p><p>普通算术逻辑指令的注意事项：</p><ul class="lvl-0"><li class="lvl-2"><p><code>lea</code> 指令不修改条件码，除此之外，其他算术逻辑指令都会设置条件码。</p></li><li class="lvl-2"><p>逻辑操作（与或非）：无需考虑进位和溢出的情况，故二者均设置为0；</p></li><li class="lvl-2"><p>移位操作：</p><ul class="lvl-2"><li class="lvl-4">进位标志会被设置为最后一个被移出的位；</li><li class="lvl-4">溢出标志会设置位0；</li></ul></li><li class="lvl-2"><p>自增指令：<code>INC</code>与<code>DEC</code>指令会设置溢出和零标志，但不会改变进位标志。</p></li></ul><p>除此之外，存在两类的特殊指令，其作用只用于设置条件码，而不会改变任何其他寄存器：</p><ul class="lvl-0"><li class="lvl-2"><p><code>CMP</code>：与<code>SUB</code>指令行为一致。用于比较两个操作数之间的大小关系；</p></li><li class="lvl-2"><p><code>TEST</code>：与<code>AND</code>指令行为一致。一般来说典型的用法是：</p><ul class="lvl-2"><li class="lvl-4">设置两个一样的操作数，用于检查该操作数是负数、正数、还是零；</li><li class="lvl-4">其中一个操作数设置为掩码，指明对于另一个操作数哪些位应该被测试。</li></ul></li></ul><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/202303061122142.png" style="zoom:50%;" /><h4 id="使用条件码-SET-2">使用条件码 SET</h4><p>条件码通常不会直接读取，我们可以使用如下指令，根据条件码的取值情况，将一个目标字节设置为0或者1。</p><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/202303061122475.png" style="zoom:33%;" /><ul class="lvl-0"><li class="lvl-2"><p>set指令的目的操作数总是低位单字节寄存器之一，或是一个字节长度的内存位置；</p></li><li class="lvl-2"><p>同义名（synonym）：如表格中所述，有些机器指令可能会有多个名字，比如有符号大于（<code>setg</code>）和不小于（<code>setnle</code>）显然是同样的作用。汇编与反汇编器会随意决定使用哪个名字。</p></li><li class="lvl-2"><p>所有的判断都是根据条件码的不同组合获得的。具体见表格。</p></li><li class="lvl-2"><p>SET通常紧跟在CMP和TEST后面，根据其结果执行操作，以表达判断。</p></li></ul><blockquote><p><strong>关于机器代码对有符号与无符号值操作的区分</strong></p><p>It is important to note how machine code <b>does</b> or <b>does not</b> distinguish between signed and unsigned values.<br>Unlike in C, it does not associate a data type with each program value. Instead, it mostly uses the same instructions for the two cases, because many arithmetic operations have <b>the same bit-level behavior</b> for unsigned and two’s-complement arithmetic.<br>Some circumstances require different instructions to handle signed and unsigned operations, such as using different versions of right shifts, division and multiplication instructions, and different combinations of condition codes.</p></blockquote><h4 id="跳转指令-JMP-2">跳转指令 JMP</h4><p>作用即跳转到标号（label）指明的一个全新的位置。</p><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/202303061122968.png" style="zoom:33%;" /><h4 id="分类-2">分类</h4><ul class="lvl-0"><li class="lvl-2"><p>无条件跳转：</p><ul class="lvl-2"><li class="lvl-4">直接跳转：根据地址直接跳转；</li><li class="lvl-4">间接跳转：间接寻址。寻址方式如前所述。跳转目标可以是寄存器中的值（<code>*%rax</code>），也可以是寄存器中地址指向的内存中的值（<code>*(%rax)</code>）。</li></ul></li><li class="lvl-2"><p>条件跳转：根据条件码组合的结果来确定是否跳转。不跳转就会继续执行下一条指令。</p><p>条件跳转只能是直接跳转，无法进行间接寻址。</p></li></ul><h4 id="目标地址编码-2">目标地址编码</h4><p>在产生目标代码文件时，汇编器会确定所有带标号指令（label）的地址，并将跳转目标（目的指令的地址）编码为跳转指令的一部分。对于目标地址的编码有两种方式，汇编器和链接器会选择适当的编码方式：</p><ul class="lvl-0"><li class="lvl-2"><p>PC-relative（PC相对的）：PC中存放的是下一条指令的地址，即将<b>下一条指令的地址</b>与<b>目标指令的地址</b>之间的差作为编码；</p><p>地址偏移量可以编码为1、2或4个字节。</p><p>相对地址的方式显然具有优势：代码段和指令在多次执行时可能被重定位到内存中的不同位置，而相对地址的编码方式可以对目标代码不做改变就移动到不同位置。</p></li><li class="lvl-2"><p>绝对地址：用4个字节直接指定目标地址。</p></li></ul><hr><p>利用上述基本机制，有多种实现高级语言中控制流变换的方法。</p><h3 id="条件分支-if-2">条件分支 if</h3><p>首先，我们定义一个高级语言下的通用伪代码模板：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">if</span> (test-expr) <br>    then-statement<br><span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">else</span>-statement<br></code></pre></td></tr></table></figure><p>实现条件分支（conditional branches）有两种方式：</p><h4 id="1-使用JMP指令实现条件转移（Conditional-Control）-2">1 使用JMP指令实现条件转移（Conditional Control）</h4><p>条件控制即使用跳转指令JMP来实现。汇编器为 $then-statement$ 与 $else-statement$ 产生各自的代码块，并插入条件与无条件跳转以实现执行正确的代码块。其基本实现逻辑如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">t = text-expr;<br><span class="hljs-keyword">if</span> (!t) <br>        <span class="hljs-keyword">goto</span> <span class="hljs-literal">false</span>;<br>then-statement;<br><span class="hljs-keyword">goto</span> done;<br><span class="hljs-literal">false</span>:<br><span class="hljs-keyword">else</span>-statement;<br>done:<br></code></pre></td></tr></table></figure><p>两种值得注意的特殊情况：</p><ul class="lvl-0"><li class="lvl-2"><p><b>没有 $else$ 语句</b>的情况值得注意的点是：if 和 else 的两个分支的代码部分位置显然可以调换。但对于<b>没有 $else$ 语句</b>的情况，上述方式可以更简单的修改为：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">t = text-expr;<br>  <span class="hljs-keyword">if</span> (!t)<br>     <span class="hljs-keyword">goto</span> done;<br>  then-statment;<br>  done:<br></code></pre></td></tr></table></figure></li><li class="lvl-2"><p>判断语句存在短路求值等复杂情况</p><p>短路求值的情况下，相当于多次分支判断。（练习题3.16）</p></li></ul><h4 id="2-基于数据的条件传送指令（Conditional-Moves）-2">2 基于数据的条件传送指令（Conditional Moves）</h4><p>使用JMP指令进行跳转的方式会存在控制流大量的跳转，对于现代处理器架构中的<strong>流水线</strong>来说，这是一个很大的性能瓶颈。为了去掉控制流的分支跳转，我们引入基于数据的条件传送，其基本逻辑如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">v = then-expr;<br>ve = <span class="hljs-keyword">else</span>-expr;<br>t = text-expr;<br><span class="hljs-keyword">if</span>(!t)                   <span class="hljs-comment">// 该部分条件传送由条件传送指令来实现</span><br>    v = ve;     <span class="hljs-comment">// 仅当符合条件时，才会进行值的传送</span><br><span class="hljs-keyword">return</span> v;<br></code></pre></td></tr></table></figure><h5 id="适用情况-2">适用情况</h5><p>条件传送的方式下，会对 then 与 else 两部分语句块提前计算出结果。这样做的方式使得：</p><ul class="lvl-0"><li class="lvl-2"><p>流水线无·需进行分支预测，更容易充满，效率更高；</p></li><li class="lvl-2"><p>不是所有的条件表达式都可以用条件传送来编译。很多情况下不能提前对结果进行计算。任一表达式如果可能产生错误条件或副作用（比如空指针的引用），都会导致非法的行为。</p></li><li class="lvl-2"><p>条件传送也不是总会提高代码的效率。如果两个分支语句块需要大量的计算，则流水线上的补偿也得不偿失。显然，编译器在做出判断时应该了解分支浪费的计算和分支预测错误的开销二者之间的大小关系，但实际很难有足够的信息做出正确的判断。实际应用中，通常只有两个表达式都很容易计算时，例如表达式分别都只是一条加法指令，它才会适用条件传送。根据经验来说，即使许多分支预测错误的开销是相对更大的，GCC也还是会使用条件控制转移（JMP指令）。总体来说，条件数据传送只能用于非常受限制的情况，但这些情况也是相当常见的，而且这种方式与现代处理器结构（流水线）更契合。</p></li></ul><h5 id="条件传送指令-2">条件传送指令</h5><p>条件传送（Conditional Moves）需要借助条件传送指令来实现，具体如下表：</p><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/202303061123873.png" style="zoom:33%;" /><p>普通的无条件传送指令MOV会将操作数的长短显式的编码在指令名中（<code>movl</code>, <code>movb</code>）。而条件传送指令不同，汇编器要从目标寄存器的名字来推断出操作数的实际长度，因此对所有的操作数长度，都可以使用同一个指令名。</p><p>源操作数和目的操作数可以是16位、32位或64位长，不支持单字节的条件传送。</p><h3 id="循环-while-for-2">循环 while &amp; for</h3><h4 id="do-while-2">do-while</h4><p>do-while loop至少会对循环体语句执行一次，比较容易实现，逻辑如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">do</span> &#123;<br>    body-statement<br>&#125; <span class="hljs-keyword">while</span> (text-expr);<br><br>loop:<br>body-statement<br>    t = text-expr;<br><span class="hljs-keyword">if</span> (t) <br>        <span class="hljs-keyword">goto</span> loop;<br></code></pre></td></tr></table></figure><h4 id="while-2">while</h4><p>while语句的区别在于，其需要先对 $text-expr$ 进行一次测试，如果首次测试就失败，则不会执行循环体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> (text-expr) <br>    body-statement<br></code></pre></td></tr></table></figure><p>实现while循环有两种方式：</p><ol><li class="lvl-3"><p>jump to middle</p><p>分别设置两个标号：loop 代表循环体内容，test 代表分支判断。其中 loop 在 test 前，第一句执行一个 goto 语句至 test 标号处执行第一次测试。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">goto</span> test<span class="hljs-comment">// 每次循环开始的 goto 跳转对流水线不友好</span><br>loop:<br>body-statement<br>test:<br>t = test-expr;<br><span class="hljs-keyword">if</span> (t) <br>        <span class="hljs-keyword">goto</span> loop;<br></code></pre></td></tr></table></figure><p>这种方式的弊端显而易见：每次循环必有一句分支跳转，对于流水线显然不友好。</p></li><li class="lvl-3"><p>guarded-do</p><p>第一次初始测试通过分支判断来实现，从而将while转换为do-while：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C">t = test-expr;<br><span class="hljs-keyword">if</span> (!t) <br>    <span class="hljs-keyword">goto</span> done; <br>loop:<br>body-statement<br>t = test-expr;<br><span class="hljs-keyword">if</span> (t) <br>        <span class="hljs-keyword">goto</span> loop;<br>done:<br></code></pre></td></tr></table></figure><p>两种不同翻译的区别取决于优化的等级，使用较高优化等级编译时，例如使用命令行选项<code>-O1</code>，GCC会采用这种策略。其减少了开始一定会有的<code>goto</code>控制流变化，更适合现代处理器中的流水线。</p></li></ol><h4 id="for-2">for</h4><p>通用逻辑形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (init-expr; test-expr; update-expr) <br>    body-statement<br></code></pre></td></tr></table></figure><p>这种逻辑形式可以转换为如下等效的while循环：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">init-expr;<br><span class="hljs-keyword">while</span> (test-expr) &#123;<br>    body-statement<br>    update-expr;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以，GCC会将 for 语句按照 while 循环的两种翻译形式产生对应代码。特殊的，如果 for 语句循环中存在<b> continue 语句</b>，则需要对代码进行适当修改，因为 update-expr 被放入了 while 循环的循环体，如果直接跳过循环，则意味着跳过 update-expr，导致进入死循环（Practice Problem 3.29）。应增加相应的 goto 语句与标签：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C">init-expr;<br><span class="hljs-keyword">while</span> (test-expr) &#123;<br>body-statement;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">continue</span>-test) &#123;<br><span class="hljs-keyword">goto</span> update;<span class="hljs-comment">// implement continue</span><br>&#125;<br>update:<br>update-expr;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="多重分支-switch-2">多重分支 switch</h3><p>多重分支从高级语言逻辑来说，可以写成多个条件分支，但这样意味着可读性的降低，多次跳转对编译后的性能也并不友好。</p><p>GCC引入了**跳转表（Jump Table）**来实现 switch 语句，其具体情况较复杂，不易抽象，详见书3.6.8节，结合实例理解。</p><h2 id="过程-Procedures-2">过程 Procedures</h2><p>要提供对过程机制的机器级支持，包括以下几个方面：</p><ul class="lvl-0"><li class="lvl-2"><p><b>传递控制 Passing control</b></p><p>通过PC（<code>%rip</code>）与运行时栈来实现控制转移，其实就是代码地址的存储与释放。</p></li><li class="lvl-2"><p><b>传递数据 Passing data</b></p><p>过程调用中需要传递参数，返回时也会有返回值。当寄存器空间足够时，通过寄存器传递即可（实际最多可以传6个参数），多出来的需要通过内存（运行时栈）来进行传递。</p></li><li class="lvl-2"><p><b>分配和释放内存 Allocating and deallocating memory</b></p><p>内存即指运行时栈，用于存放<b>被保存的寄存器值</b>、<b>局部变量</b>以及<b>寄存器中装不下的参数</b>。</p></li></ul><p>显然，三种机制都依赖于一个内存中的数据结构，即<strong>运行时栈（Run-Time Stack）</strong>。</p><h3 id="运行时栈-Run-Time-Stack-2">运行时栈 Run-Time Stack</h3><p>栈后进先出的特性，非常适合实现过程的调用。运行时栈的特点：</p><ul class="lvl-0"><li class="lvl-2"><p><b>内存</b>中的一块区域；</p></li><li class="lvl-2"><p>栈意味着后进先出，使用<code>push</code>和<code>pop</code>指令来操作栈空间；</p></li><li class="lvl-2"><p>向下增长，即低地址为栈顶；</p></li><li class="lvl-2"><p>栈顶位置由栈指针指明，其值位于<code>%rsp</code>寄存器中（stack pointer）；</p></li></ul><p>当x86-64过程需要的存储空间超过寄存器能够存放的大小时，就需要从栈上分配空间。为每个过程分配的空间成为过程的<i>栈帧（stack frame）</i>。栈帧常见内容如图，包括：</p><h4 id="返回地址-return-address-2">返回地址 return address</h4><p>当过程调用了其他过程，就需要保存返回地址，即为<code>callq</code>指令的下一条指令地址；</p><h4 id="参数-argument-2">参数 argument</h4><p>寄存器中至多能够传递6个参数（整数值），超出这个数量的参数（或者较大的容器如数组）就需要借助栈帧来传递；</p><h4 id="被保存的寄存器-saved-registers-2">被保存的寄存器 saved registers</h4><p>寄存器组时唯一被所有过程共享的资源。某些寄存器在函数调用时可能被覆盖，而其值后续会用到，需要保存。x86-64设置了一组统一的<b>寄存器使用惯例</b>，所有的过程都必须遵循。</p><p>根据惯例（前寄存器图片有标注），寄存器分为两种：<b>callee-saved（被调用者保存）</b>与<b>caller-saved（调用者保存）</b>。因为寄存器组是所有过程共享的空间，所以要确保内容的正确性。</p><ol><li class="lvl-3"><p><b>Callee-saved Registers</b></p><p>即被调用的函数需要保存的寄存器，包括：<code>%rbx</code>、<code>%rbp</code>和<code>%r12</code> ~ <code>%r15</code>。（共6个）被调用的函数要保证这些值在其结束并返回时与开始时保持一致。想要保证这些寄存器的值不变：</p><ul class="lvl-2"><li class="lvl-5"><p>不修改寄存器的值；</p></li><li class="lvl-5"><p>需要修改寄存器的情况时，将寄存器中的原始值压入栈中，并在返回前从栈中弹出旧值，恢复现场。栈帧中标注的“Saved Registers”即为该部分值。</p></li></ul><p>通常，这6个寄存器用于作为中介来存放临时变量，如果callee-saved寄存器用完，多余的需要借助栈的空间来存放。（Practice Problem 3.34）</p></li><li class="lvl-3"><p><b>Caller-saved Registers</b></p><p>除了<code>%rsp</code>之外的所有寄存器，都为调用者保存寄存器。即任何过程可以任意对这些寄存器进行修改，保存寄存器值的责任由调用者本身承担。</p></li></ol><h4 id="局部变量-local-variables-2">局部变量 local variables</h4><p>过程中创建的局部变量，在过程运行时创建，过程结束就会随着栈帧一起回收/销毁；对于局部变量，如果寄存器空间足够也会优先使用寄存器空间。在以下几种情况时，必须使用内存/栈来存放：</p><ul class="lvl-0"><li class="lvl-2"><p>寄存器不足以存放所有的本地数据；</p></li><li class="lvl-2"><p>涉及地址的变量空间，比如：</p><ul class="lvl-2"><li class="lvl-4">使用了地址运算符 <code>&amp;</code>；</li><li class="lvl-4">数组或者结构等涉及地址偏移量的数据，能够通过引用来访问。</li></ul></li></ul><p>在为局部变量分配栈帧时，过程首先减小栈指针（<code>subq $offset %rsp</code>）来在栈上分配空间。分配的结果作为栈帧的一部分，即为图中的“Local variables”部分。用后增大栈指针（<code>addq $offset %rsp</code>）恢复栈空间。</p><p>栈帧可能存放的内容大体上就这些，但实际情况中很多函数根本不需要栈帧，比如不超过6个整数大小参数的叶子过程（即不存在调用其他过程的过程）。也就是说，不存在调用，且寄存器够用的情况下，函数无需借助栈帧。</p><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/202303061127544.png" style="zoom:33%;" /><p>运行时帧作为内存的一部分，是实现过程的有利支撑，接下来关注实现过程的三个重要方面。</p><h3 id="控制传送-Control-Transfer-2">控制传送 Control Transfer</h3><p>转移控制的本质其实就是跳转到正确的代码位置，并在执行完子过程后返回正确的地址。这个过程会借助程序计数器PC（<code>%rip</code>寄存器）与运行时栈，使用如下两条指令完成：</p><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/202303061128044.png" style="zoom: 50%;" /><ul class="lvl-0"><li class="lvl-2"><p><code>call</code></p><ul class="lvl-2"><li class="lvl-4"><p><code>call Q</code>指令会把返回地址（紧跟在<code>call</code>指令后面的下一条指令）压入栈帧，并相应的调整<code>%rsp</code>的值。</p></li><li class="lvl-4"><p>然后程序跳转到 Q 指定的地址位置。</p><p>其中 Q 可以是直接访存，在汇编代码中就是一个标号（Label），也可以是间接访存，目标形式就是 <code>*</code> 号后面跟着操作数指示符。</p></li></ul></li><li class="lvl-2"><p><code>ret</code>：从栈帧中弹出返回地址，并将PC / <code>%rip</code> 的值设置为返回地址。</p></li></ul><h3 id="数据传送-Data-Transfer-2">数据传送 Data Transfer</h3><p>数据传送主要包括两部分：<b>参数</b>与<b>返回值</b>。返回值按照规定通常都由<code>%rax</code>传递。参数如前所述，6个整数以内由寄存器传递，多出的部分需要开辟（调用者的）栈帧来传递。</p><p>寄存器传递参数的规则如图所示：</p><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/202303061128851.png" style="zoom:50%;" /><p>栈传递参数的规则：</p><ul class="lvl-0"><li class="lvl-2"><p>参数的顺序见运行时栈部分的图片，通常来说，编号更小的参数位于栈顶（后进先出）；</p></li><li class="lvl-2"><p>所有的数据大小按8的倍数对齐（按字节寻址）；</p></li></ul><h3 id="递归过程-Recursive-Process-2">递归过程 Recursive Process</h3><p>没什么特别的，和普通函数调用基本一致。由于递归函数的参数形式都是一样的，caller要按需保存参数的值（参数寄存器均为 caller-saved），可能会占用 callee-saved register。</p><h2 id="数组">数组</h2><h3 id="基本原则-2">基本原则</h3><p>对于数据类型 T 与整型常数 N，定义：<code>T = A[N]</code>。该语句相当于以下几步工作：</p><ul class="lvl-0"><li class="lvl-2"><p>分配空间：在<b>内存</b>中分配一段 $L\times N$ 字节的<b>连续</b>空间。其中 $L$ 为数据类型 T 的大小；</p></li><li class="lvl-2"><p>初始地址：引入标识符 $A$，其值为指向数组开头的指针。通常将该指针值记作 $x_A$；</p></li><li class="lvl-2"><p>生成索引：通过整数索引 $0\sim N- 1$ 来访问数组中的元素。</p></li></ul><h3 id="访问与指针-2">访问与指针</h3><h4 id="指针运算">指针运算</h4><p>C语言中的指针运算会自动根据数据类型大小进行伸缩。即，对于数据类型 $T$，有一个指向该类型的指针 $p$，其中 $p$ 的具体值记为 $x_p$，那么 $p+ i$ 就相当于 $x_p + L \times i$。其中 $L$ 是该数据类型的大小。</p><h4 id="数组元素的访问-2">数组元素的访问</h4><p>通常，数组的起始地址存放在寄存器<code>%rdx</code>中，而索引则存放在<code>%rcx</code>中。可以利用内存引用指令来简化数组的访问，其具体实现如下表（假定结果都存放在<code>%rax</code>/<code>%eax</code>中）：</p><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/202303061128037.png" style="zoom: 33%;" /><h4 id="嵌套数组-多维数组的访问-2">嵌套数组 / 多维数组的访问</h4><p>与一维数组基本无差。以二维数组为例，对于数组<code>T D[R][C]</code>，其数组元素<code>D[i][j]</code>的地址为：$x_D + L(C\times i + j)$。较复杂的地址计算可能无法使用单句 <code>mov </code>指令来实现，可以利用 <code>lea</code> 指令进行地址的辅助计算。</p><h3 id="定长数组-2">定长数组</h3><p>对于定长数组，GCC能够对其操作进行性能上的优化。3.8.4节给出了在<code>O1</code>优化等级下的例子。</p><h3 id="变长数组-2">变长数组</h3><p>具体优化见3.8.5节。</p><h2 id="异质的数据结构-Heterogeneous-Data-Structures-2">异质的数据结构 Heterogeneous Data Structures</h2><h3 id="struct-2">struct</h3><ul class="lvl-0"><li class="lvl-2"><p>将不同类型的对象聚合到一个对象中；</p></li><li class="lvl-2"><p>访问与存储规则类似于数组：</p><ul class="lvl-2"><li class="lvl-4">所有的组成部分都放在内存中的一段<b>连续</b>区域内；</li><li class="lvl-4">指向结构的指针就是指向结构第一个字节的地址；</li><li class="lvl-4">不同成员的类型不同，意味着内存偏移量不同。编译器负责维护关于每个结构类型的信息，指示每个字段的字节偏移量，并以这些偏移量作为内存引用指令中的位移，从而产生对结构元素的引用。</li></ul></li></ul><h3 id="union-2">union</h3><ul class="lvl-0"><li class="lvl-2"><p>以多种类型来引用同一个对象。</p></li><li class="lvl-2"><p>union的用途：</p><ol><li class="lvl-5">按照不同的数据类型来解释同样的位模式；</li><li class="lvl-5">多个字段多选一时，可以使用union来节省空间。因为union的大小取决于其最大字段的大小。</li></ol></li></ul><p>详见3.9.2节。</p><h3 id="数据对齐-2">数据对齐</h3><ul class="lvl-0"><li class="lvl-2"><p>x86-64的对齐原则：任何$K$字节的基本对象的地址必须是$K$的倍数。</p></li><li class="lvl-2"><p>编译器在汇编代码中放入命令，指明全局数据所需的对齐，格式如下：</p><p><code>.align K</code>：代表后面的所有数据的起始地址必须是$K$的倍数。</p></li><li class="lvl-2"><p>强制对齐：特殊指令如SSE指令。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>15-213</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>15-213: Bomb Lab</title>
    <link href="/2023/02/14/15-213-bomb_lab/"/>
    <url>/2023/02/14/15-213-bomb_lab/</url>
    
    <content type="html"><![CDATA[<h1>Bomb Lab</h1><h2 id="题目-2">题目</h2><p>命令行中有几个阶段，每个阶段都要输入正确的字符串才能通过，否则炸弹就会爆炸。</p><p>观察<code>bomb.c</code>文件代码，发现每个阶段即为如下语句组成：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">input = read_line();<br>phase_1(input);<br>phase_defused();<br></code></pre></td></tr></table></figure><p>由上述代码可知，爆炸的具体操作在<code>phase_1</code>函数中实现。该函数为黑盒，无法解析其源代码文本，需要通过gdb来进行反汇编来获取其中的具体信息，从而得到正确答案。</p><h2 id="phase-1">phase_1</h2><p>首先，获得该函数反汇编内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) disas phase_1<br>Dump of assembler code for function phase_1:<br>   0x0000000000400ee0 &lt;+0&gt;:     sub    $0x8,%rsp<br>   0x0000000000400ee4 &lt;+4&gt;:     mov    $0x402400,%esi<br>   0x0000000000400ee9 &lt;+9&gt;:     callq  0x401338 &lt;strings_not_equal&gt;<br>   0x0000000000400eee &lt;+14&gt;:    test   %eax,%eax<br>   0x0000000000400ef0 &lt;+16&gt;:    je     0x400ef7 &lt;phase_1+23&gt;<br>   0x0000000000400ef2 &lt;+18&gt;:    callq  0x40143a &lt;explode_bomb&gt;<br>   0x0000000000400ef7 &lt;+23&gt;:    add    $0x8,%rsp<br>   0x0000000000400efb &lt;+27&gt;:    retq<br>End of assembler dump.<br></code></pre></td></tr></table></figure><p>根据上述代码可以得到：将立即数<code>0x402400</code>移入<code>%esi</code>，作为参数调用函数<code>strings_not_equal</code>。顾名思义该函数的返回值即为判断字符串是否等于答案，根据其返回值决定是否跳过第8行。据此可以判断，移入的参数为字符串的地址，故以字符串形式查看该内存处内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) x/sb 0x402400<br>0x402400:       &quot;Border relations with Canada have never been better.&quot;<br></code></pre></td></tr></table></figure><p>至此，获得答案。</p><p>拓展可以观察函数<code>strings_not_equal</code>的反汇编内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) disas strings_not_equal<br>Dump of assembler code for function strings_not_equal:<br>   0x0000000000401338 &lt;+0&gt;:     push   %r12<br>   0x000000000040133a &lt;+2&gt;:     push   %rbp<br>   0x000000000040133b &lt;+3&gt;:     push   %rbx<br>       # 以上为callee-saved寄存器备份<br>   0x000000000040133c &lt;+4&gt;:     mov    %rdi,%rbx<br>       # 第一个参数送入rbx<br>   0x000000000040133f &lt;+7&gt;:     mov    %rsi,%rbp<br>       # 第二个参数送入rbp<br>   0x0000000000401342 &lt;+10&gt;:    callq  0x40131b &lt;string_length&gt;<br>       # 顾名思义是求第一个参数字符串长度，此时rdi中仍为原始的第一个参数<br>   0x0000000000401347 &lt;+15&gt;:    mov    %eax,%r12d<br>   # 将计算返回值送入r12d<br>   0x000000000040134a &lt;+18&gt;:    mov    %rbp,%rdi<br>   # 将rbp中的第二个参数送入rdi作为参数<br>   0x000000000040134d &lt;+21&gt;:    callq  0x40131b &lt;string_length&gt;<br>   # 求第二个参数字符串的长度<br>   0x0000000000401352 &lt;+26&gt;:    mov    $0x1,%edx<br>     # 对应第99行，edx中的1被送入eax中作为返回值，代表长度不相等，匹配失败<br>   0x0000000000401357 &lt;+31&gt;:    cmp    %eax,%r12d<br>       # 比较两个字符串的长度<br>   0x000000000040135a &lt;+34&gt;:    jne    0x40139b &lt;strings_not_equal+99&gt;<br>       # 长度不等则直接跳转至第99行并返回1，代表not equal<br>   0x000000000040135c &lt;+36&gt;:    movzbl (%rbx),%eax<br>   0x000000000040135f &lt;+39&gt;:    test   %al,%al<br>   0x0000000000401361 &lt;+41&gt;:    je     0x401388 &lt;strings_not_equal+80&gt;<br>   0x0000000000401363 &lt;+43&gt;:    cmp    0x0(%rbp),%al<br>   0x0000000000401366 &lt;+46&gt;:    je     0x401372 &lt;strings_not_equal+58&gt;<br>   0x0000000000401368 &lt;+48&gt;:    jmp    0x40138f &lt;strings_not_equal+87&gt;<br>   0x000000000040136a &lt;+50&gt;:    cmp    0x0(%rbp),%al<br>   0x000000000040136d &lt;+53&gt;:    nopl   (%rax)<br>   0x0000000000401370 &lt;+56&gt;:    jne    0x401396 &lt;strings_not_equal+94&gt;<br>   0x0000000000401372 &lt;+58&gt;:    add    $0x1,%rbx<br>   0x0000000000401376 &lt;+62&gt;:    add    $0x1,%rbp<br>   0x000000000040137a &lt;+66&gt;:    movzbl (%rbx),%eax<br>   0x000000000040137d &lt;+69&gt;:    test   %al,%al<br>   0x000000000040137f &lt;+71&gt;:    jne    0x40136a &lt;strings_not_equal+50&gt;<br>   0x0000000000401381 &lt;+73&gt;:    mov    $0x0,%edx<br>   0x0000000000401386 &lt;+78&gt;:    jmp    0x40139b &lt;strings_not_equal+99&gt;<br>   0x0000000000401388 &lt;+80&gt;:    mov    $0x0,%edx<br>   0x000000000040138d &lt;+85&gt;:    jmp    0x40139b &lt;strings_not_equal+99&gt;<br>   0x000000000040138f &lt;+87&gt;:    mov    $0x1,%edx<br>   0x0000000000401394 &lt;+92&gt;:    jmp    0x40139b &lt;strings_not_equal+99&gt;<br>   0x0000000000401396 &lt;+94&gt;:    mov    $0x1,%edx<br>   0x000000000040139b &lt;+99&gt;:    mov    %edx,%eax<br>       # 以下为callee-saved寄存器还原<br>   0x000000000040139d &lt;+101&gt;:   pop    %rbx<br>   0x000000000040139e &lt;+102&gt;:   pop    %rbp<br>   0x000000000040139f &lt;+103&gt;:   pop    %r12<br>   0x00000000004013a1 &lt;+105&gt;:   retq<br>End of assembler dump.<br></code></pre></td></tr></table></figure><h2 id="phase-2">phase_2</h2><p>反汇编该函数内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) disas phase_2<br>Dump of assembler code for function phase_2:<br>   0x0000000000400efc &lt;+0&gt;:     push   %rbp<br>   0x0000000000400efd &lt;+1&gt;:     push   %rbx<br>   0x0000000000400efe &lt;+2&gt;:     sub    $0x28,%rsp<br>   0x0000000000400f02 &lt;+6&gt;:     mov    %rsp,%rsi<br>   0x0000000000400f05 &lt;+9&gt;:     callq  0x40145c &lt;read_six_numbers&gt;<br>   0x0000000000400f0a &lt;+14&gt;:    cmpl   $0x1,(%rsp)<br>   0x0000000000400f0e &lt;+18&gt;:    je     0x400f30 &lt;phase_2+52&gt;<br>   0x0000000000400f10 &lt;+20&gt;:    callq  0x40143a &lt;explode_bomb&gt;<br>   0x0000000000400f15 &lt;+25&gt;:    jmp    0x400f30 &lt;phase_2+52&gt;<br>   0x0000000000400f17 &lt;+27&gt;:    mov    -0x4(%rbx),%eax<br>   0x0000000000400f1a &lt;+30&gt;:    add    %eax,%eax<br>   0x0000000000400f1c &lt;+32&gt;:    cmp    %eax,(%rbx)<br>   0x0000000000400f1e &lt;+34&gt;:    je     0x400f25 &lt;phase_2+41&gt;<br>   0x0000000000400f20 &lt;+36&gt;:    callq  0x40143a &lt;explode_bomb&gt;<br>   0x0000000000400f25 &lt;+41&gt;:    add    $0x4,%rbx<br>   0x0000000000400f29 &lt;+45&gt;:    cmp    %rbp,%rbx<br>   0x0000000000400f2c &lt;+48&gt;:    jne    0x400f17 &lt;phase_2+27&gt;<br>   0x0000000000400f2e &lt;+50&gt;:    jmp    0x400f3c &lt;phase_2+64&gt;<br>   0x0000000000400f30 &lt;+52&gt;:    lea    0x4(%rsp),%rbx<br>   0x0000000000400f35 &lt;+57&gt;:    lea    0x18(%rsp),%rbp<br>   0x0000000000400f3a &lt;+62&gt;:    jmp    0x400f17 &lt;phase_2+27&gt;<br>   0x0000000000400f3c &lt;+64&gt;:    add    $0x28,%rsp<br>   0x0000000000400f40 &lt;+68&gt;:    pop    %rbx<br>   0x0000000000400f41 &lt;+69&gt;:    pop    %rbp<br>   0x0000000000400f42 &lt;+70&gt;:    retq<br>End of assembler dump.<br></code></pre></td></tr></table></figure><p>依次进行解析：</p><h3 id="1-准备进入函数">1 准备进入函数</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">0x0000000000400efc &lt;+0&gt;:     push   %rbp                            # callee-saved<br>0x0000000000400efd &lt;+1&gt;:     push   %rbx   # callee-saved<br>0x0000000000400efe &lt;+2&gt;:     sub    $0x28,%rsp               <br>    # 分配栈帧 5*8：<br>    # 两个callee-saved以及三个机器字存放6个32位int值（见后可知）<br>0x0000000000400f02 &lt;+6&gt;:     mov    %rsp,%rsi   <br>    # rsp作为第二个参数传递给函数，以便使用lea生成变量地址<br>0x0000000000400f05 &lt;+9&gt;:     callq  0x40145c &lt;read_six_numbers&gt;     # 进入函数<br></code></pre></td></tr></table></figure><p>分配了5个机器字大小的栈帧，此时栈帧情况如图所示：</p><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/202303061115032.png" style="zoom:33%;" /><p>至此发现，爆炸与<code>read_six_numbers</code>函数执行有关，所以对其反汇编输出，分析该函数内容：</p><h3 id="2-read-six-numbers">2 read_six_numbers</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) disas read_six_numbers<br>Dump of assembler code for function read_six_numbers:<br>   0x000000000040145c &lt;+0&gt;:     sub    $0x18,%rsp<br>       # 分配栈帧<br>   0x0000000000401460 &lt;+4&gt;:     mov    %rsi,%rdx<br>       # 参数3：rsi中存放的栈地址入rdx，我们在这里标注其指向的数据为 x1 <br>   0x0000000000401463 &lt;+7&gt;:     lea    0x4(%rsi),%rcx<br>       # 参数4：rsi + 4, 即 x2 送入rcx<br>   0x0000000000401467 &lt;+11&gt;:    lea    0x14(%rsi),%rax<br>   0x000000000040146b &lt;+15&gt;:    mov    %rax,0x8(%rsp)<br>       # 参数8：%rax作为中继，rsi + 20 送入栈中 rsp + 8 处，借助栈传参<br>       # 即 x6 存放在栈中 rsp + 8 处传递<br>   0x0000000000401470 &lt;+20&gt;:    lea    0x10(%rsi),%rax<br>   0x0000000000401474 &lt;+24&gt;:    mov    %rax,(%rsp)<br>       # 参数7：rsi + 16 送入栈中 rsp 处，借助栈传参<br>       #       即 x5 存放在栈中 rsp 处传递<br>   0x0000000000401478 &lt;+28&gt;:    lea    0xc(%rsi),%r9<br>       # 参数6：rsp + 12 送入r9<br>   0x000000000040147c &lt;+32&gt;:    lea    0x8(%rsi),%r8<br>       # 参数5：rsp + 8 送入r8<br>   0x0000000000401480 &lt;+36&gt;:    mov    $0x4025c3,%esi<br>       # 参数2：0x4025c3以字符串形式输出即为“%d %d %d %d %d %d”<br>       # 至此推测scanf的参数1显然为输入内容<br>   0x0000000000401485 &lt;+41&gt;:    mov    $0x0,%eax<br>   0x000000000040148a &lt;+46&gt;:    callq  0x400bf0 &lt;__isoc99_sscanf@plt&gt;<br>       # scanf的返回值代表正确读入参数的个数<br>   0x000000000040148f &lt;+51&gt;:    cmp    $0x5,%eax<br>   0x0000000000401492 &lt;+54&gt;:    jg     0x401499 &lt;read_six_numbers+61&gt;<br>       # 如果正确读入的参数个数为6，即大于5，则跳过explode<br>   0x0000000000401494 &lt;+56&gt;:    callq  0x40143a &lt;explode_bomb&gt;<br>   0x0000000000401499 &lt;+61&gt;:    add    $0x18,%rsp<br>   0x000000000040149d &lt;+65&gt;:    retq<br>End of assembler dump.<br></code></pre></td></tr></table></figure><p>执行<code>scanf</code>前，为其准备参数，如下：</p><table><thead><tr><th style="text-align:center">rdi</th><th style="text-align:center">rsi</th><th style="text-align:center">rdx</th><th style="text-align:center">rcx</th><th style="text-align:center">r8</th><th style="text-align:center">r9</th><th style="text-align:center">%rsp+16</th><th style="text-align:center">%rsp+20</th></tr></thead><tbody><tr><td style="text-align:center">char*</td><td style="text-align:center"><code>%d %d %d %d %d %d</code></td><td style="text-align:center">%rsp</td><td style="text-align:center">%rsp+4</td><td style="text-align:center">%rsp+8</td><td style="text-align:center">%rsp+12</td><td style="text-align:center">%rsp+16</td><td style="text-align:center">%rsp+20</td></tr><tr><td style="text-align:center">arg1</td><td style="text-align:center">arg2: 0x4025c3</td><td style="text-align:center">arg3: &amp;x1</td><td style="text-align:center">arg4: &amp;x2</td><td style="text-align:center">arg5: &amp;x3</td><td style="text-align:center">arg6: &amp;x4</td><td style="text-align:center">arg7: &amp;x5</td><td style="text-align:center">arg8: &amp;x6</td></tr></tbody></table><p>共8个参数，其中前6个通过寄存器传递，后2个通过栈传递：</p><ul class="lvl-0"><li class="lvl-2"><p>第一个参数为输入流，代码中无需显式给出；</p></li><li class="lvl-2"><p>结合<code>scanf</code>本身的语法，6个待赋值的整数值的地址即为后6个参数。这里使用lea指令来计算得到其在栈中的地址。</p></li></ul><p>此时的系统栈情况如下：</p><p><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/202303061116203.png" alt=""></p><p>至此，说明至少要读取6个整数，否则在<code>read_six_numbers</code>内就会爆炸。</p><h3 id="3-对结果的第一个要求">3 对结果的第一个要求</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">0x0000000000400f05 &lt;+9&gt;:     callq  0x40145c &lt;read_six_numbers&gt;<br>0x0000000000400f0a &lt;+14&gt;:    cmpl   $0x1,(%rsp)<br>0x0000000000400f0e &lt;+18&gt;:    je     0x400f30 &lt;phase_2+52&gt;<br>0x0000000000400f10 &lt;+20&gt;:    callq  0x40143a &lt;explode_bomb&gt;<br></code></pre></td></tr></table></figure><p>此时，从<code>read_six_numbers</code>出返回后，6个整数均已赋值完毕，栈中情况如图所示：</p><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/202303061116842.png" style="zoom:33%;" /><p>结合代码，发现<strong>第一个变量 $x1$ 的值必须为1</strong>，才能跳过explode。</p><h3 id="4-第一次跳转">4 第一次跳转</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">   0x0000000000400f30 &lt;+52&gt;:    lea    0x4(%rsp),%rbx<br>   0x0000000000400f35 &lt;+57&gt;:    lea    0x18(%rsp),%rbp<br>       # rsp + 24 为phase_2栈帧图中指向保存的%rbx部分<br>       # 显然是作为后续循环的终止条件<br>   0x0000000000400f3a &lt;+62&gt;:    jmp    0x400f17 &lt;phase_2+27&gt;<br>   ...<br>跳转后：<br>   0x0000000000400f17 &lt;+27&gt;:    mov    -0x4(%rbx),%eax<br>       # rsp指向的栈顶处的 x1 送入 eax<br>   0x0000000000400f1a &lt;+30&gt;:    add    %eax,%eax<br>       # x1 *= 2<br>   0x0000000000400f1c &lt;+32&gt;:    cmp    %eax,(%rbx)<br>       # x1 * 2 与 rsp + 4处的 x2 进行比较<br>   0x0000000000400f1e &lt;+34&gt;:    je     0x400f25 &lt;phase_2+41&gt;<br>       # 相等则跳转，跳过explode<br>   0x0000000000400f20 &lt;+36&gt;:    callq  0x40143a &lt;explode_bomb&gt;<br></code></pre></td></tr></table></figure><p>根据该部分可得，<strong>要求 $x2 = 2 \times x1$</strong> ，否则explode。</p><h3 id="5-进入循环">5 进入循环</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">   0x0000000000400f25 &lt;+41&gt;:    add    $0x4,%rbx<br>       # rbx 指向下一个参数<br>   0x0000000000400f29 &lt;+45&gt;:    cmp    %rbp,%rbx<br>       # 判断停止循环的条件：指向 rsp + 24 处<br>   0x0000000000400f2c &lt;+48&gt;:    jne    0x400f17 &lt;phase_2+27&gt;<br>       # 进入循环<br>   0x0000000000400f2e &lt;+50&gt;:    jmp    0x400f3c &lt;phase_2+64&gt;<br>       # 循环结束后直接跳转至收尾工作<br>   ...<br>跳转后：<br>       # 释放栈帧，恢复callee-saved寄存器，收尾工作，即退出循环<br>   0x0000000000400f3c &lt;+64&gt;:    add    $0x28,%rsp<br>   0x0000000000400f40 &lt;+68&gt;:    pop    %rbx<br>   0x0000000000400f41 &lt;+69&gt;:    pop    %rbp<br>   0x0000000000400f42 &lt;+70&gt;:    retq<br></code></pre></td></tr></table></figure><p>回到27说明进入了循环。且不断指向下一个参数，说明对输入值的要求为：<strong>$x_{n} = 2 \times x_{n - 1}$</strong>。</p><p>至此得到结果，即：</p><ol><li class="lvl-3"><p>需要输入6个整数，根据大小来判断，应该为32位<code>int</code>/<code>unsigned</code>类型；</p></li><li class="lvl-3"><p>$x1 = 1$；</p></li><li class="lvl-3"><p>$x_{n} = 2 \times x_{n - 1}$</p></li></ol><p>故，最终答案为：<code>1 2 4 8 16 32</code>。</p><h2 id="phase-3">phase_3</h2><blockquote><p>关键词：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) disas phase_3<br>Dump of assembler code for function phase_3:<br>   0x0000000000400f43 &lt;+0&gt;:     sub    $0x18,%rsp<br>       # allocate stack frame<br>   0x0000000000400f47 &lt;+4&gt;:     lea    0xc(%rsp),%rcx<br>   0x0000000000400f4c &lt;+9&gt;:     lea    0x8(%rsp),%rdx<br>       # 栈中开辟的两个局部变量<br>       # 命名为x2(rsp + 0xc)，x1(rsp + 0x8)<br>   0x0000000000400f51 &lt;+14&gt;:    mov    $0x4025cf,%esi<br>       # 0x4025cf：&quot;%d %d&quot;<br>       # scanf的2-4号参数<br>   0x0000000000400f56 &lt;+19&gt;:    mov    $0x0,%eax<br>   0x0000000000400f5b &lt;+24&gt;:    callq  0x400bf0 &lt;__isoc99_sscanf@plt&gt;<br>   0x0000000000400f60 &lt;+29&gt;:    cmp    $0x1,%eax<br>   0x0000000000400f63 &lt;+32&gt;:    jg     0x400f6a &lt;phase_3+39&gt;<br>       # 正确读取了两个参数，否则explode<br>   0x0000000000400f65 &lt;+34&gt;:    callq  0x40143a &lt;explode_bomb&gt;<br>   0x0000000000400f6a &lt;+39&gt;:    cmpl   $0x7,0x8(%rsp)<br>   0x0000000000400f6f &lt;+44&gt;:    ja     0x400fad &lt;phase_3+106&gt;<br>       # if x1 &gt; 7 goto explode<br>       # ja(above) indicates unsigned<br>       # unsigned x1 &lt;= 7<br>   0x0000000000400f71 &lt;+46&gt;:    mov    0x8(%rsp),%eax<br>       # x1 送入 eax<br>   0x0000000000400f75 &lt;+50&gt;:    jmpq   *0x402470(,%rax,8)<br>       # base: 0x402470<br>       # 直接跳转至(base + 8 * x2)<br>       <br>   0x0000000000400f7c &lt;+57&gt;:    mov    $0xcf,%eax<br>   0x0000000000400f81 &lt;+62&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;<br>       # base + 0 (0 207)<br>       <br>   0x0000000000400f83 &lt;+64&gt;:    mov    $0x2c3,%eax<br>   0x0000000000400f88 &lt;+69&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;<br>       # base + 2 (2 707)<br>       <br>   0x0000000000400f8a &lt;+71&gt;:    mov    $0x100,%eax<br>   0x0000000000400f8f &lt;+76&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;<br>       # base + 3 (3 256)<br>   <br>   0x0000000000400f91 &lt;+78&gt;:    mov    $0x185,%eax<br>   0x0000000000400f96 &lt;+83&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;<br>       # base + 4 (4 389)<br>       <br>   0x0000000000400f98 &lt;+85&gt;:    mov    $0xce,%eax<br>   0x0000000000400f9d &lt;+90&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;<br>       # base + 5 (5 206)<br>     <br>   0x0000000000400f9f &lt;+92&gt;:    mov    $0x2aa,%eax<br>   0x0000000000400fa4 &lt;+97&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;<br>       # base + 6 (6 682)<br>       <br>   0x0000000000400fa6 &lt;+99&gt;:    mov    $0x147,%eax<br>   0x0000000000400fab &lt;+104&gt;:   jmp    0x400fbe &lt;phase_3+123&gt;<br>       # base + 7 (7 327)<br>       <br>   0x0000000000400fad &lt;+106&gt;:   callq  0x40143a &lt;explode_bomb&gt;<br>       <br>   0x0000000000400fb2 &lt;+111&gt;:   mov    $0x0,%eax<br>   0x0000000000400fb7 &lt;+116&gt;:   jmp    0x400fbe &lt;phase_3+123&gt;<br>       <br>   0x0000000000400fb9 &lt;+118&gt;:   mov    $0x137,%eax<br>   # base + 1 (1 311)<br>       <br>   0x0000000000400fbe &lt;+123&gt;:   cmp    0xc(%rsp),%eax<br>   0x0000000000400fc2 &lt;+127&gt;:   je     0x400fc9 &lt;phase_3+134&gt;<br>       # if x2 != eax goto explode<br>   0x0000000000400fc4 &lt;+129&gt;:   callq  0x40143a &lt;explode_bomb&gt;<br>   0x0000000000400fc9 &lt;+134&gt;:   add    $0x18,%rsp<br>   0x0000000000400fcd &lt;+138&gt;:   retq<br>End of assembler dump.<br></code></pre></td></tr></table></figure><p>比较简单。整体逻辑如下：</p><ul class="lvl-0"><li class="lvl-2"><p>通过<code>scanf</code>的参数分析可得，输入为两个整数，暂且命名为 $x1$ 与 $x2$；</p></li><li class="lvl-2"><p>第一个参数要求：$x1 &lt;= 7$；且 $x1$ 应为无符号整数；</p></li><li class="lvl-2"><p>根据 $x1$ 的数值进行跳转，根据值的范围，跳转的范围共有8个，分别为0 - 7；</p></li><li class="lvl-2"><p>每个跳转的语句都是传某个值进入<code>eax</code>寄存器，并测试其值是否与 $r2$ 相等，故答案即为这8对无符号整数。</p></li></ul><h2 id="phase-4">phase_4</h2><blockquote><p>关键词：递归。要将汇编的逻辑精简成高级语言才方便理解。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) disas phase_4<br>Dump of assembler code for function phase_4:<br>   0x000000000040100c &lt;+0&gt;:     sub    $0x18,%rsp<br>       # allocate stack frame<br>   0x0000000000401010 &lt;+4&gt;:     lea    0xc(%rsp),%rcx<br>   0x0000000000401015 &lt;+9&gt;:     lea    0x8(%rsp),%rdx<br>   0x000000000040101a &lt;+14&gt;:    mov    $0x4025cf,%esi<br>   0x000000000040101f &lt;+19&gt;:    mov    $0x0,%eax<br>   0x0000000000401024 &lt;+24&gt;:    callq  0x400bf0 &lt;__isoc99_sscanf@plt&gt;<br>   0x0000000000401029 &lt;+29&gt;:    cmp    $0x2,%eax<br>   0x000000000040102c &lt;+32&gt;:    jne    0x401035 &lt;phase_4+41&gt;<br>       # 老套路：scanf 获取2个整数 x1(rsp + 0x8), x2(rsp + 0xc)<br>   0x000000000040102e &lt;+34&gt;:    cmpl   $0xe,0x8(%rsp)<br>   0x0000000000401033 &lt;+39&gt;:    jbe    0x40103a &lt;phase_4+46&gt;<br>       # if x1 &gt;= 14 goto explode<br>   0x0000000000401035 &lt;+41&gt;:    callq  0x40143a &lt;explode_bomb&gt;<br>   0x000000000040103a &lt;+46&gt;:    mov    $0xe,%edx<br>       # 14 作为函数第3个参数<br>   0x000000000040103f &lt;+51&gt;:    mov    $0x0,%esi<br>       # 0 作为函数第2个参数<br>   0x0000000000401044 &lt;+56&gt;:    mov    0x8(%rsp),%edi<br>       # x1 作为函数第1个参数<br>   0x0000000000401048 &lt;+60&gt;:    callq  0x400fce &lt;func4&gt;<br>       # func4(x1, 0, 14)<br>       <br>   0x000000000040104d &lt;+65&gt;:    test   %eax,%eax<br>   0x000000000040104f &lt;+67&gt;:    jne    0x401058 &lt;phase_4+76&gt;<br>       # if return_val != 0 goto explode<br>   0x0000000000401051 &lt;+69&gt;:    cmpl   $0x0,0xc(%rsp)<br>   0x0000000000401056 &lt;+74&gt;:    je     0x40105d &lt;phase_4+81&gt;<br>       # if x2 != 0 goto explode<br>   0x0000000000401058 &lt;+76&gt;:    callq  0x40143a &lt;explode_bomb&gt;<br>   0x000000000040105d &lt;+81&gt;:    add    $0x18,%rsp<br>   0x0000000000401061 &lt;+85&gt;:    retq<br>End of assembler dump.<br></code></pre></td></tr></table></figure><p>根据上述注释解析，可以获得：</p><ul class="lvl-0"><li class="lvl-2"><p>根据第&lt;+69&gt; - &lt;+74&gt;条指令可得：$x2 = 0$；</p></li><li class="lvl-2"><p>需要进一步分析 <code>func4</code> 函数，要求其返回值必须为0。</p></li></ul><p><code>func4</code>的反汇编结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) disas func4<br><span class="hljs-meta prompt_"># </span><span class="language-bash">func4(x1, 0, 14)</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">x1 <span class="hljs-keyword">in</span> %rdi, 0 <span class="hljs-keyword">in</span> %rsi, 14 <span class="hljs-keyword">in</span> %rdx</span><br>Dump of assembler code for function func4:<br>   0x0000000000400fce &lt;+0&gt;:     sub    $0x8,%rsp<br>       # allocate stack frame<br>   0x0000000000400fd2 &lt;+4&gt;:     mov    %edx,%eax<br>   0x0000000000400fd4 &lt;+6&gt;:     sub    %esi,%eax<br>   0x0000000000400fd6 &lt;+8&gt;:     mov    %eax,%ecx<br>   0x0000000000400fd8 &lt;+10&gt;:    shr    $0x1f,%ecx<br>   0x0000000000400fdb &lt;+13&gt;:    add    %ecx,%eax<br>   0x0000000000400fdd &lt;+15&gt;:    sar    %eax<br>       # 算术右移，但无参数，相当于右移1位 <br>   0x0000000000400fdf &lt;+17&gt;:    lea    (%rax,%rsi,1),%ecx<br>       <br>   0x0000000000400fe2 &lt;+20&gt;:    cmp    %edi,%ecx<br>   0x0000000000400fe4 &lt;+22&gt;:    jle    0x400ff2 &lt;func4+36&gt;<br>   0x0000000000400fe6 &lt;+24&gt;:    lea    -0x1(%rcx),%edx<br>   0x0000000000400fe9 &lt;+27&gt;:    callq  0x400fce &lt;func4&gt;<br>  <br>   0x0000000000400fee &lt;+32&gt;:    add    %eax,%eax<br>   0x0000000000400ff0 &lt;+34&gt;:    jmp    0x401007 &lt;func4+57&gt;<br>       <br>   0x0000000000400ff2 &lt;+36&gt;:    mov    $0x0,%eax<br>   0x0000000000400ff7 &lt;+41&gt;:    cmp    %edi,%ecx<br>   0x0000000000400ff9 &lt;+43&gt;:    jge    0x401007 &lt;func4+57&gt;<br>   0x0000000000400ffb &lt;+45&gt;:    lea    0x1(%rcx),%esi<br>   0x0000000000400ffe &lt;+48&gt;:    callq  0x400fce &lt;func4&gt;<br>   0x0000000000401003 &lt;+53&gt;:    lea    0x1(%rax,%rax,1),%eax<br>       <br>   0x0000000000401007 &lt;+57&gt;:    add    $0x8,%rsp<br>   0x000000000040100b &lt;+61&gt;:    retq<br>End of assembler dump.<br></code></pre></td></tr></table></figure><p>根据反汇编结果可得，<code>func4</code>为一个递归函数，精简其逻辑如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta"># recursive function</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">func4</span><span class="hljs-params">(<span class="hljs-type">int</span> rdi, <span class="hljs-type">int</span> rsi, <span class="hljs-type">int</span> rdx)</span> &#123;<br>    # &lt;+<span class="hljs-number">4</span>&gt; - &lt;+<span class="hljs-number">17</span>&gt;<br>    <span class="hljs-type">int</span> rax = (rdx - rsi + ((rdx - rsi) &gt;&gt; <span class="hljs-number">31</span>)) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> rcx = (rdx - rsi + ((rdx - rsi) &gt;&gt; <span class="hljs-number">31</span>)) &gt;&gt; <span class="hljs-number">1</span> + rsi;<br>    <br>    # &lt;+<span class="hljs-number">20</span>&gt; - &lt;+<span class="hljs-number">53</span>&gt;<br>    <span class="hljs-keyword">if</span>(rcx &lt; rdi) &#123;                                  # &lt;+<span class="hljs-number">20</span>&gt; - &lt;+<span class="hljs-number">22</span>&gt;<br>        <span class="hljs-meta"># rsi = rcx + 1;                               <span class="hljs-string">&lt;+45&gt;</span></span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * func4(rdi, rcx + <span class="hljs-number">1</span>, rdx) + <span class="hljs-number">1</span>; # &lt;+<span class="hljs-number">48</span>&gt;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(rdi &lt; rcx) &#123; <br>        <span class="hljs-meta"># rdx = rcx - 1;                        <span class="hljs-string">&lt;+24&gt;</span></span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * func4(rdi, rsi, rcx - <span class="hljs-number">1</span>);         # &lt;+<span class="hljs-number">27</span>&gt;<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-meta"># rdi == rcx                              <span class="hljs-string">&lt;+43&gt;</span></span><br>        <span class="hljs-meta"># rax = 0                                      <span class="hljs-string">&lt;+36&gt;</span></span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>初始参数情况为：<code>func4(x1, 0, 14)</code>，将其带入计算可得<code>rax = rcx = 7</code>，那么只需让 $x1 = 7$ 即可，当然其他满足要求的数字也可以，但没必要。</p><p>最终答案为 <code>7 0</code>。</p><h2 id="phase-5">phase_5</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) disas phase_5<br>Dump of assembler code for function phase_5:<br>   0x0000000000401062 &lt;+0&gt;:     push   %rbx<br>       # callee-saved<br>   0x0000000000401063 &lt;+1&gt;:     sub    $0x20,%rsp<br>       # allocate stack frame<br>   0x0000000000401067 &lt;+5&gt;:     mov    %rdi,%rbx<br>       # 输入送入rbx<br>   0x000000000040106a &lt;+8&gt;:     mov    %fs:0x28,%rax<br>   0x0000000000401073 &lt;+17&gt;:    mov    %rax,0x18(%rsp)<br>       # canary: 存在局部char数组，可能有缓冲区溢出风险<br>   0x0000000000401078 &lt;+22&gt;:    xor    %eax,%eax<br>       # eax 清零<br>   0x000000000040107a &lt;+24&gt;:    callq  0x40131b &lt;string_length&gt;<br>   0x000000000040107f &lt;+29&gt;:    cmp    $0x6,%eax<br>   0x0000000000401082 &lt;+32&gt;:    je     0x4010d2 &lt;phase_5+112&gt;<br>       # 输入字符串长度必须为6: 6位16进制地址？<br>   0x0000000000401084 &lt;+34&gt;:    callq  0x40143a &lt;explode_bomb&gt;<br>   0x0000000000401089 &lt;+39&gt;:    jmp    0x4010d2 &lt;phase_5+112&gt;<br>       <br>       # input in %rbx<br>       # for (rax from 0 to 6)<br>   0x000000000040108b &lt;+41&gt;:    movzbl (%rbx,%rax,1),%ecx<br>       # 8位-32位<br>       # %rax 疑似数组偏移量<br>   0x000000000040108f &lt;+45&gt;:    mov    %cl,(%rsp)<br>   0x0000000000401092 &lt;+48&gt;:    mov    (%rsp),%rdx<br>       # 低8位送入rdx<br>   0x0000000000401096 &lt;+52&gt;:    and    $0xf,%edx<br>       # 仅保留低4位二进制位<br>     <br>       # rbx + rax -&gt; rcx -&gt; (%rsp) -&gt; %rdx (仅保留低四位)<br>   0x0000000000401099 &lt;+55&gt;:    movzbl 0x4024b0(%rdx),%edx<br>   0x00000000004010a0 &lt;+62&gt;:    mov    %dl,0x10(%rsp,%rax,1)<br>       <br>   0x00000000004010a4 &lt;+66&gt;:    add    $0x1,%rax# rax++<br>   0x00000000004010a8 &lt;+70&gt;:    cmp    $0x6,%rax# rax &lt; 6<br>   0x00000000004010ac &lt;+74&gt;:    jne    0x40108b &lt;phase_5+41&gt;<br># 循环终止<br>       <br>   0x00000000004010ae &lt;+76&gt;:    movb   $0x0,0x16(%rsp)<br>       # 高2bytes置零，低6bytes保留<br>   0x00000000004010b3 &lt;+81&gt;:    mov    $0x40245e,%esi<br>       # 字符串内容为 flyers<br>   0x00000000004010b8 &lt;+86&gt;:    lea    0x10(%rsp),%rdi<br>   0x00000000004010bd &lt;+91&gt;:    callq  0x401338 &lt;strings_not_equal&gt;<br>   0x00000000004010c2 &lt;+96&gt;:    test   %eax,%eax<br>   0x00000000004010c4 &lt;+98&gt;:    je     0x4010d9 &lt;phase_5+119&gt;<br>   0x00000000004010c6 &lt;+100&gt;:   callq  0x40143a &lt;explode_bomb&gt;<br>       <br>   0x00000000004010cb &lt;+105&gt;:   nopl   0x0(%rax,%rax,1)<br>   0x00000000004010d0 &lt;+110&gt;:   jmp    0x4010d9 &lt;phase_5+119&gt;<br>       <br>   0x00000000004010d2 &lt;+112&gt;:   mov    $0x0,%eax<br>       # eax 清零，在循环中作为偏移量<br>   0x00000000004010d7 &lt;+117&gt;:   jmp    0x40108b &lt;phase_5+41&gt;<br>      <br>           # 检查canary<br>   0x00000000004010d9 &lt;+119&gt;:   mov    0x18(%rsp),%rax<br>   0x00000000004010de &lt;+124&gt;:   xor    %fs:0x28,%rax<br>   0x00000000004010e7 &lt;+133&gt;:   je     0x4010ee &lt;phase_5+140&gt;<br>   0x00000000004010e9 &lt;+135&gt;:   callq  0x400b30 &lt;__stack_chk_fail@plt&gt;<br>       # deallocate stack frame<br>   0x00000000004010ee &lt;+140&gt;:   add    $0x20,%rsp<br>   0x00000000004010f2 &lt;+144&gt;:   pop    %rbx<br>   0x00000000004010f3 &lt;+145&gt;:   retq<br>End of assembler dump.<br></code></pre></td></tr></table></figure><p>分步讨论：</p><h3 id="part-1">part 1</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">0x0000000000401062 &lt;+0&gt;:     push   %rbx<br>    # callee-saved<br>0x0000000000401063 &lt;+1&gt;:     sub    $0x20,%rsp<br>    # allocate stack frame<br>0x0000000000401067 &lt;+5&gt;:     mov    %rdi,%rbx<br>    # 输入送入rbx<br>0x000000000040106a &lt;+8&gt;:     mov    %fs:0x28,%rax<br>0x0000000000401073 &lt;+17&gt;:    mov    %rax,0x18(%rsp)<br>    # canary: 存在局部char数组，可能有缓冲区溢出风险<br>0x0000000000401078 &lt;+22&gt;:    xor    %eax,%eax<br>    # eax 清零<br></code></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>基操：分配栈帧 + 备份callee-saved reg</p></li><li class="lvl-2"><p>存在canary：说明存在局部的字符数组，有缓冲区溢出的风险；</p><p>这里我们假设字符数组为<code>char str[]</code>；</p></li><li class="lvl-2"><p><code>$rbx</code>中存放了输入的字符串，此时还无法判断其内容为什么类型。</p><p>这里我们假设输入的数组为<code>char input[]</code>；</p></li></ul><h3 id="part-2">part 2</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">   0x000000000040107a &lt;+24&gt;:    callq  0x40131b &lt;string_length&gt;<br>   0x000000000040107f &lt;+29&gt;:    cmp    $0x6,%eax<br>   0x0000000000401082 &lt;+32&gt;:    je     0x4010d2 &lt;phase_5+112&gt;<br>       # 输入字符串长度必须为6<br>   0x0000000000401084 &lt;+34&gt;:    callq  0x40143a &lt;explode_bomb&gt;<br>   0x0000000000401089 &lt;+39&gt;:    jmp    0x4010d2 &lt;phase_5+112&gt;<br>...<br>   0x00000000004010d2 &lt;+112&gt;:   mov    $0x0,%eax<br>       # eax 清零，在循环中作为偏移量<br>   0x00000000004010d7 &lt;+117&gt;:   jmp    0x40108b &lt;phase_5+41&gt;<br></code></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>输入字符串长度必须为6；</p></li><li class="lvl-2"><p>清零<code>$eax</code>后进入循环。</p></li></ul><h3 id="part-3：循环">part 3：循环</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">    # input in $rbx, i in $rax<br>    # for: i from 0 to 6<br>0x000000000040108b &lt;+41&gt;:    movzbl (%rbx,%rax,1),%ecx# input + i -&gt; ecx (32)<br>    # 8位-32位<br>0x000000000040108f &lt;+45&gt;:    mov    %cl,(%rsp)# cl -&gt; (%rsp) (8)<br>0x0000000000401092 &lt;+48&gt;:    mov    (%rsp),%rdx# (%rsp) -&gt; rdx (8)<br>0x0000000000401096 &lt;+52&gt;:    and    $0xf,%edx# 仅保留%rdx中的低4位 (4)<br>    # rbx + rax -&gt; rcx -&gt; (%rsp) -&gt; %rdx (4)<br>    <br>0x0000000000401099 &lt;+55&gt;:    movzbl 0x4024b0(%rdx),%edx# 4024b0+%rdx -&gt; edx (32)<br># 0x4024b0处内容：maduiersnfotvbyl<br>0x00000000004010a0 &lt;+62&gt;:    mov    %dl,0x10(%rsp,%rax,1)# dl -&gt; (rsp + 16 + i)<br>    # 4024b0 + rdx -&gt; (rsp + 16 + i) (8)<br>0x00000000004010a4 &lt;+66&gt;:    add    $0x1,%rax# i++<br>0x00000000004010a8 &lt;+70&gt;:    cmp    $0x6,%rax# i &lt; 6<br>0x00000000004010ac &lt;+74&gt;:    jne    0x40108b &lt;phase_5+41&gt;<br># 循环终止<br></code></pre></td></tr></table></figure><p>转换为高级代码逻辑如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// string s = &quot;maduiersnfotvbyl&quot; 位于0x4024b0处的字符串</span><br><span class="hljs-comment">// str in $rbx, i in $rax</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;<br>    <span class="hljs-comment">// index in %rdx (4)</span><br>    <span class="hljs-type">int</span> index = input[i] &amp; <span class="hljs-number">0xf</span>;<span class="hljs-comment">// 仅保留低4位 &lt;+41&gt; - &lt;+52&gt;</span><br>   <span class="hljs-comment">// str = rsp + 16, s = 0x4024b0</span><br>    str[i] = s[index];<br>    <br>    <span class="hljs-comment">// 即：str[i] = s[ (input[i] &amp; 0xf) ];</span><br>&#125;<br></code></pre></td></tr></table></figure><p>至此我们发现：</p><ul class="lvl-0"><li class="lvl-2"><p>输入字符串<code>input</code>中的值会依次作为索引，来读入内存中字符串<code>s</code>（位于内存中0x4024b0处）中对应下标处的字符，并送入栈帧中<code>str</code>（位于<code>$rsp + 16</code>）处；</p></li><li class="lvl-2"><p>只关心<code>input</code>中最低四位的值。</p></li></ul><h3 id="part-4">part 4</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">0x00000000004010ae &lt;+76&gt;:    movb   $0x0,0x16(%rsp)<br>    # 高2bytes置零，低6bytes保留<br>0x00000000004010b3 &lt;+81&gt;:    mov    $0x40245e,%esi<br>    # 字符串内容为 flyers 送入 rsi<br>0x00000000004010b8 &lt;+86&gt;:    lea    0x10(%rsp),%rdi<br># str 送入 rdi<br>0x00000000004010bd &lt;+91&gt;:    callq  0x401338 &lt;strings_not_equal&gt;<br># 对比 str 与 &quot;flyers&quot;<br>0x00000000004010c2 &lt;+96&gt;:    test   %eax,%eax<br>0x00000000004010c4 &lt;+98&gt;:    je     0x4010d9 &lt;phase_5+119&gt;<br>0x00000000004010c6 &lt;+100&gt;:   callq  0x40143a &lt;explode_bomb&gt;<br>    <br>0x00000000004010cb &lt;+105&gt;:   nopl   0x0(%rax,%rax,1) # 空操作？<br>0x00000000004010d0 &lt;+110&gt;:   jmp    0x4010d9 &lt;phase_5+119&gt;<br></code></pre></td></tr></table></figure><p>如上即为一个判断逻辑，查看0x40245e处的字符串，并与其对比：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">if(str != &quot;flyers&quot;) &#123;<br>explode_bomb();<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，整体逻辑已经结束，即：</p><ol><li class="lvl-3"><p>输入为6个字符，从0到6依次取每个字符的二进制低4位作为索引index，即索引为：<code>input[i] &amp; 0xf</code>；</p></li><li class="lvl-3"><p>函数内开辟一个局部字符数组<code>str</code>，位于栈帧<code>rsp + 16</code>处；</p></li><li class="lvl-3"><p><code>str[i] = s[ (input[i] &amp; 0xf) ] </code></p><p>其中字符串<code>s</code>位于内存中4024b0处，其值为：<code>maduiersnfotvbyl</code></p></li><li class="lvl-3"><p>对比<code>str</code>与<code>&quot;flyers&quot;</code>，相等即为正确答案。</p></li></ol><p>即，输入给出一个正确的索引顺序，使得<code>str</code>的值为<code>&quot;flyers&quot;</code>。正确的下标顺序为<code>9fe567</code>，即，输入字符串的二进制低四位的值（ASCII）必须等于<code>9fe567</code>（1001, 1111, 1110, 0101, 0110, 0111）。查看ASCII码即可得到正确的答案。一个正确的例子是：<code>)/.%&amp;'</code>（肯定使用字母和数字更方便，这个例子是为了表达结果的任意性）。</p><h3 id="part-5">part 5</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">     # 检查canary<br>0x00000000004010d9 &lt;+119&gt;:   mov    0x18(%rsp),%rax<br>0x00000000004010de &lt;+124&gt;:   xor    %fs:0x28,%rax<br>0x00000000004010e7 &lt;+133&gt;:   je     0x4010ee &lt;phase_5+140&gt;<br>0x00000000004010e9 &lt;+135&gt;:   callq  0x400b30 &lt;__stack_chk_fail@plt&gt;<br>    # deallocate stack frame<br>0x00000000004010ee &lt;+140&gt;:   add    $0x20,%rsp<br>0x00000000004010f2 &lt;+144&gt;:   pop    %rbx<br>0x00000000004010f3 &lt;+145&gt;:   retq<br></code></pre></td></tr></table></figure><p>常规收尾工作：检查canary + 释放栈帧。</p><p>栈帧与字符串的情况见图：</p><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/202303061117105.png" style="zoom:33%;" /><p><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/202303061117722.png" alt=""></p><h2 id="phase-6">phase_6</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) disas phase_6<br>Dump of assembler code for function phase_6:<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">part1</span><br>   0x00000000004010f4 &lt;+0&gt;:     push   %r14<br>   0x00000000004010f6 &lt;+2&gt;:     push   %r13<br>   0x00000000004010f8 &lt;+4&gt;:     push   %r12<br>   0x00000000004010fa &lt;+6&gt;:     push   %rbp<br>   0x00000000004010fb &lt;+7&gt;:     push   %rbx<br>   0x00000000004010fc &lt;+8&gt;:     sub    $0x50,%rsp<br>   # callee-saved regs and allocate stack frame<br>   0x0000000000401100 &lt;+12&gt;:    mov    %rsp,%r13<br>   # rsp in $r13<br>   0x0000000000401103 &lt;+15&gt;:    mov    %rsp,%rsi<br>   # read_six_numbers有2个参数，第二个用于产生地址<br>   0x0000000000401106 &lt;+18&gt;:    callq  0x40145c &lt;read_six_numbers&gt;<br>   <br>   0x000000000040110b &lt;+23&gt;:    mov    %rsp,%r14<br>   # rsp in $r14<br>   0x000000000040110e &lt;+26&gt;:    mov    $0x0,%r12d<br>   # 0 in $r12<br>   <br>   0x0000000000401114 &lt;+32&gt;:    mov    %r13,%rbp<br>   # rsp in $rbp<br>   0x0000000000401117 &lt;+35&gt;:    mov    0x0(%r13),%eax<br>   0x000000000040111b &lt;+39&gt;:    sub    $0x1,%eax<br>   # x1 - 1 in $eax<br>   <br>   0x000000000040111e &lt;+42&gt;:    cmp    $0x5,%eax<br>   0x0000000000401121 &lt;+45&gt;:    jbe    0x401128 &lt;phase_6+52&gt;<br>   # if (x1 - 1 &gt; 5) goto explode<br>   0x0000000000401123 &lt;+47&gt;:    callq  0x40143a &lt;explode_bomb&gt;<br>   <br>   0x0000000000401128 &lt;+52&gt;:    add    $0x1,%r12d<br>   # r12d++ 暂且称其为i<br>   0x000000000040112c &lt;+56&gt;:    cmp    $0x6,%r12d<br>   0x0000000000401130 &lt;+60&gt;:    je     0x401153 &lt;phase_6+95&gt;<br>   0x0000000000401132 &lt;+62&gt;:    mov    %r12d,%ebx<br>   <br><span class="hljs-meta prompt_"># </span><span class="language-bash">loop</span><br>   0x0000000000401135 &lt;+65&gt;:    movslq %ebx,%rax<br>   # i -&gt; ebx -&gt; rax<br>   0x0000000000401138 &lt;+68&gt;:    mov    (%rsp,%rax,4),%eax<br>   # eax = x[i]<br>   0x000000000040113b &lt;+71&gt;:    cmp    %eax,0x0(%rbp)<br>   0x000000000040113e &lt;+74&gt;:    jne    0x401145 &lt;phase_6+81&gt;<br>   # if (x[i] == x[0]) goto explode<br>   # x[i] != x[0] ??<br>   0x0000000000401140 &lt;+76&gt;:    callq  0x40143a &lt;explode_bomb&gt;<br>   <br>   0x0000000000401145 &lt;+81&gt;:    add    $0x1,%ebx                  # i + 1<br>   0x0000000000401148 &lt;+84&gt;:    cmp    $0x5,%ebx<br>   0x000000000040114b &lt;+87&gt;:    jle    0x401135 &lt;phase_6+65&gt;<br>   # if (i + 1 &gt; 5) leave <br>   <br>   0x000000000040114d &lt;+89&gt;:    add    $0x4,%r13<br>   0x0000000000401151 &lt;+93&gt;:    jmp    0x401114 &lt;phase_6+32&gt;<br>   <br>   0x0000000000401153 &lt;+95&gt;:    lea    0x18(%rsp),%rsi<br>   0x0000000000401158 &lt;+100&gt;:   mov    %r14,%rax<br>   0x000000000040115b &lt;+103&gt;:   mov    $0x7,%ecx<br>   0x0000000000401160 &lt;+108&gt;:   mov    %ecx,%edx<br>   0x0000000000401162 &lt;+110&gt;:   sub    (%rax),%edx<br>   0x0000000000401164 &lt;+112&gt;:   mov    %edx,(%rax)<br>   0x0000000000401166 &lt;+114&gt;:   add    $0x4,%rax<br>   0x000000000040116a &lt;+118&gt;:   cmp    %rsi,%rax<br>   0x000000000040116d &lt;+121&gt;:   jne    0x401160 &lt;phase_6+108&gt;<br>   0x000000000040116f &lt;+123&gt;:   mov    $0x0,%esi<br>   0x0000000000401174 &lt;+128&gt;:   jmp    0x401197 &lt;phase_6+163&gt;<br>   0x0000000000401176 &lt;+130&gt;:   mov    0x8(%rdx),%rdx<br>   0x000000000040117a &lt;+134&gt;:   add    $0x1,%eax<br>   0x000000000040117d &lt;+137&gt;:   cmp    %ecx,%eax<br>   0x000000000040117f &lt;+139&gt;:   jne    0x401176 &lt;phase_6+130&gt;<br>   0x0000000000401181 &lt;+141&gt;:   jmp    0x401188 &lt;phase_6+148&gt;<br>   0x0000000000401183 &lt;+143&gt;:   mov    $0x6032d0,%edx<br>   0x0000000000401188 &lt;+148&gt;:   mov    %rdx,0x20(%rsp,%rsi,2)<br>   0x000000000040118d &lt;+153&gt;:   add    $0x4,%rsi<br>   0x0000000000401191 &lt;+157&gt;:   cmp    $0x18,%rsi<br>   0x0000000000401195 &lt;+161&gt;:   je     0x4011ab &lt;phase_6+183&gt;<br>   0x0000000000401197 &lt;+163&gt;:   mov    (%rsp,%rsi,1),%ecx<br>   0x000000000040119a &lt;+166&gt;:   cmp    $0x1,%ecx<br>   0x000000000040119d &lt;+169&gt;:   jle    0x401183 &lt;phase_6+143&gt;<br>   0x000000000040119f &lt;+171&gt;:   mov    $0x1,%eax<br>   0x00000000004011a4 &lt;+176&gt;:   mov    $0x6032d0,%edx<br>   0x00000000004011a9 &lt;+181&gt;:   jmp    0x401176 &lt;phase_6+130&gt;<br>   0x00000000004011ab &lt;+183&gt;:   mov    0x20(%rsp),%rbx<br>   0x00000000004011b0 &lt;+188&gt;:   lea    0x28(%rsp),%rax<br>   0x00000000004011b5 &lt;+193&gt;:   lea    0x50(%rsp),%rsi<br>   0x00000000004011ba &lt;+198&gt;:   mov    %rbx,%rcx<br>   0x00000000004011bd &lt;+201&gt;:   mov    (%rax),%rdx<br>   0x00000000004011c0 &lt;+204&gt;:   mov    %rdx,0x8(%rcx)<br>   0x00000000004011c4 &lt;+208&gt;:   add    $0x8,%rax<br>   0x00000000004011c8 &lt;+212&gt;:   cmp    %rsi,%rax<br>   0x00000000004011cb &lt;+215&gt;:   je     0x4011d2 &lt;phase_6+222&gt;<br>   0x00000000004011cd &lt;+217&gt;:   mov    %rdx,%rcx<br>   0x00000000004011d0 &lt;+220&gt;:   jmp    0x4011bd &lt;phase_6+201&gt;<br>   0x00000000004011d2 &lt;+222&gt;:   movq   $0x0,0x8(%rdx)<br>   0x00000000004011da &lt;+230&gt;:   mov    $0x5,%ebp<br>   0x00000000004011df &lt;+235&gt;:   mov    0x8(%rbx),%rax<br>   0x00000000004011e3 &lt;+239&gt;:   mov    (%rax),%eax<br>   0x00000000004011e5 &lt;+241&gt;:   cmp    %eax,(%rbx)<br>   0x00000000004011e7 &lt;+243&gt;:   jge    0x4011ee &lt;phase_6+250&gt;<br>   0x00000000004011e9 &lt;+245&gt;:   callq  0x40143a &lt;explode_bomb&gt;<br>   0x00000000004011ee &lt;+250&gt;:   mov    0x8(%rbx),%rbx<br>   0x00000000004011f2 &lt;+254&gt;:   sub    $0x1,%ebp<br>   0x00000000004011f5 &lt;+257&gt;:   jne    0x4011df &lt;phase_6+235&gt;<br>   0x00000000004011f7 &lt;+259&gt;:   add    $0x50,%rsp<br>   0x00000000004011fb &lt;+263&gt;:   pop    %rbx<br>   0x00000000004011fc &lt;+264&gt;:   pop    %rbp<br>   0x00000000004011fd &lt;+265&gt;:   pop    %r12<br>   0x00000000004011ff &lt;+267&gt;:   pop    %r13<br>   0x0000000000401201 &lt;+269&gt;:   pop    %r14<br>   0x0000000000401203 &lt;+271&gt;:   retq<br>End of assembler dump.<br></code></pre></td></tr></table></figure><h3 id="part-1-2">part 1</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">part1</span><br>   0x00000000004010f4 &lt;+0&gt;:     push   %r14<br>   0x00000000004010f6 &lt;+2&gt;:     push   %r13<br>   0x00000000004010f8 &lt;+4&gt;:     push   %r12<br>   0x00000000004010fa &lt;+6&gt;:     push   %rbp<br>   0x00000000004010fb &lt;+7&gt;:     push   %rbx<br>   0x00000000004010fc &lt;+8&gt;:     sub    $0x50,%rsp<br>   # callee-saved regs and allocate stack frame<br></code></pre></td></tr></table></figure><h3 id="part-2-read-six-numbers">part 2: read six numbers</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">0x0000000000401100 &lt;+12&gt;:    mov    %rsp,%r13<br># rsp in $r13<br>0x0000000000401103 &lt;+15&gt;:    mov    %rsp,%rsi<br># read_six_numbers有2个参数，第二个用于产生地址<br>0x0000000000401106 &lt;+18&gt;:    callq  0x40145c &lt;read_six_numbers&gt;<br></code></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>$rsp</code>送入<code>$r13</code>中；</p></li><li class="lvl-2"><p>读入6个输入，该函数不再继续了解，前面已经叙述过。此时的栈帧情况如图：</p><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/202303061115426.png" style="zoom:33%;" /></li></ul><h3 id="part-3">part 3</h3><h4 id="3-1-准备进入循环">3-1 准备进入循环</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">0x000000000040110b &lt;+23&gt;:    mov    %rsp,%r14<br># rsp/&amp;x[0] in $r14<br>0x000000000040110e &lt;+26&gt;:    mov    $0x0,%r12d<br># 0 in $r12<br></code></pre></td></tr></table></figure><h4 id="3-2-循环体">3-2 循环体</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs shell">   0x0000000000401114 &lt;+32&gt;:    mov    %r13,%rbp<br>   # $rsp in $rbp 因为此时$r13中的值即为$rsp &lt;+12&gt;<br>   <br>   0x0000000000401117 &lt;+35&gt;:    mov    0x0(%r13),%eax# x0送入$eax<br>   0x000000000040111b &lt;+39&gt;:    sub    $0x1,%eax<br>   # x0 - 1 in $eax<br>   0x000000000040111e &lt;+42&gt;:    cmp    $0x5,%eax<br>   0x0000000000401121 &lt;+45&gt;:    jbe    0x401128 &lt;phase_6+52&gt;<br>   0x0000000000401123 &lt;+47&gt;:    callq  0x40143a &lt;explode_bomb&gt;<br>   # if (x[i] - 1 &gt; 5) goto explode<br>   # 要求：eax = M(%r13) - 1 &lt;= 5<br>   <br>   # for j 0 to 5<br>   0x0000000000401128 &lt;+52&gt;:    add    $0x1,%r12d<br>   # r12d++ 暂且称其为j++<br>   0x000000000040112c &lt;+56&gt;:    cmp    $0x6,%r12d<br>   0x0000000000401130 &lt;+60&gt;:    je     0x401153 &lt;phase_6+95&gt;  # j == 6时跳出循环 <br>   0x0000000000401132 &lt;+62&gt;:    mov    %r12d,%ebx<br>   # k = j<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">inisde loop: k from j to 5 <span class="hljs-keyword">in</span> <span class="hljs-variable">$ebx</span> 检查所有，要求均不等于xi，否则爆炸</span><br>   0x0000000000401135 &lt;+65&gt;:    movslq %ebx,%rax<br>   # k -&gt; ebx -&gt; rax<br>   0x0000000000401138 &lt;+68&gt;:    mov    (%rsp,%rax,4),%eax<br>   # eax = x[k]<br>   0x000000000040113b &lt;+71&gt;:    cmp    %eax,0x0(%rbp)<br>   0x000000000040113e &lt;+74&gt;:    jne    0x401145 &lt;phase_6+81&gt;<br>   # if (x[k] == x[0]) goto explode<br>   0x0000000000401140 &lt;+76&gt;:    callq  0x40143a &lt;explode_bomb&gt;<br>   0x0000000000401145 &lt;+81&gt;:    add    $0x1,%ebx                 <br>   0x0000000000401148 &lt;+84&gt;:    cmp    $0x5,%ebx<br>   0x000000000040114b &lt;+87&gt;:    jle    0x401135 &lt;phase_6+65&gt;<br>   <br>                                # i++<br>   0x000000000040114d &lt;+89&gt;:    add    $0x4,%r13    # r13指向下一个x<br>   0x0000000000401151 &lt;+93&gt;:    jmp    0x401114 &lt;phase_6+32&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">暂且认为这一大段嵌套循环的目的是：保证6个数全都不一致，且取值范围为1-6，否则爆炸</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这就意味着6个数为1-6的某种排列（0的情况？）</span><br></code></pre></td></tr></table></figure><p>转化为高级语言的逻辑如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*--</span><br><span class="hljs-comment">int j = 0;</span><br><span class="hljs-comment">for (int i = 0; i &lt; 6; i++) &#123;</span><br><span class="hljs-comment">if(x[i] - 1 &gt; 5) &#123;</span><br><span class="hljs-comment">goto explode;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">j++;</span><br><span class="hljs-comment">if(j == 6) &#123;</span><br><span class="hljs-comment">break;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">for(int k = j; k &lt;= 5; k++) &#123;</span><br><span class="hljs-comment">if(x[k] == x[i]) &#123;</span><br><span class="hljs-comment">goto explode;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">--*/</span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;<br><span class="hljs-keyword">if</span>(x[i] &gt; <span class="hljs-number">6</span>) &#123;<br><span class="hljs-keyword">goto</span> explode;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">6</span>; j++) &#123;<br><span class="hljs-keyword">if</span>(x[i] == x[j]) &#123;<br><span class="hljs-keyword">goto</span> explode;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="part-4-2">part 4</h3><h4 id="4-1-准备进入循环">4-1 准备进入循环</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">0x0000000000401153 &lt;+95&gt;:    lea    0x18(%rsp),%rsi <br># $rsp + 24 -&gt; $rsi  指明循环终点<br>0x0000000000401158 &lt;+100&gt;:   mov    %r14,%rax<br># $r14 = $rsp -&gt; $rax<br>0x000000000040115b &lt;+103&gt;:   mov    $0x7,%ecx<br></code></pre></td></tr></table></figure><h4 id="4-2-循环体">4-2 循环体</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">0x0000000000401160 &lt;+108&gt;:   mov    %ecx,%edx<br># 7 in $edx<br>0x0000000000401162 &lt;+110&gt;:   sub    (%rax),%edx<br># 7 - x[i] in edx<br>0x0000000000401164 &lt;+112&gt;:   mov    %edx,(%rax)<br># x[i] = 7 - x[i]<br>0x0000000000401166 &lt;+114&gt;:   add    $0x4,%rax<br># 指向下一个x<br>0x000000000040116a &lt;+118&gt;:   cmp    %rsi,%rax<br>0x000000000040116d &lt;+121&gt;:   jne    0x401160 &lt;phase_6+108&gt;<br></code></pre></td></tr></table></figure><p>转换为高级语言的逻辑：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;<br>    x[i] = <span class="hljs-number">7</span> - x[i];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="part-5-2">part 5</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs shell">0x000000000040116f &lt;+123&gt;:   mov    $0x0,%esi# esi = i = 0<br>0x0000000000401174 &lt;+128&gt;:   jmp    0x401197 &lt;phase_6+163&gt;<br><br>                             # 0x6032d0 in $rdx, 0x1 in $rax<br>0x0000000000401176 &lt;+130&gt;:   mov    0x8(%rdx),%rdx<br># rdx += 8<br>0x000000000040117a &lt;+134&gt;:   add    $0x1,%eax<br>  # eax++<br>0x000000000040117d &lt;+137&gt;:   cmp    %ecx,%eax<br>0x000000000040117f &lt;+139&gt;:   jne    0x401176 &lt;phase_6+130&gt;<br><br>0x0000000000401181 &lt;+141&gt;:   jmp    0x401188 &lt;phase_6+148&gt;<br><br># if x[i] &lt;= 1<br>0x0000000000401183 &lt;+143&gt;:   mov    $0x6032d0,%edx<br>0x0000000000401188 &lt;+148&gt;:   mov    %rdx,0x20(%rsp,%rsi,2)<br># 6032d0 -&gt; rsp + 32 + 2 * i<br>0x000000000040118d &lt;+153&gt;:   add    $0x4,%rsi<br># i += 4<br>0x0000000000401191 &lt;+157&gt;:   cmp    $0x18,%rsi<br>0x0000000000401195 &lt;+161&gt;:   je     0x4011ab &lt;phase_6+183&gt;<br># if i == 24 goto &lt;+183&gt;<br><br>0x0000000000401197 &lt;+163&gt;:   mov    (%rsp,%rsi,1),%ecx<br># x[i] -&gt; $ecx<br>0x000000000040119a &lt;+166&gt;:   cmp    $0x1,%ecx<br>0x000000000040119d &lt;+169&gt;:   jle    0x401183 &lt;phase_6+143&gt;<br># if x[i] &lt;= 1 goto &lt;+143&gt;<br># else<br>0x000000000040119f &lt;+171&gt;:   mov    $0x1,%eax<br>0x00000000004011a4 &lt;+176&gt;:   mov    $0x6032d0,%edx<br>0x00000000004011a9 &lt;+181&gt;:   jmp    0x401176 &lt;phase_6+130&gt;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// long y[] 起始于rsp + 32  链表？ </span><br><span class="hljs-keyword">for</span>(esi = <span class="hljs-number">0</span>; esi &lt; <span class="hljs-number">6</span>; esi++) &#123;    <span class="hljs-comment">// &lt;+123&gt;</span><br>    <span class="hljs-comment">// &lt;+163&gt;</span><br>    ecx = x[esi];<span class="hljs-comment">// &lt;+163&gt;</span><br>    <span class="hljs-keyword">if</span> (ecx &gt; <span class="hljs-number">1</span>) &#123;     <span class="hljs-comment">// &lt;+166&gt; - &lt;+169&gt;</span><br>        <span class="hljs-comment">// &lt;+171&gt;</span><br>        <span class="hljs-keyword">for</span>(eax = <span class="hljs-number">1</span>; eax &lt; ecx; eax++) &#123;  <span class="hljs-comment">// &lt;+171&gt; + &lt;+137&gt; - &lt;+139&gt;</span><br>            edx = *(edx + <span class="hljs-number">8</span>);<span class="hljs-comment">// 链表？</span><br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// if ecx &lt;= 1</span><br>        edx = <span class="hljs-number">0x6032d0</span>;<span class="hljs-comment">// &lt;+148&gt;</span><br>    &#125;<br>y[esi] = edx;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="phase-6-2">phase 6</h3><h4 id="6-1">6-1</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell">0x00000000004011ab &lt;+183&gt;:   mov    0x20(%rsp),%rbx<br># rbx = y[0]<br>0x00000000004011b0 &lt;+188&gt;:   lea    0x28(%rsp),%rax<br># rax = &amp;y[1] (rsp + 40)<br>0x00000000004011b5 &lt;+193&gt;:   lea    0x50(%rsp),%rsi<br># rsi = rsp + 80  循环终止点<br>0x00000000004011ba &lt;+198&gt;:   mov    %rbx,%rcx<br># rcx = rbx = y[0]<br><br>0x00000000004011bd &lt;+201&gt;:   mov    (%rax),%rdx<br># rdx = *rax = y[1]<br>0x00000000004011c0 &lt;+204&gt;:   mov    %rdx,0x8(%rcx)<br># *(y[0] + 8) = y[1];<br>0x00000000004011c4 &lt;+208&gt;:   add    $0x8,%rax<br># rax += 8 = &amp;y[2]<br>0x00000000004011c8 &lt;+212&gt;:   cmp    %rsi,%rax<br>0x00000000004011cb &lt;+215&gt;:   je     0x4011d2 &lt;phase_6+222&gt;<br>0x00000000004011cd &lt;+217&gt;:   mov    %rdx,%rcx<br># rcx = y[1];<br>0x00000000004011d0 &lt;+220&gt;:   jmp    0x4011bd &lt;phase_6+201&gt;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(rax = y + <span class="hljs-number">1</span>; rax &lt; y + <span class="hljs-number">6</span>; rax++) &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="secret-phase">secret_phase</h2><p><code>DrEvil</code></p>]]></content>
    
    
    <categories>
      
      <category>15-213</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>网络流</title>
    <link href="/2022/12/09/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    <url>/2022/12/09/%E7%BD%91%E7%BB%9C%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h1>网络流</h1><h2 id="基本概念-2">基本概念</h2><h3 id="网络-Network">网络 Network</h3><h3 id="流-Flow">流 Flow</h3><h3 id="-2"></h3><h2 id="最大流">最大流</h2><h3 id="相关概念">相关概念</h3><h4 id="残量网络">残量网络</h4><h4 id="增广路">增广路</h4><h3 id="Ford-Fulkerson增广路算法">Ford-Fulkerson增广路算法</h3><h3 id="Edmonds-Karp动能算法">Edmonds-Karp动能算法</h3><h3 id="Dinic算法1234">Dinic算法1234</h3>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>最大流</tag>
      
      <tag>最小割</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最小生成树（Minimum Spanning Tree）</title>
    <link href="/2022/12/09/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    <url>/2022/12/09/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="最小生成树-Minimum-Spanning-Tree-2">最小生成树 Minimum Spanning Tree</h2><p>基本概念与性质：</p><ul class="lvl-0"><li class="lvl-2"><p>最小生成树（MST）即所有边权之和最小的生成树。</p></li><li class="lvl-2"><p>MST不唯一，但对应的边权和唯一（最小值）。</p></li><li class="lvl-2"><p>必有 $|V|$ 个顶点， $|V| - 1$ 条边。这符合树的基本性质：包含所有图中的顶点，且不存在回路。</p><p>由此可得：如果图 $G$ 是一颗树，则其 MST 必定是它本身。</p></li><li class="lvl-2"><p>最小生成树的两种算法实现都是典型的<strong>贪心算法</strong>。</p></li><li class="lvl-2"><p>最小生成树的存在性同时也表征了 <b>图的连通性</b>。即，生成树的概念只针对连通图。</p><p>如果是非连通图，只存在生成森林。</p></li></ul><h3 id="Prim">Prim</h3><blockquote><p>基本思想：让一颗小树长大从某一起点出发，不断选择 <b>与当前集合 距离最近的节点</b> 加入。</p></blockquote><h4 id="实现-4">实现</h4><p>实现中有两个重点概念：</p><ol><li class="lvl-3"><p>集合：集合中的点即代表当前已经处理过的点。可以使用<b>布尔数组</b>或者<b>哈希集合</b>来表示该集合。</p></li><li class="lvl-3"><p>与集合的距离：</p><p>初始状态为所有点距离起始点的距离。后续每次向集合中加入新点时，都更新数组（即<b>松弛操作</b>，Relaxation）。即绕该新节点是否能获得离集合更近的距离。</p></li></ol><p>算法流程如下：</p><p>执行 $n$ 次循环。其中 $n$ 代表节点个数，每次循环向集合中加入一个节点。循环体：</p><ol><li class="lvl-3"><p><b>找出当前距离集合最近的点 $v$</b>。两种方法实现：</p><ul class="lvl-2"><li class="lvl-5">线性遍历；</li><li class="lvl-5">使用<b>堆</b>进行优化；</li></ul></li><li class="lvl-3"><p><b>将点 $v$ 加入集合。</b>加入哈希序列或者修改布尔数组的值即可，视具体实现而定。</p></li><li class="lvl-3"><p><b>松弛（Relaxation）。</b>更新其他节点与集合的距离，即其他节点绕行该新加入的节点 $v$ 是否能够获得更近的距离。</p></li></ol><blockquote><p>Dijkstra算法和prim算法其实是相同的思路（贪心+松弛），只是在其中记录距离的 $dist$ 数组的含义发生了变化：Dijkstra中代表与源点的距离，而Prim中代表与集合的距离。</p></blockquote><h4 id="效率-5">效率</h4><p>最外层循环共执行 $V$ 次；</p><ul class="lvl-0"><li class="lvl-2"><p>寻找最小值：</p><ul class="lvl-2"><li class="lvl-4">线性遍历：$O(V)$</li><li class="lvl-4">堆：$O(logV)$</li></ul></li><li class="lvl-2"><p>松弛：</p><ul class="lvl-2"><li class="lvl-4">使用邻接表（能够按照边的信息来访问）：$O(E)$</li><li class="lvl-4">使用邻接矩阵：$O(V)$</li></ul><p>如果使用堆，松弛操作进行的修改还涉及堆的调整：$O(logV)$</p></li></ul><p>综上：</p><ul class="lvl-0"><li class="lvl-2"><p>暴力寻找最小值：$O(V^2)$</p></li><li class="lvl-2"><p>普通二叉堆：$O((E+V)logV) = O(ElogV)$</p></li></ul><p>使用Fib堆能够有进一步的提升。</p><p>Prim主要由节点数量决定效率，显然适合稠密图。实际应用中虽然复杂度比Kruskal更优，跑起来却未必更快。</p><h3 id="Kruskal">Kruskal</h3><blockquote><p>基本思想：将森林合并成树每次选取 <b>权值最小</b> 且 <b>不会构成回路</b> 的边，加入集合。</p></blockquote><h4 id="实现-5">实现</h4><p>实现中的重点：</p><ol><li class="lvl-3"><p>边贪心。即如何从小到大的取边。</p><ul class="lvl-2"><li class="lvl-5">排序：将图的信息转换为边的信息，对每条边按照权重从小到大排序。排序是最常用的方法；</li><li class="lvl-5">堆：利用优先队列实现从小到大取。</li></ul></li><li class="lvl-3"><p>判断当前加入的边是否为安全边 / 是否会构成回路。</p><p>使用并查集，判断边是否满足要求相当于判断边的两个节点是否在同一集合中。</p></li><li class="lvl-3"><p>当前满足条件的边集合。前面使用了并查集来判断安全边，此处继续通过 Union 操作来将边的两个节点合并即可。</p></li></ol><p>算法流程：</p><ol><li class="lvl-3"><p>对边进行排序。</p></li><li class="lvl-3"><p>从小到大枚举所有边，直至枚举结束或者当前边数已经构成树为止（$|E| = |V| - 1$）。</p></li><li class="lvl-3"><p>循环体中：</p><ul class="lvl-2"><li class="lvl-5">使用并查集判断当前边是否为安全边（<code>Find</code>操作）；</li><li class="lvl-5">如果为安全边，则加入集合（<code>Union</code>操作）。</li></ul></li><li class="lvl-3"><p>如果结束循环时，加入集合的边数量不对（$|E| \neq |V| - 1$），则说明图不连通/生成树不存在。</p></li></ol><h4 id="效率-6">效率</h4><ul class="lvl-0"><li class="lvl-2"><p>排序：$O(ElogE)$</p></li><li class="lvl-2"><p>循环+并查集：循环执行 $O(E)$ 次<code>Find</code>与<code>Union</code>操作。</p><p>假定使用按秩合并与路径压缩的并查集：$O(E\alpha(V))$。</p></li></ul><p>综上，总渐进时间复杂度为 $O(ElogE)$。</p><p>考虑到 $|V| - 1\leq|E| &lt; |V|^2$ ，如果是稀疏图，即边的数量接近顶点数量的情况，Kruskal接近$O(VlogV)$。绝大多数情况下，Kruskal的实际性能都更优。</p><h3 id="相关题目-15">相关题目</h3><ul class="lvl-0"><li class="lvl-2"><p><a href="http://bailian.openjudge.cn/practice/solution/37220720/">POJ Agri-Net</a></p></li></ul><h3 id="其他相关概念">其他相关概念</h3><p>次优最小生成树（Second-best Minimum Spanning Tree）、瓶颈生成树（Bottleneck Spanning Tree）等。</p><p><a href="https://oi-wiki.org/graph/mst/">最小生成树 - OI Wiki (oi-wiki.org)</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Prim</tag>
      
      <tag>Kruskal</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最短路径（Shortest Path）</title>
    <link href="/2022/12/09/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    <url>/2022/12/09/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h2 id="最短路径-Shortest-Path-2">最短路径 Shortest Path</h2><p>最短路径有若干变体（variants），基本都可以分为两大类：</p><ul class="lvl-0"><li class="lvl-2"><p>单源最短路径（Single-Source Shortest Path, SSSP）</p><p>对于无权图的单源最短路径，使用朴素的BFS即可得到答案。Prim和Dijkstra也都是BFS思想的算法。</p></li><li class="lvl-2"><p>所有结点对最短路径问题（All-Pair Shortest Path, APSP）</p></li></ul><p>首先我们来关注最短路径问题涉及的一些重要性质与话题：</p><h4 id="最短路径的最优子结构-Optimal-Substructure-of-a-Shortest-Path">最短路径的最优子结构 Optimal Substructure of a Shortest Path</h4><p>即，最短路径的子路径也是最短路径。</p><h4 id="负权重的边与环路-Negative-weight-Edges-and-Cycles">负权重的边与环路 Negative-weight Edges and Cycles</h4><p>负权重边与环路是密切相关的：</p><ul class="lvl-0"><li class="lvl-2"><p>如果一个结点对之间只存在负权重边，不存在负权重环路，那么仍然存在最短路径的定义；</p><p>此时，两个节点之间存在无数条路径，因为环路可以走任意次，但是正环路保证了最短路径的存在。</p></li><li class="lvl-2"><p>如果一个结点对之间存在负权重环路，那么两点之间则不存在最短路径的定义；</p><p>因为不断绕负环走能够使得路径长度无穷的减小下去。</p></li></ul><p>对于不同的算法来说：</p><ul class="lvl-0"><li class="lvl-2"><p>Dijkstra无法处理带有负权边的图，只能应用于正权值网络中。</p></li><li class="lvl-2"><p>只要没有负权重环路（只是存在负权边），则Bellman-Ford能够应对，可以侦测并报告负边的存在。</p></li></ul><p>通过上述分析，无论正还是负，环路都不可能会出现在最短路径中。我们可以假定 <b>最短路径中均为简单路径，不存在环路。</b></p><h4 id="实际路径的重构-Representing-Shortest-Paths">实际路径的重构 Representing Shortest Paths</h4><p>很多情况下，我们不但希望计算出最短路径的权重，还希望重构出路径、给出路径上的结点。</p><p>对于每个结点 $v$，我们维持一个<b>前驱结点</b> $v.\pi$。最短路径算法在是实现的过程中，对每个节点的 $\pi$ 属性进行设置，这样，将从结点 $v$ 开始的前驱结点链反转即可得到一条最短路径。</p><h4 id="松弛-Relaxation">松弛 Relaxation</h4><blockquote><p><b>Relaxation的含义（算法导论Ch24）</b></p><p>It may seem strange that the term “relaxation” is used for an operation that tightens an upper bound. The use of the term is historical. The outcome of a relaxation step can be viewed as a relaxation of the constraint $v.d \leq u.d + w(u,v)$, which, by the triangle inequality, must be satisfied if $u.d = \delta(s, u)$ and $v.d = \delta(s, v)$. That is, if $v.d \leq u.d + w(u, v)$, there is no “pressure” to satisfy this constraint, so the constraint is “relaxed”.</p></blockquote><p>对边 $(u, v)$ 的松弛就是考虑该边能否对 $s$ 到 $v$ 之间的最短路径做出改善，即考虑 $s$ 绕 $v$ 到 $u$ 能否产生更短的路径。具体流程伪代码如下：<br>$$<br>\begin{array}{ll}<br>1 &amp; \text{RELAX}(u,v,weight) \<br>2 &amp; \textbf{if} \space v.dist &gt; u.dist + weight(u,v)\<br>3 &amp; \qquad v.dist = u.d+weight(u,v) \<br>4 &amp; \qquad v.\pi = u<br>\end{array}<br>$$<br>在接下来的算法中，松弛是唯一导致最短路径估计与前驱结点发生变化的操作。不同算法之间的不同之处在于对每条边松弛的<b>次数</b>以及松弛边的<b>次序</b>不同。</p><h3 id="单源最短路径">单源最短路径</h3><h4 id="贪心-—-Dijkstra">贪心 — Dijkstra</h4><p>每个边松弛一次，按照结点离起点的距离进行贪心。Dijkstra要求图中不能存在负权值边。</p><h5 id="数据结构-2">数据结构</h5><ol><li class="lvl-3"><p>集合：表示已经计算过最短路径的结点。使用布尔数组或哈希集合均可。</p></li><li class="lvl-3"><p>与源点的距离：开辟 $dist$ 数组记录每个结点与源点的距离。</p><p>初始情况下，起点 $dist$ 为 0，其他均为 $+\infty$ 。</p><p>如果采用优先队列进行优化，则开辟对应数据结构。</p></li><li class="lvl-3"><p>记录前驱：开辟一个数组记录每个结点在最短路径上的前驱。</p></li></ol><h5 id="算法流程">算法流程</h5><p>$n$ 次循环，代表每次将一个结点加入集合。每次循环中分为三步：</p><ol><li class="lvl-3"><p>找出当前距离源点最近的结点 $u$；</p><p>优化：使用堆等优先队列来组织结点。</p></li><li class="lvl-3"><p>将 $u$ 加入集合，按照题意增加其他相关操作；</p></li><li class="lvl-3"><p>对于每个与 $u$ 相连的结点，进行松弛操作。</p></li></ol><h5 id="实现-6">实现</h5><p>伪代码如下：<br>$$<br>\begin{array}{ll}<br>1 &amp; \text{DIJKSTRA.}(G)\<br>2 &amp; \text{initialize} \<br>3 &amp; S = \varnothing \<br>3 &amp; \textbf{for } i= 1 \textbf{ to } |V|  \<br>4 &amp; \qquad u = \text{EXTRACT_MIN(G)} \<br>5 &amp; \qquad S = S \bigcup {u} \<br>6 &amp; \qquad \textbf{for } \text{each vertex }v \text{ connected to } u\<br>7 &amp; \qquad \qquad \text{RELAX}(u, v,weight)<br>\end{array}<br>$$</p><ol><li class="lvl-3"><p>暴力实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span> &#123;<br>    <span class="hljs-type">int</span> v, weight;<br>&#125;;<br>vector&lt; vector&lt;edge&gt; &gt; edge;<br>vector&lt;<span class="hljs-type">int</span>&gt; dist;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// initialize</span><br>    unordered_set&lt;<span class="hljs-type">int</span>&gt; s;<br>    dist.<span class="hljs-built_in">resize</span>(n);<br>    <span class="hljs-built_in">fill</span>(dist.<span class="hljs-built_in">begin</span>(), dist.<span class="hljs-built_in">end</span>(), INT_MAX);<br>    dist[start] = <span class="hljs-number">0</span>;<span class="hljs-comment">// 设置起点dist</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-comment">// EXTRACT-MIN</span><br>        <span class="hljs-type">int</span> u, minDist = INT_MAX;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">if</span> ( !s.<span class="hljs-built_in">count</span>(j) &amp;&amp; dist[j] &lt; minDist ) &#123;<br>        u = j;<br>                minDist = dist[j];<br>            &#125;<br>        &#125;<br>        <br>        s.<span class="hljs-built_in">insert</span>(u);<br>        <br>        <span class="hljs-comment">// RELAX</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; adj: graph[u]) &#123;<br>       <span class="hljs-type">int</span> v = adj.v, weight = adj.weight;<br>            <span class="hljs-keyword">if</span> (dist[u] + weight &lt; dist[v]) &#123;<br>            dist[v] = dist[u] + weight;    <br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li class="lvl-3"><p>优先队列实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span> &#123;<br>    <span class="hljs-type">int</span> v, weight;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    <span class="hljs-type">int</span> u, dist;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt; (<span class="hljs-type">const</span> node&amp; a) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> dist &gt; a.dist;<br>    &#125;<br>&#125;;<br>vector&lt; vector&lt;edge&gt; &gt; graph;<br>vector&lt;<span class="hljs-type">int</span>&gt; dist;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// initialize</span><br>    unordered_set&lt;<span class="hljs-type">int</span>&gt; s;<br>    dist.<span class="hljs-built_in">resize</span>(n);<br>    <span class="hljs-built_in">fill</span>(dist.<span class="hljs-built_in">begin</span>(), dist.<span class="hljs-built_in">end</span>(), INT_MAX);<br>    dist[start] = <span class="hljs-number">0</span>;<br>    pirority_queue&lt;node, vector&lt;node&gt;, greater&lt;node&gt;&gt; q;<br>    q.<span class="hljs-built_in">push</span>(&#123;start, <span class="hljs-number">0</span>&#125;);<br>    <br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-comment">// EXTRACT-MIN</span><br>        <span class="hljs-type">int</span> u = q.<span class="hljs-built_in">top</span>().u;<br>        q.<span class="hljs-built_in">pop</span>();<br>        <br>        s.<span class="hljs-built_in">insert</span>(u);<br>        <br>        <span class="hljs-comment">// RELAX</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; adj: graph[u]) &#123;<br>        <span class="hljs-type">int</span> v = adj.v, weight = adj.weight;<br>            <span class="hljs-keyword">if</span> (dist[u] + weight &lt; dist[v]) &#123;<br>            dist[v] = dist[u] + weight;<br>                q.<span class="hljs-built_in">push</span>(&#123;v, dist[v]&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h5 id="效率分析-2">效率分析</h5><p>提取最小结点的实现方式有多种，不同的实现时间复杂度不同：</p><ul class="lvl-0"><li class="lvl-2"><p>暴力：</p><ul class="lvl-2"><li class="lvl-4">提取最小值：共 $|V|$ 次循环，每次循环中暴力遍历：$O(V)$</li><li class="lvl-4">松弛：每个边松弛一次，即 $O(E)$</li></ul><p>总计：$O(V^2 + E) = O(V^2)$</p></li><li class="lvl-2"><p>二叉堆 ：</p><ul class="lvl-2"><li class="lvl-4">提取最小值：共 $|V|$ 次循环，每次弹出堆顶元素：$O(logV)$</li><li class="lvl-4">松弛：每个边松弛一次，并且每次松弛都会向堆中插入元素：$O(logV)$</li></ul><p>总计：$O(VlogV + ElogV) = O((V+E)logV) = O(ElogV)$</p></li></ul><p>使用 Fibonacci 堆可以进一步提升速度。</p><p>总的来看：</p><ul class="lvl-0"><li class="lvl-2"><p>在稀疏图中，如果 $|E| = O(V)$，那么使用二叉堆的 Dijkstra 是比 Bellman-Ford 算法有较大的效率优势的。</p></li><li class="lvl-2"><p>在稠密图中，$|E| = O(n^2)$，那么暴力做法的实际速度比二叉堆更优。</p></li></ul><h4 id="动态规划-—-Bellman-Ford">动态规划 — Bellman Ford</h4><p>每个边松弛 $|V| - 1$ 次。Bellman-Ford</p><h5 id="算法流程-2">算法流程</h5><p>Bellman-Ford就是不断尝试对图上的边依次进行松弛，每一轮循环都会对图中所有的边尝试进行一次松弛操作。当一次循环中没有成功的松弛操作时，算法停止。考虑到一次松弛会使最短路径的边数至少 + 1，而整个单源最短路径的边数最多为 $|V| - 1$ （无环路/简单路径）。因此整个算法最多执行 $|V| - 1$ 轮松弛操作。</p><p>设置整个算法循环 $|V| - 1$ 轮。如果整个图中存在负环，那么松弛操作会无休止的进行下去。因此，如果循环结束后检查仍然存在能松弛的边，就说明从起点出发能够到达一个负环。</p><div class="warning"><p><b>负环判断中存在的常见误区</b></p><p>需要注意的是，以 点为源点跑 Bellman-Ford 算法时，如果没有给出存在负环的结果，只能说明从 点出发不能抵达一个负环，而不能说明图上不存在负环。因此如果需要判断整个图上是否存在负环，最严谨的做法是建立一个超级源点，向图上每个节点连一条权值为 0 的边，然后以超级源点为起点执行 Bellman-Ford 算法。</p></div><h5 id="实现-7">实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span> &#123;<br>    <span class="hljs-type">int</span> v, weight;<br>&#125;;<br>vector&lt; vector&lt;<span class="hljs-type">int</span>&gt; &gt; graph;<br>vector&lt;<span class="hljs-type">int</span>&gt; dist;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">bellman_ford</span><span class="hljs-params">()</span> </span>&#123;<br>    dist.<span class="hljs-built_in">resize</span>(n);<br>    <span class="hljs-built_in">fill</span>(dist.<span class="hljs-built_in">begin</span>(), dist.<span class="hljs-built_in">end</span>(), INT_MAX);<br>    dist[start] = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">bool</span> flag;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;                <span class="hljs-comment">// |V|次循环</span><br>        flag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> u = <span class="hljs-number">0</span>; u &lt; n; u++) &#123;     <span class="hljs-comment">// 对所有边尝试松弛</span><br>            <span class="hljs-keyword">if</span> (dist[u] == INT_MAX) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; adj: graph[u]) &#123;<br>                <span class="hljs-type">int</span> v = adj.v, weight = adj.weight;<br>                <span class="hljs-keyword">if</span> (dist[u] + weight &lt; dist[v]) &#123;<br>                dist[v] = dist[u] + weight; <br>                    flag = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!flag) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> flag;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="效率分析-3">效率分析</h5><p>共 $|V| - 1$ 轮循环，每轮循环遍历所有边，即 $O(E)$。故总时间复杂度为 $O(VE)$ 。</p><p>实际模拟这个过程，会发现算法的效率很取决于松弛边的顺序，即，很多松弛操作因为顺序不当其实是无用的。针对这个缺陷，有很多针对 Bellman-Ford 的优化算法，国内最出名的就是 SPFA 算法。</p><div class="tips"><p><b>Bellman-Ford 的其他优化 </b></p><p>除了队列优化（SPFA）之外，Bellman-Ford 还有其他形式的优化，这些优化在部分图上效果明显，但在某些特殊图上，最坏复杂度可能达到指数级。</p><ul class="lvl-1"><li class="lvl-2"><p>堆优化：将队列换成堆，与 Dijkstra 的区别是允许一个点多次入队。在有负权边的图可能被卡成指数级复杂度。</p></li><li class="lvl-2"><p>栈优化：将队列换成栈（即将原来的 BFS 过程变成 DFS），在寻找负环时可能具有更高效率，但最坏时间复杂度仍然为指数级。</p></li><li class="lvl-2"><p>LLL 优化：将普通队列换成双端队列，每次将入队结点距离和队内距离平均值比较，如果更大则插入至队尾，否则插入队首。</p></li><li class="lvl-2"><p>SLF 优化：将普通队列换成双端队列，每次将入队结点距离和队首比较，如果更大则插入至队尾，否则插入队首。</p></li><li class="lvl-2"><p>D´Esopo-Pape 算法：将普通队列换成双端队列，如果一个节点之前没有入队，则将其插入队尾，否则插入队首。</p></li></ul><p>更多优化以及针对这些优化的 Hack 方法，可以看 <a href="https://www.zhihu.com/question/292283275/answer/484871888">fstqwq 在知乎上的回答</a>。</p></div><h4 id="队列优化-—-SPFA">队列优化 — SPFA</h4><p>针对 Bellman-Ford 中大量无意义的松弛操作，我们进行筛选：<b>只有上次被松弛的结点，所连接的边，才有可能引起下一次的松弛操作。</b></p><p>针对这一推论，我们使用一个队列来维护“哪些结点可能会引起松弛操作”，就能只访问必要的边了。</p><h5 id="实现-8">实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span> &#123;<br>    <span class="hljs-type">int</span> v, weight;<br>&#125;;<br>vector&lt; vector&lt;<span class="hljs-type">int</span>&gt; &gt; graph;<br>vector&lt;<span class="hljs-type">int</span>&gt; dist;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span> </span>&#123;<br>    dist.<span class="hljs-built_in">resize</span>(n);<br>    <span class="hljs-built_in">fill</span> (dist.<span class="hljs-built_in">begin</span>(), dist.<span class="hljs-built_in">end</span>(), INT_MAX);<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    unordered_set&lt;<span class="hljs-type">int</span>&gt; s;<span class="hljs-comment">// 表征哪些结点已经在队列中，防止重复入队</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<span class="hljs-comment">// 记录到当前结点的最短路径长度，便于判定负环</span><br>    dist[start] = <span class="hljs-number">0</span>;<br>    q.<span class="hljs-built_in">emplace</span>(start);<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> u = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        s.<span class="hljs-built_in">erase</span>(u);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; adj: graph[u]) &#123;<br>            <span class="hljs-type">int</span> v = adj.v, weight = adj.weight;<br>            <span class="hljs-keyword">if</span> (dist[u] + weight &lt; dist[v]) &#123;<br>                dist[v] = dist[u] + weight;<br>                cnt[v] = cnt[u] + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span>(cnt[v] &gt; n - <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">// 如果路径长度大于n-1,必定是因为存在负环</span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(!s.<span class="hljs-built_in">count</span>(v)) &#123;<br>                    q.<span class="hljs-built_in">push</span>(v);<br>                    s.<span class="hljs-built_in">insert</span>(v);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="有向无环图中的单源最短路径">有向无环图中的单源最短路径</h4><p>有向无环图意味着图存在拓扑序。按照拓扑序的顺序对边依次进行松弛操作，能够在 $\Theta(V+E)$ 的时间内完成单源最短路径的求解。对于邻接链表的形式就是线性时间。</p><h4 id="相关题目-16">相关题目</h4><p><a href="http://bailian.openjudge.cn/practice/solution/37918576/">POJ-Checking an Alibi</a></p><h3 id="多源最短路径">多源最短路径</h3><h4 id="Floyd-Warshall">Floyd-Warshall</h4><p>能够处理带有负值边的图，但不允许出现负环（不存在简单最短路径）。</p><h5 id="数据结构-3">数据结构</h5><p>定义一个三维数组 $dist[i][x][y]$，表示第 $i$ 轮循环中（只允许经过结点 $1$ 到 $i$），结点 $x$ 到结点 $y$ 的最短距离。</p><p>Floyd算法的本质是一个动态规划算法，根据其定义也能建立SRTBOT模型，且上述三维数组可以进行空间压缩。</p><h5 id="算法流程-3">算法流程</h5><p>共 $|V|$ 轮循环，第 $i$ 轮循环更新所有结点两两之间绕行结点 $i$ （只允许经过结点 $1$ 到 $i$）是否会产生更近的距离。</p><p>为Floyd算法建立SRTBOT模型：</p><ul class="lvl-0"><li class="lvl-2"><p>Subproblem: $dp[i][x][y]$ 代表只允许经过结点 $1$ 到 $i$ ，结点 $x$ 到结点 $y$ 的最短距离。</p></li><li class="lvl-2"><p>Relate: 第 $i$ 轮循环即尝试绕结点 $i$ 是否会产生更短的距离，即：<br>$$<br>dp[i][x][y] = min(dp[i - 1][x][i] + dp[i - 1][i][y], dp[i - 1][x][y]);<br>$$</p></li><li class="lvl-2"><p>Topological Order: Increasing $i, x, y$ . 三重循环。</p></li><li class="lvl-2"><p>Base: $dp[0][x][y]$ 代表初始情况下（不绕行任何中间节点），图中结点两两直接相连（单一条边）的距离。</p></li><li class="lvl-2"><p>Original Problem:  $dp[n][x][y]$</p><p>其中 $n = |V|$ ，即对每个结点更新过一次后的矩阵即为全源最短路径。</p></li><li class="lvl-2"><p>Time: $O(n^3)$</p></li><li class="lvl-2"><p>Memory: 可以进行状态压缩。模拟就能够发现，第一维其实是可以直接省略的，空间压缩至二维，空间复杂度为 $O(n^2)$。</p></li></ul><h5 id="实现-9">实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><span class="hljs-keyword">for</span> <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt; n; x++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; y &lt; n; y++) &#123;<br>            <br>            dist[x][y] = <span class="hljs-built_in">min</span>( dist[x][i] + dist[i][y], dist[x][y] );<br>            <br>            <span class="hljs-comment">/*--</span><br><span class="hljs-comment">            空间压缩前：</span><br><span class="hljs-comment">            dist[i][x][y] = min( dist[i - 1][x][i] + dist[i - 1][i][y], dist[i - 1][x][y] );</span><br><span class="hljs-comment">            --*/</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="效率分析-4">效率分析</h5><p>三重循环：时间复杂度为 $O(V^3)$，空间复杂度为 $O(N^2)$。</p><h4 id="Johnson-稀疏图适用">Johnson - 稀疏图适用</h4><h5 id="算法思想">算法思想</h5><p>经过堆优化的Dijkstra算法是非常优秀的，如果枚举所有起点，跑 $|V|$ 次Dijkstra算法，能够以不错的速度解决多源最短路径问题。这种做法比跑 $|V|$ 次Bellman-Ford算法的时间复杂度更优秀，在<b>稀疏图</b>上也比Floyd算法的速度更快。</p><p>由于Dijkstra无法处理正确求解负权值边，我们需要对边的权值进行预处理。即，Johnson算法的核心思想就是<b>“重新赋予边权+Dijkstra”</b>。在这个过程中，会使用Dijkstra和Bellman-Ford算法作为自己的子程序。</p><p>整理一下思路：</p><ul class="lvl-0"><li class="lvl-2"><p>能够处理具有负权值边的图，但不可有负环；</p></li><li class="lvl-2"><p>对具有负边的情况，重新赋予边权；</p></li><li class="lvl-2"><p>保证了所有边权均为正后，对每个结点挨个调用 Dijkstra 算法。</p></li></ul><h5 id="算法流程-4">算法流程</h5><p>重点关注重新赋予边权的过程：</p><p><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/pics-master/202212091439847.png" alt=""></p><ul class="lvl-0"><li class="lvl-2"><p>(a)：建立一个全新结点 $s$，从这个点向其他所有点连接一条边权为 0 的边;</p><p>图中黑色即为新建结点 $s$ ，结点 $v$ 内部标记的值为黑点 0 到其的距离 $h(s, v)$；</p><p>调用Bellman-Ford算法，更新所有结点到 $s$ 的最短距离，显然会出现负的距离。</p></li><li class="lvl-2"><p>(b)：对每条边进行重新赋权。公式如下：<br>$$<br>\hat{w}(u, v) = w(u, v) + h(u) - h(v)<br>$$<br>此操作后，图中所有边都能保证正值，且最短路径的结果并未发生变化。证明详见算法导论 Ch25.3。</p></li><li class="lvl-2"><p>© - (g)：对每个结点依次调用 Dijkstra。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Dijkstra</tag>
      
      <tag>Bellman-Ford</tag>
      
      <tag>Floyd-Warshall</tag>
      
      <tag>Johnson</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分治 Divide and Conquer</title>
    <link href="/2022/11/23/%E5%88%86%E6%B2%BB-Divide-and-Conquer/"/>
    <url>/2022/11/23/%E5%88%86%E6%B2%BB-Divide-and-Conquer/</url>
    
    <content type="html"><![CDATA[<h2 id="递归式求解">递归式求解</h2><h3 id="代入法-Substitution-Method">代入法 Substitution Method</h3><h3 id="递归树法-Recursion-tree-Method">递归树法 Recursion-tree Method</h3><h3 id="主方法-Master-Theorem">主方法 Master Theorem</h3><h2 id="经典问题">经典问题</h2><h3 id="归并排序">归并排序</h3><h4 id="优化">优化</h4><p>在归并排序中对小数组采用<b>插入排序</b>。（算法导论：思考题2-1）</p><h3 id="逆序对计数">逆序对计数</h3><p>使用归并排序求解逆序对计数问题。</p><ul class="lvl-0"><li class="lvl-2"><p><a href="http://algorithm.openjudge.cn/2022algohw3/solution/37258895/">POJ 重要逆序对</a></p></li><li class="lvl-2"><p>剑指Offer 51. 数组中的逆序对 (Hard)</p><blockquote><p>首先，按照逆序对的定义，来统计数组中的逆序对的方法有两种形式：</p><ul class="lvl-3"><li class="lvl-2">统计每一位的前面有几个更大的元素；</li><li class="lvl-2">统计每一位的后面有几个更小的元素；</li></ul><p>二者本质一样，按照具体解题方法来选择即可。</p><p>第一反应的暴力解法使用两种形式均可，两层循环达到$O(n^2)$级别复杂度（上限也就5000），题目中50000规模的输入显然会TLE。</p></blockquote><p>逆序对数有两种常见的优化解法：</p><ul class="lvl-2"><li class="lvl-4"><p><em>解法一：桶 + 树状数组 + 数组离散化</em></p><ul class="lvl-4"><li class="lvl-6"><p>基本思想是【<strong>建桶</strong>】来统计每个元素出现的次数，则该桶的<strong>前缀和</strong>即为小于该元素的元素数量。</p></li><li class="lvl-6"><p>考虑到前缀和给出的是更小的元素的数量，我们选择第二种形式统计，即统计每一位的后面有几个更小的元素：</p><p>下标就要从大到小进行循环，对每个位置的值对应的桶自增一，并统计当前桶的前缀和（即已经处理过的、后面的更小元素值的数量）。</p><p>反复计算前缀和/区间和问题显然可以使用树状数组来进行优化。</p></li><li class="lvl-6"><p>同时在空间上，因为元素的值可能非常大，因此对最大值进行建桶会导致空间利用率低，且内存可能并不足够。对于这种<strong>稀疏且只关心相对大小</strong>的桶，可以使用<strong>离散化</strong>来增加空间利用率，也避免出现 MLE。</p><p>**离散化就是将数组内元素排序，按照大小分配成从 1 到 $n$的值。**具体实现如下：</p><ol><li class="lvl-9"><p>复制一个一模一样的临时数组，并对其进行排序 — 耗费 $O(nlogn)$</p></li><li class="lvl-9"><p>从前往后对原数组每个位置进行访问，利用二分查找在临时数组中查找其排序后的位置，并利用该位置修改其值。</p></li></ol></li></ul></li><li class="lvl-4"><p>解法二：归并排序</p><p>归并排序每一次 <b>合并</b> 的时候，观察左右两个子序列 $[l_1, \space r_1], [l_2, \space r_2]$ （此时均为有序序列）。</p><p>假设当前状态如上述，指向两个子序列的指针为 $lPtr$ 与 $rPtr$ ：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">    l_1      r_1       l_2      r_2<br>     |<span class="hljs-string">        </span>|<span class="hljs-string">         </span>|<span class="hljs-string">        </span>|<br>L = [2, 3, 6, 7]   R = [0, 1, 4, 5]       Merge = []<br>     |<span class="hljs-string">                  </span>|<br>    lPtr               rPtr<br></code></pre></td></tr></table></figure><ul class="lvl-4"><li class="lvl-6"><p>统计每一位后比其更小的元素个数：</p><p>当 $lPtr$ 指向的元素小于等于 $rPtr$ 指向的元素，即 $lPtr$ 应右移；此时，$rPtr$ 左侧的元素均小于 $lPtr$ 所指向的元素，且在原数组中位于其后。统计该部分长度为 $rPtr - l_2 + 1$ 。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">    l_1      r_1       l_2      r_2<br>     |<span class="hljs-string">        </span>|<span class="hljs-string">         </span>|<span class="hljs-string">        </span>|<br>L = [2, 3, 6, 7]   R = [0, 1, 4, 5]      Merge = [0, 1]<br>     |<span class="hljs-string">                        </span>|<br>    lPtr                     rPtr<br></code></pre></td></tr></table></figure></li><li class="lvl-6"><p>统计每一位前比其更大的元素个数：</p><p>$rPtr$ 指向的元素小于 $lPtr$ 指向的元素，即 $rPtr$ 应右移；和上述同理，但关注 $L$ 中更大的元素部分。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">    l_1      r_1       l_2      r_2<br>     |<span class="hljs-string">        </span>|<span class="hljs-string">         </span>|<span class="hljs-string">        </span>|<br>L = [2, 3, 6, 7]   R = [0, 1, 4, 5]      Merge = [0, 1, 2, 3]<br>           |<span class="hljs-string">                  </span>|<br>          lPtr               rPtr<br></code></pre></td></tr></table></figure></li></ul><p>上述两种方式任选其一，不要同时使用会造成重复答案，手动操作以加深理解。</p><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/pics-master/202204261027731.png" style="zoom: 50%;" /></li></ul></li><li class="lvl-2"><p>315 计算右侧小于当前元素的个数 (Hard)<br>跟剑指offer51一模一样的题目，换个形式而已。额外需要注意的是下标的记录，由于可能存在重复元素，无法直接使用哈希表来记录元素下标。所以开辟一个新的下标数组，在归并排序的过程中与主数组同步变化。</p></li></ul><h3 id="平面最近点对">平面最近点对</h3><p>即，给定一系列二维平面上的点，求一组欧几里得距离最近的点对。（题解比较套路）</p><p>首先考虑暴力解法，即对所有点对两两计算距离并求出最小值，时间显然为 $O(n^2)$。常见两种优化解法：分治 与 随机化。</p><h4 id="分治">分治</h4><p>整体思路来看：</p><p><b>Divide</b>: 将所有点进行二分。显然二分的前提是要对所有点的坐标进行排序。排序上，我们以横坐标为第一优先级，纵坐标为第二优先级进行排序并二分。</p><p><b>Conquer</b>: 分别求解出二分后各自的最小距离，并将整体集合中的最小距离 $min$ 设置为二者中的较小值。</p><p><b>Combine</b>: 难点就在于如何合并。因为分治只考虑了二分后两部分各自的最小距离，而没有考虑到两个点分别在两个不同部分中的情况。因为我们在前两步已经得到了一个最小距离 $min$ ，所以我们只需要考虑小于这个距离的情况。根据勾股定理，我们只需要考虑在横坐标和纵坐标方向上距离小于 $min$ 的所有点。</p><ol><li class="lvl-3"><p>首先，根据横坐标划分，如图所示，仅考虑中点左右长度为 $min$ 的范围。将该范围内所有点放入一个待选集合 $temp$ 中。</p></li><li class="lvl-3"><p>其次，在上述集合中，按照纵坐标进行进一步的划分。即，在集合中考虑两点垂直距离不超过 $min$ 的两点，求出其距离并与 $min$ 进行比较。根据如上两步，在中点附近分别对横坐标和纵坐标范围进行了搜索，确定了是否存在两个点分别在不同集合中的情况。</p></li></ol><p><b>效率</b></p><p><a href="https://github.com/e-maxx-eng/e-maxx-eng/blob/master/src/geometry/nearest_points.md">参考文章</a></p><h4 id="随机化">随机化</h4><p>能够进一步将时间缩减至 $O(n)$。</p><h4 id="题目-3">题目</h4><ul class="lvl-0"><li class="lvl-2"><p><a href="http://bailian.openjudge.cn/practice/solution/37683786/">POJ Raid</a><br>明显的平面最近点对问题，唯一要注意的是需要将点分为两部分。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆序对计数</tag>
      
      <tag>平面上最近的点对</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序 Sort</title>
    <link href="/2022/11/22/%E6%8E%92%E5%BA%8F-Sort/"/>
    <url>/2022/11/22/%E6%8E%92%E5%BA%8F-Sort/</url>
    
    <content type="html"><![CDATA[<blockquote><p>代码实现见<code>leetcode\sort.cpp</code></p></blockquote><h2 id="复杂度与稳定性-2">复杂度与稳定性</h2><table><thead><tr><th style="text-align:center">排序方法</th><th style="text-align:center">平均时间复杂度</th><th style="text-align:center">最坏时间复杂度</th><th style="text-align:center">额外空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center">简单选择排序</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">冒泡排序</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">直接插入排序</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">希尔排序</td><td style="text-align:center">$O(n^d)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">基数排序</td><td style="text-align:center">$O(p(n+b))$</td><td style="text-align:center">$O(p(n+b))$</td><td style="text-align:center">$O(n+b)$</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">堆排序</td><td style="text-align:center">$O(n log n)$</td><td style="text-align:center">$O(n log n)$</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">快速排序</td><td style="text-align:center">$O(n log n)$</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">$O(log n)$</td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">归并排序</td><td style="text-align:center">$O(n log n)$</td><td style="text-align:center">$O(n log n)$</td><td style="text-align:center">$O(n)$</td><td style="text-align:center">稳定</td></tr></tbody></table><h2 id="插入排序-Insertion-Sort-2">插入排序 Insertion Sort</h2><h3 id="循环不变式-Loop-Invariant">循环不变式 Loop Invariant</h3><p>循环不变式 (loop invariant) 用于理解和证明算法的正确性。实际上，循环不变式并不是狭义上的式子，而是一个在算法起始、中间运算、中止的过程中保持为“真”的命题。即在循环体的每次执行前后均为真的谓词。循环不变式体现了循环程序中循环变量的变化规律。</p><blockquote><p>举例说明：口袋中有黑、白两色小球，现将手放入袋中每次摸出两个，如果两球同色就都不放回袋中，如果两球异色就将白球放回，由于每次至少减少一个，所以袋中的球必然越来越少。现问：如果袋中最后剩下一个球，此球的颜色与开始时袋中黑、白球的个数有什么关系？按照一般的思路，此题非常复杂，难以解决。多次重复摸球及放回的动作构成了一个循环过程。如果我们有意识地寻找循环过程中不变的性质，就会发现，在循环过程中，白球个数的奇偶性保持不变，因为，每次取出的白球的个数或是零或是2。因此，如果开始时白球的个数为奇数，那么剩下的一球为白球。如果开始时白球的个数为偶数，那么剩下的一球为黑球。这种 <b>不依较前面所执行的重复次数的性质</b> 称之为循环不变式。</p></blockquote><p>关于循环不变式，我们需要证明三条性质：</p><ul class="lvl-0"><li class="lvl-2"><p><b>初始化 Initialization</b>：循环的第一次迭代之前，它为真。</p></li><li class="lvl-2"><p><b>保持 Maintenance</b>：如果循环的某次迭代之前它为真，那么下次迭代之前它仍为真。</p></li><li class="lvl-2"><p><b>终止 Termination</b>：在循环终止时，不变式为我们提供一个有用的性质，该性质有助于证明算法是否是正确的。</p></li></ul><p>前两条性质有点类似于数学归纳法，但第三条性质与我们通常使用的数学归纳法不同，在归纳法中，归纳步是无限使用的，但在这里当循环终止时，停止“归纳”。</p><h3 id="利用循环不变式证明插入排序">利用循环不变式证明插入排序</h3><p>首先，要先找出其中的循环不变式。经过分析，可以看出：在循环的每次迭代开始时，子数组$A[1…j-1]$ 由原来在 $A[1…j-1]$ 中的元素组成，但已按升序排列。</p><p>接着证明循环不变式的三条性质成立：</p><ul class="lvl-0"><li class="lvl-2"><p><b>初始化</b>：在循环的第一次迭代之前，子数组 $A[1…j-1]$ 仅由第一个元素 $A[1]$ 组成，循环不变式显然成立。</p></li><li class="lvl-2"><p><b>保持</b>：在循环中，将 $A[ j - 1]$、$A[ j - 2]$、$A[ j - 3]$ 等向右移动一个位置，直到 $A[j]$ 找到适当位置，并将 $A[j]$ 插入到该位置。此时子数组 $A[1… j]$ 由原来在 $A[1… j]$ 中的元素组成，但已按序排列。循环不变式成立。</p></li><li class="lvl-2"><p><b>终止</b>：循环终止的条件为 $j &gt;A.length=n$，即 $j =A.length+1$ 时。此时子数组 $A[1… n]$ 由原来在 $A[1… n]$ 中的元素组成，但已按序排列。循环不变式成立，算法正确。</p></li></ul><h3 id="效率-4">效率</h3><p>插入排序一个常见的优化即，在有序子序列部分选择插入位置时，使用 <b>二分查找</b> 来优化查找速度。但插入排序内层循环的时间消耗取决于 选择插入位置 + 移动元素 两部分。仅仅优化选择时间，元素的移动仍然为线性时间，所以时间复杂度仍然为平方级，而不能优化至 $O(nlogn)$。</p><h2 id="快速排序-Quick-Sort-2">快速排序 Quick Sort</h2><blockquote><p>基于<strong>元素交换</strong>的排序。</p></blockquote><h4 id="基本思想-3">基本思想</h4><p>快速排序也是一个基于交换的分治算法，算法的基本思想：</p><ol><li class="lvl-3"><p>选择主元，即每次选择一个元素作为分治基准<code>pivot</code>；</p><p><code>pivot</code>将所有元素分为两部分，每一轮要确定当前分治基准的最终位置，将比其小的元素移到左侧，比其大的元素移到右侧；</p></li><li class="lvl-3"><p>子集分治（partition）：以<code>pivot</code>为基准将元素分割成了两部分，分别是<strong>更小的左半部分</strong>和<strong>更大的右半部分</strong>，分别向两边进行分治处理。</p></li></ol><h4 id="效率与特点-2">效率与特点</h4><p>效率的高低主要取决于分治基准的选取，通常默认采取第一个元素作为基准：</p><ul class="lvl-0"><li class="lvl-2"><p>最好情况：每次<code>pivot</code>都能正好将所有元素二分，时间复杂度为 $O(nlogn)$，空间上递归工作栈深度$O(logn)$；</p></li><li class="lvl-2"><p>最坏情况：如果待排序列是个有序表，则每次都有一侧是个空表，时间复杂度上升至 $O(n^2)$，空间上递归工作栈深度 $O(n)$。</p></li></ul><p>快速排序有一些解题时用得到、值得注意的特点：</p><ul class="lvl-0"><li class="lvl-2"><p>待排序列<strong>越无序，效率越高</strong>；</p><p>可以对数组进行<strong>随机化打乱</strong>。根据算法导论中的证明，将数组打乱后，快排就能达到$O(n)$的期望时间复杂度！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> lo, <span class="hljs-type">int</span> hi)</span> </span>&#123;<br>    <span class="hljs-built_in">srand</span>(<span class="hljs-built_in">time</span>(<span class="hljs-number">0</span>));<br>    <span class="hljs-type">int</span> random = <span class="hljs-built_in">rand</span>() % (hi - lo + <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">swap</span>(nums[lo + random], nums[lo]);<br>    <br>    <span class="hljs-type">int</span> pivot = nums[lo];<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure></li><li class="lvl-2"><p><strong>每次都会有一个元素归位</strong>（215，TopK问题）</p><p>虽然快速排序在排序的中途不会产生任何有序子序列，但是每一次子集划分时，分治基准<code>pivot</code>都会被放在最终的正确位置。</p></li></ul><h4 id="相关题目-12">相关题目</h4><blockquote><p><em>TopK</em>类型题目常用于考察快速排序。</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p><strong>215 Kth Largest Element in an Array 数组中的第K个最大元素 (Medium)</strong></p><p>TopK问题，高频经典题目，必须熟练拿捏。啪的一下立马啊，就是一个带<strong>随机</strong>的<strong>快速排序</strong>。</p><p>思路：</p><ul class="lvl-2"><li class="lvl-4"><p>数组中寻找第K个元素的话，很自然的想到使用快速排序，因为快速排序每次都能将主元放到其最终位置，所以每次分治循环时判定分治基准的索引是否为k即可（降序排序）。</p><p>在使用随机化进行优化后，期望时间复杂度达到线性。</p><p>实际上，在期望时间复杂度方面，快速排序在效率上基本是最优秀的，在没有其他特定条件下，可以优先选择使用快速排序。</p></li><li class="lvl-4"><p>使用最大堆的思路也比较直接，但时间复杂度显然不如加入了随机优化的快速排序。</p></li></ul><p>解法总结：</p><ol><li class="lvl-5"><p>最重要的<strong>快速排序</strong>，通过引入随机化达到 $O(n)$ 的平均时间复杂度。</p></li><li class="lvl-5"><p><strong>大根堆</strong>：建堆消耗 $O(n)$，$k$次删除每次 $O(logn)$ 共 $O(klogn)$ 。总渐进复杂度为 $O(nlogn)$。</p></li></ol></li><li class="lvl-2"><p><strong>347 Top K Frequent Element 前K个高频元素 (Medium)</strong></p><p>见[桶排序](####桶排序 Bucket Sort)</p></li><li class="lvl-2"><p>75 Sort Colors 颜色分类 (Medium)</p><p>经典<strong>荷兰国旗问题</strong>。实质是快速排序的子集划分过程partition的改进：即通过一次扫描，把数组分为三个部分。</p><p>解法为双指针，详见[双指针部分](##双指针 Two pointers)。</p></li></ul><h2 id="堆-Heap-3">堆 Heap</h2><h3 id="基本实现">基本实现</h3><h4 id="STL-2">STL</h4><p>STL中的优先级队列<code>priority_queue&lt;datatype&gt;</code>即为堆的实现。</p><h4 id="手动实现-2">手动实现</h4><p>数据结构上采用<strong>顺序存储</strong>，用<strong>数组</strong>存放的<strong>完全二叉树</strong>，该种树具备一些特性使得其适合作为堆：数组的索引可以反映出节点之间的逻辑关系。</p><p>数组存放有两种不同处理方式：一是从<strong>下标1</strong>处开始存放，二是从<strong>下标0</strong>处开始存放。这样对应的节点逻辑关系有所区别。</p><ul class="lvl-0"><li class="lvl-2"><p>从1处开始存放：对于编号为 $i$ 的节点，其父亲为 $i/2$ ，其左右孩子分别为 $2i$、$2i+1$；</p></li><li class="lvl-2"><p>从0处开始存放：对于编号为 $i$ 的节点，其父亲为 $(i - 1) / 2$ ，其左右孩子分别为 $2i + 1$、$2i+2$；</p><p>从效率上来看，从1开始存放对应的操作更简单（需要的指令）</p></li></ul><p>具体代码见sort.cpp。</p><h4 id="相关题目-13">相关题目</h4><ul class="lvl-0"><li class="lvl-2"><p><strong>215 Kth Largest Element in an Array 数组中的第K个最大元素 (Medium)</strong></p><p>见[快速排序](##快速排序 Quick Sort)。</p></li><li class="lvl-2"><p><strong>347 Top K Frequent Element 前K个高频元素 (Medium)</strong></p><p>见[桶排序](####桶排序 Bucket Sort)</p></li></ul><h3 id="对顶堆">对顶堆</h3><ul class="lvl-0"><li class="lvl-2"><p><a href="http://algorithm.openjudge.cn/2022hw2/solution/36783241/">POJ Dynamic Median</a></p></li></ul><h2 id="归并排序-Merge-Sort-2">归并排序 Merge Sort</h2><p>见分治。</p><ul class="lvl-0"><li class="lvl-2"></li></ul><h2 id="分布式排序-Distribution-Sort-2">分布式排序 Distribution Sort</h2><h3 id="桶排序-Bucket-Sort-2">桶排序 Bucket Sort</h3><p>根据元素属性的值（可能是出现次数、也可能是其他属性）来进行排序。</p><p>为每个可能取到的值建一个桶。用空间换时间，达到<strong>线性时间复杂度</strong>。</p><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/pics-master/202203151641820.png" style="zoom:50%;" /><ul class="lvl-0"><li class="lvl-2"><p><strong>347 Top K Frequent Element 前K个高频元素 (Medium)</strong></p><p>题目实际上要使用<strong>哈希表</strong>统计每个元素出现的次数，然后对该次数表进行实际的排序。</p><ul class="lvl-2"><li class="lvl-4"><p>解法一：使用哈希表加<strong>桶排序</strong>，空间换时间；</p><p>时间复杂度为线性，三个操作：哈希表统计出现次数、根据哈希表建桶、根据桶得到答案。三个操作时间复杂度均为线性。</p></li><li class="lvl-4"><p>解法二：堆</p></li><li class="lvl-4"><p>解法三：快速排序</p><p>使用哈希表统计时间，再把哈希表的内容放到一个数组中，再对数组进行TopK排序统计。</p></li></ul></li><li class="lvl-2"><p>451 Sort Character By Frequency 根据字符出现频率排序 (Medium)</p><p>跟347换个皮，实质一样。</p><p>仍然可以用其他任何排序解法来做，但时间复杂度都会更高。</p></li></ul><h3 id="基数排序-Radix-Sort-2">基数排序 Radix Sort</h3><h2 id="Miscellaneous-2">Miscellaneous</h2><h3 id="计数排序">计数排序</h3><ul class="lvl-0"><li class="lvl-2"><p>1051 Height Checker 高度检查器 (Easy)</p></li></ul><h3 id="选择排序-Selection-Sort-2">选择排序 Selection Sort</h3><h3 id="插入排序-Insertion-Sort-3">插入排序 Insertion Sort</h3><h3 id="冒泡排序-Bubble-Sort-2">冒泡排序 Bubble Sort</h3><h3 id="希尔排序-Shell-Sort-2">希尔排序 Shell Sort</h3><h3 id="STL中的排序-2">STL中的排序</h3>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>冒泡排序(Bubble Sort)</tag>
      
      <tag>快速排序(Quick Sort)</tag>
      
      <tag>堆(Heap)</tag>
      
      <tag>桶排序(Bucket Sort)</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>贪心（Greedy）</title>
    <link href="/2022/10/18/%E8%B4%AA%E5%BF%83%EF%BC%88Greedy%EF%BC%89/"/>
    <url>/2022/10/18/%E8%B4%AA%E5%BF%83%EF%BC%88Greedy%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="基本原理">基本原理</h2><ul class="lvl-0"><li class="lvl-2">不保证得到最优解，但实际对很多问题都可求得最优解。</li><li class="lvl-2">满足最优子结构。</li><li class="lvl-2">贪心选择性质（greedy-choice property）：局部最优解能够导向全局最优解。</li></ul><div class="tips"><p>几乎在每个贪心算法下，几乎总有一个更为繁琐的动态规划算法。</p></div><h2 id="相关算法">相关算法</h2><p>贪心的思想体现在各种重要的算法当中，比如<strong>Dijkstra</strong>、<strong>最小生成树</strong>以及<strong>Huffman编码</strong>等。</p><h3 id="区间问题">区间问题</h3><blockquote><p>对于区间贪心，通常都使用【排序 + 贪心】的思路来解决。</p><p>参考：算法导论16.1（活动选择问题）、算法设计4.1（区间调度）。</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>435 Non-overlapping Intervals 无重叠区间 (Medium)</p><p>贪心思想：每次选择都保证剩余空间更大。</p><p>根据区间右端点进行排序，越小的右端点代表剩余空间越大。左端点排序与否不影响结果。</p><p>该题另外的解法还有动态规划，但时间复杂度更差，达到平方级且会TLE。</p></li><li class="lvl-2"><p>452 Minimum Number of Arrows to Burst Balloons 用最少数量的箭引爆气球 (Medium)</p><p>贪心思想：每次都从区间端点处射箭，可以理解为，再不射这根箭就没有办法满足要求。</p><p>本质和435一致。选择按照右端点进行排序。</p></li><li class="lvl-2"><p>757 Set Intersection Size At Least Two 设置交集大小至少为2 (Hard)</p><p>题目为452的变式，452代表交集大小为1的情况。</p><p>贪心思想：每次选择点都希望尽可能涉及更多的区间。</p><p>将区间按照右端点从小到大排序，显然我们尽量希望选择区间最右侧的点放入区间，因为该部分最有可能与后半部分产生相交。</p><p>一些注意事项：</p><ul class="lvl-2"><li class="lvl-4"><p>因为交集大小为2，所以每轮对新区间更新时要进行分类讨论；</p></li><li class="lvl-4"><p>要注意集合右端点相同的情况，集合左端点应该按照反向排序。具体通过手动模拟来理解。</p></li></ul></li><li class="lvl-2"><p><a href="http://algorithm.openjudge.cn/2022hw2/solution/36796440/">POJ Radar Installation</a></p><p>题目的实质和还是“用最少数量的箭引爆气球”，只是需要将题目中的几何转化为实际的区间问题。</p></li><li class="lvl-2"><p><a href="http://algorithm.openjudge.cn/2022hw1/solution/36075720/">POJ 区间合并</a></p><p>本质和452是一样的题目。</p></li><li class="lvl-2"><p>763 Partition Labels 划分字母区间 (Medium)</p><p>题目的实质一道最基础的区间问题：将一系列区间划分为完全不重叠的几部分。重点在于如何对题目建模，将字符串问题转化为实际的区间问题。</p></li><li class="lvl-2"><p>122 Best Time to Buy and Sell Stock II 买卖股票的最佳时机 (Medium)</p><p>贪心思想：因为购买次数没有限制，所以相当于涨了就卖。求出所有上升区间之差即可。注意的是贪心只能计算出最大利润，而计算过程本身并不代表实际交易过程。想要获得实际交易过程，需要使用动态规划。</p></li></ul><h3 id="Dijkstra">Dijkstra</h3><p>详细内容见图部分。</p><h3 id="MST">MST</h3><p>贪心思想：</p><ul class="lvl-0"><li class="lvl-2"><p>Prim：每次选取离集合最近的点加入集合，即使当前树的总权重增加量最小的边。</p></li><li class="lvl-2"><p>Kruskal: 边贪心，即次选取图中不会构成回路的最小边。</p></li></ul><p>详细内容见图部分。相关题目如下：</p><ul class="lvl-0"><li class="lvl-2"><p><a href="http://bailian.openjudge.cn/practice/solution/37220720/">POJ Agri-Net</a></p></li></ul><h3 id="Huffman-Code">Huffman Code</h3><p>详细内容见树部分。</p><h3 id="相关题目-17">相关题目</h3><ul class="lvl-0"><li class="lvl-2"><p>455 Assign Cookies 分发饼干 (Easy)</p><p>非常典型的贪心问题，需要先进行排序（根据数据规模判断可以接受<code>O(nlogn)</code>的时间复杂度。</p></li><li class="lvl-2"><p>1403 Minimum Subsequence in Non-Increasing Order 非递增顺序的最小子序列 (Easy)</p><p>简单贪心。</p></li><li class="lvl-2"><p>1217 Minimum Cost to Move Chips to The Same Position 玩筹码 (Easy)</p><p>重点在于理清题目的本质：实际和具体位置与移动根本无关，而只与位置的<strong>奇偶性</strong>有关。</p><p>移动两格的花费为0，移动一格的花费为1，意味着从奇数位到任意奇数位、从偶数位到任意偶数位的开销都为0。仅在奇偶出现切换时才会有开销。即最终的结果只跟最终位置的奇偶性有关，统计全部移到偶数位的开销（即奇数位元素的个数）与全部移到奇数位的开销（即偶数位元素的个数），二者选择较小值即可。</p></li><li class="lvl-2"><p>135 Candy 分发糖果 (Hard)</p><p>一个特殊的题意理解错误：当两个孩子相邻且评分一致时并不一定二者分到相同的糖果。题目只要求相邻二者中多的一定要更多。</p><p>非常典型的贪心问题：</p><ul class="lvl-2"><li class="lvl-4"><p>常规解法：二次扫描，从左到右一次，从右到左一次，满足两个方向上的大小关系。第二次要注意已经满足条件的情况。由于使用了辅助数组来存放糖果数，空间复杂度为<code>O(n)</code>。</p></li><li class="lvl-4"><p>优化解法：思路比较复杂，利用统计递增和递减序列长度来实现求解，具体见代码。无需辅助数组，能够将空间复杂度降低至O(1)。</p></li></ul></li><li class="lvl-2"><p>605 Can Place Flowers 种花问题 (Easy)</p><p>没什么特别的，注意一些边界条件处理就行，简单题。</p></li><li class="lvl-2"><p><strong>406 Queue Reconstruction by Height 根据身高重建队列 (Medium)</strong></p><p>不论从高到低还是从低到高，本题的本质在于按照<strong>优先级</strong>对元素进行排序。而对于优先级的定义来说，<strong>元素的特征不止一个，不同特征的排序方式可能会有所不同</strong>，这是一种很常见的处理方式。</p><p>比如本题存在两个特征，由于题目的条件是“大于等于”，所以两个特征的排序正好相反，应该一个增序、一个降序。</p></li><li class="lvl-2"><p>665 Non-decreasing Array 非递减数列 (Medium)</p><p>至多只有一个不符合非递减规则的元素，分两种情况：要么有个过大的元素，需要对其缩小；要么有个过小的元素，需要对其放大。</p><p>一个使用的库函数是<code>is_sorted</code>，判断容器是否有序，参数为起始和终止的迭代器。</p></li><li class="lvl-2"><p>2279 Maximum Bags With Full Capacity of Rocks 装满石头的背包的最大数量 (Medium)</p><p>排序 + 贪心</p></li><li class="lvl-2"><p>2285 Maximum Total Importance of Roads 道路的最大总重要性 (Medium)</p></li><li class="lvl-2"><p>2294 Partition Array Such That Maximum Difference is K 划分数组使最大差为K (Medium)</p><p>排序 + 贪心</p></li><li class="lvl-2"><p><strong>871 Minimum Number o Refueling Stops 最低加油次数 (Hard)</strong></p><p>贪心 + 堆</p><p>维护一个<strong>最远可达点</strong>，并将可达点内的加油站用一个<strong>大根堆</strong>来组织（根据加油站的油量）。每次从大根堆中选出<strong>最大</strong>的堆顶加油站来加油（贪心思想的体现），直至最远可达点超过<code>target</code>。</p><p>当大根堆中没有元素可加入且最远可达点仍小于<code>target</code>时，说明不可达，返回<code>-1</code>。</p></li><li class="lvl-2"><p><strong>870 Advantage Shuffle 优势洗牌 (Medium)</strong></p><p>在模拟的过程中能够发现是一个贪心问题：针对B的每个元素b，寻找A中最小的a使其满足 a&gt;b 。比较明显的贪心思想。类似于田忌赛马，本题具体解法如下：</p><ul class="lvl-2"><li class="lvl-4"><p>解法一：贪心 + 哈希</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">sort</span>(nums1);<span class="hljs-comment">// 首先对两个数组进行排序</span><br><span class="hljs-built_in">sort</span>(nums2);<br><span class="hljs-keyword">while</span>(nums1中还有元素) &#123;<br><span class="hljs-keyword">if</span>(nums1[ptr1] &gt; nums2[ptr2]) &#123;<br>结果填入答案；<br>ptr1++;  ptr2++;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>将nums1的值送入remaining;<br>ptr1++;<br>&#125;<br>&#125;<br><span class="hljs-keyword">while</span>(nums2中有未被满足的元素) &#123;<br>根据remaining中剩余元素进行填充；<br>&#125;<br></code></pre></td></tr></table></figure><p>值得注意的点：</p><ol><li class="lvl-9"><p>因为两个数组都要排序后解答，所以要利用哈希表来记录答案；</p></li><li class="lvl-9"><p>由于第二个数组中有可能出现重复元素，哈希表要记录下标到答案的映射，而非元素值到答案的映射；</p></li><li class="lvl-9"><p>书写sort中<code>cmp</code>函数的注意要点，详见STL.md中的内容；</p></li><li class="lvl-9"><p>题目的解法就是挺麻烦的，有时候要优先给出解法，先不要考虑代码的优雅程度；</p></li></ol></li><li class="lvl-4"><p>解法二：贪心 + 二分，使用multiset</p><p>也是一个很直观的想法，对$nums1$进行排序，并对$nums2$中的每个元素在$nums1$中进行二分查找最近的下一个更大值。</p></li></ul></li><li class="lvl-2"><p><a href="http://algorithm.openjudge.cn/2022hw2/solution/36786583/">POJ Yogurt Factory</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>extern &amp; static</title>
    <link href="/2022/10/12/extern-and-static/"/>
    <url>/2022/10/12/extern-and-static/</url>
    
    <content type="html"><![CDATA[<h2 id="程序-进程的内存空间">程序/进程的内存空间</h2><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/pics-master/202211082058886.png" style="zoom:50%;" /><p>这里关注的是Read/write data与Read-only code and data这部分。这些内容都是直接按照可执行目标文件（executable object file）的内容进行初始化的。</p><ul class="lvl-0"><li class="lvl-2"><p>Read/write data：全局区。存放全局变量（global）与静态变量（static）。</p><ul class="lvl-2"><li class="lvl-4"><code>.data</code>：已经初始化的全局变量与静态变量（initialized）；</li><li class="lvl-4"><code>.bss</code>：未初始化的全局变量与静态变量（uninitialized）。</li></ul></li><li class="lvl-2"><p>Read-only code and data：该部分内容只读。</p><ul class="lvl-2"><li class="lvl-4"><p><code>.text</code>：代码段，即程序的机器代码。</p></li><li class="lvl-4"><p><code>.rodata</code>：只读数据，例如switch中的jump table。</p></li><li class="lvl-4"><p><code>.init</code></p></li></ul></li></ul><h2 id="作用域与生命周期">作用域与生命周期</h2><ul class="lvl-0"><li class="lvl-2"><p>作用域（scope）：从代码空间角度来看，变量在哪个代码段内有效。</p></li><li class="lvl-2"><p>生命周期（duration）：从时间角度来看，变量什么时候被初始化，什么时候被回收。</p></li></ul><h2 id="extern">extern</h2><p>extern是用作变量声明，而不是变量定义。它只是对一个已定义的外部变量作声明，以扩展其作用域。在多个文件的程序中，如果某一个文件想要引用另一个文件中已定义的外部变量，就可以添加外部变量声明（extern）。</p><h2 id="面向过程中的static">面向过程中的static</h2><blockquote><p><strong>全局（global）与局部（local）</strong></p><ul class="lvl-1"><li class="lvl-2"><p>全局即在函数外定义的变量，局部即在函数或语句内部定义的变量。</p></li><li class="lvl-2"><p>全局变量作用域从定义处开始，一直到程序结束；</p><p>局部变量作用域仅限于其所在的函数或语句作用域内。</p></li><li class="lvl-2"><p>全局变量位于程序内存中的静态区域，其在生成可执行目标文件时已经分配完成；</p><p>局部变量位于程序内存中的动态区域，其位于程序栈处。</p></li><li class="lvl-2"><p>全局变量因为在程序开始时就已经分配存储空间，所以<b>必须有初始值</b>。</p><p>如果未显式赋值，则编译器默认置0。</p></li></ul></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 静态局部</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">func</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br>    ...<br>&#125;<br><br><span class="hljs-comment">// 静态全局</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    ...<br>&#125;<br><br><span class="hljs-comment">// 静态函数声明</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>;<br></code></pre></td></tr></table></figure><h3 id="静态全局变量-static-global-var">静态全局变量 static global var</h3><blockquote><p>仅本地有效，其他文件不可见。</p></blockquote><p>全局变量前添加<code>static</code>关键字，即为静态全局变量。</p><h4 id="特性">特性</h4><p>全局变量<b>只能被本文件引用</b>，而不能被其他文件引用。即<b>对其他文件不可见</b>。即使在其他文件中使用<code>extern</code>进行了外部变量声明，仍然无法引用静态全局变量。</p><h4 id="用途">用途</h4><p>避免同名冲突：多人开发时，不同模块/文件之间存在相同的变量名而不会互相影响，提升模块化和通用性，实现解耦。</p><h3 id="静态局部变量-static-local-var">静态局部变量 static local var</h3><blockquote><p>只初始化一次，后续保留上一次计算的原始值。</p></blockquote><p>局部变量前添加<code>static</code>关键字，即为静态局部变量。</p><h4 id="特性-2">特性</h4><ul class="lvl-0"><li class="lvl-2"><p>静态局部变量在程序内存中位于Read/write data部分，其在程序整个运行期间都不释放。</p></li><li class="lvl-2"><p>静态局部变量在<b>编译时即赋予初值</b>，且仅赋初值一次；</p><p>其存储特性意味着它必须拥有初值。如果定义时不赋初值，则编译器自动赋予0或空字符串作为初值。</p></li><li class="lvl-2"><p>尽管静态局部变量所占用的空间在程序运行整个期间都不释放，但其作用域仍然仅限于其所在函数体内。即对其他函数都不可见。</p></li><li class="lvl-2"><p>缺点就是会多占内存，不会及时释放。而且会降低程序可读性。</p></li></ul><h4 id="用途-2">用途</h4><ul class="lvl-0"><li class="lvl-2"><p>希望在函数/语句体内的局部变量的值在函数调用结束后不消失、保留原值，即其占用的存储单元不释放。</p><p>下一次该函数调用时，其初始值保留上一次调用结束时的值。</p></li><li class="lvl-2"><p>变量初始化后只会被引用而不会被修改其值的情况。</p></li></ul><h3 id="静态函数">静态函数</h3><blockquote><p>仅本地可见，其他文件不可见。</p></blockquote><p>函数前添加<code>static</code>关键字，即为静态/内部函数。</p><h4 id="特性-3">特性</h4><p>函数的作用域限定在本文件内，即只能被本文件中的其他函数所调用。其他文件无法对其进行调用。这也意味着不使用static声明的函数都默认为外部函数（和使用extern声明的效果一致），能够被其他文件所调用。</p><h4 id="用途-3">用途</h4><p>使函数局限于文件，在多文件的工程中不用担心同名函数互相干扰。实现多人工程开发的解耦。</p><h2 id="面向对象中的static">面向对象中的static</h2><h3 id="静态成员变量">静态成员变量</h3><blockquote><p>实现数据共享，而不破坏封装性。</p></blockquote><p>在成员变量的声明前加关键字<code>static</code>，即声明为静态数据成员。访问权限私有和公有均可。</p><h4 id="用途-4">用途</h4><p>如果我们想要实现数据共享，希望所有实例中的某个数据成员的值保持一致，就可以将该成员定义为静态数据成员。</p><p>静态数据成员不属于某一个对象，而<b>属于该类</b>。所有该类的对象都共享这些静态数据成员（实现数据共享而不会因为全局变量破坏封装性）。</p><h4 id="引用">引用</h4><p>静态数据成员既可以<b>通过对象引用</b>，也可以<b>通过类名来引用</b>。</p><ul class="lvl-0"><li class="lvl-2"><p>即使未实例化对象，也可以<b>通过类名来引用</b>静态数据成员：<code>数据类型名 类名::静态数据成员</code></p></li><li class="lvl-2"><p>访问控制与其他数据成员一样，遵从同样的规则；</p><p>如果静态数据成员被定义为private，则不能在类外直接引用，必须通过公用的成员函数引用。通常会编写专门引用静态数据成员的静态成员函数。</p></li></ul><h4 id="作用域与生命周期-2">作用域与生命周期</h4><ul class="lvl-0"><li class="lvl-2"><p>生命周期：从程序开始/类声明开始即分配空间，直至程序结束。</p></li><li class="lvl-2"><p>作用域：与类的作用域保持一致。</p></li></ul><p>与之相对的普通数据成员，遵循对象的生命周期，跟随对象的分配与销毁。</p><h4 id="存储">存储</h4><ul class="lvl-0"><li class="lvl-2"><p>在类声明时（还未实例化任何对象）即分配存储空间。</p></li><li class="lvl-2"><p>无论实例多少个对象，静态数据成员在内存中都只占一份空间（属于类而非对象），由所有实例化的对象共享。对象无需为其重新开辟空间。</p></li></ul><h4 id="初始化">初始化</h4><ul class="lvl-0"><li class="lvl-2"><p>静态意味着必须初始化。如果未对静态数据成员赋初值，则编译系统默认为0。</p></li><li class="lvl-2"><p>只能在类体外进行初始化。类体内只能进行声明。</p></li><li class="lvl-2"><p>不能用参数初始化表对静态数据成员进行初始化。</p></li></ul><h3 id="静态成员函数">静态成员函数</h3><blockquote><p>专用于访问静态数据成员。</p></blockquote><p>在成员函数的声明前加关键字<code>static</code>，即声明为静态成员函数。同样的，静态成员函数也是类的一部分，而不属于任何实例化的对象。</p><h4 id="调用">调用</h4><ul class="lvl-0"><li class="lvl-2"><p>公用的静态成员函数可以在类外直接使用类名和域运算符调用：<code>class_name::func_name()</code>。</p></li><li class="lvl-2"><p>也可以通过对象名调用静态成员函数。</p><p>但注意，此时仍然没有指向调用对象的this指针。（无法定位对象的非静态成员。）</p></li></ul><h4 id="用途-5">用途</h4><p>专门为了处理静态数据成员，而非进行数据共享。</p><blockquote><p>养成良好习惯：只用静态成员函数引用静态数据成员，而不引用非静态数据成员。</p></blockquote><h4 id="特点">特点</h4><ul class="lvl-0"><li class="lvl-2"><p>因为静态成员函数属于类，所以<b>没有this指针</b>。</p><p>该特性意味着无法通过this指针访问某一实例的非静态成员。</p><p>如果一定要访问某一实例化对象的非静态成员，则需要加上对象名以及成员运算符<code>.</code>。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>extern</tag>
      
      <tag>static</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集（Union-Find Set）</title>
    <link href="/2022/10/06/%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%88Union-Find-Set%EF%BC%89/"/>
    <url>/2022/10/06/%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%88Union-Find-Set%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>从最直观的角度来看，并查集最典型的使用场景就是 <b>判断元素处于哪个集合中</b>，也就是 <b>元素分组 / 归属 / 连通性</b> 的问题。并查集管理一系列 <b>不相交</b> 的集合，并支持两种主要操作：</p><ul class="lvl-0"><li class="lvl-2">Union 合并：把两个不相交的 <b>集合</b> 合并为一个集合；</li><li class="lvl-2">Find 查询：查询两个元素是否在同一个集合中。</li></ul><p>对于使用森林实现的并查集，存在两个 <b>启发式策略（heuristics）</b>来进行运行时间上的改进：<b>按秩合并（union by rank）</b> 与 <b>路径压缩（path compression）</b>。</p><h2 id="使用场景-5">使用场景</h2><p>并查集的优势在于：同一集合中存在大量元素，且元素之间具有较为复杂的关系组织时，判断元素的归属问题需要过多的资源，而并查集能够在更少的资源下完成这种类型的操作。比如经典的亲戚问题：</p><blockquote><p>若某个家族人员过于庞大，要判断两个人是否为亲戚是一个比较复杂的过程，现在给出某个亲戚关系图，求任意给出的两个人是否具有亲戚关系。</p></blockquote><p>上述类型问题显然非常适合并查集，尤其是经过 <b>路径压缩</b> 的并查集。</p><p>整体来说：</p><ul class="lvl-0"><li class="lvl-2"><p>对于判断 <strong>【集合归属】</strong>、<strong>【无向图的连通性】</strong>、<strong>【确定无向图的连通分量】</strong> 这类问题时，常考虑 <b>并查集</b>。</p></li><li class="lvl-2"><p>与之相反的，关于 <b>有向图之间的（对前驱节点的）依赖性</b>，仍然采用 <b>搜索</b> 以及 拓扑排序（常用于判断是否存在环路）这类方法来解决。</p></li><li class="lvl-2"><p>除此之外，并查集一个常用的使用场景是 <b>Kruskal’s Algorithm</b> 实现 <b>最小生成树</b> 算法。</p></li></ul><h2 id="基本操作-4">基本操作</h2><h3 id="数据结构">数据结构</h3><p>并查集常见实现方式有两种：链表 与 森林。我们通常都采用森林的方式来构建。链表方式的具体实现见算法导论 Ch-21.2。</p><p>并查集森林（有根树）：维护一个游标数组 <code>parent</code>（就开个vector）。数组的值代表其所在下表的父节点的编号。</p><p>即 <code>parent[i] = x</code> 的含义是：节点 $i$ 的父节点编号为 $x$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ufset</span> &#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; parent;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="初始化-2">初始化</h3><p>将每个节点的父节点设置为自己。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">ufset</span>(<span class="hljs-type">int</span> n): <span class="hljs-built_in">parent</span>(n + <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        parent[i] = i;<br>    &#125;<br>    <span class="hljs-comment">// 等价于：itoa(parent.begin(), parent,end(), 0);</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Union">Union</h3><p>Union 的含义就是让两个元素“共属”同一个集合，实际上也代表着两个元素所在的集合的合并。实现方式就是让其中一个元素所在集合的根节点指向另外一个元素的集合根节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>parent[find[x]] = find[y];<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="启发式优化-按秩合并-Union-by-Rank">启发式优化 - 按秩合并 Union by Rank</h4><p>简单的合并方式可能会使整棵树的形状变得不均匀 / 不平衡，使得整棵树退化成接近线性的结构。秩就代表：当前节点为根的树的高度 / 深度。</p><p>一个直接的优化方式就是按秩合并：<b>每次合并都将 深度（秩）较小的集合 挂在 深度（秩）较大的集合下面</b>，即，让拥有较大秩的根 成为 拥有较小秩的根 的父节点。显然，为了得到集合的深度，我们需要增加一个 秩 数组来进行记录。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">private</span>:<br>vector&lt;<span class="hljs-type">int</span>&gt; rank;<span class="hljs-comment">// 初始情况下，深度全部为 1</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-type">int</span> fax = <span class="hljs-built_in">find</span>(x), fay = <span class="hljs-built_in">find</span>(y);<br>    <span class="hljs-keyword">if</span>（fax != fay) &#123;<span class="hljs-comment">// 分别属于两个不同集合，需要合并</span><br>    <span class="hljs-keyword">if</span>(rank[fax] &lt; rank[fay]) &#123;<span class="hljs-comment">// 如果二者秩不同，合并后秩不会发生变化</span><br>        parent[fax] = fay;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            parent[fay] = fax;<br>            <span class="hljs-keyword">if</span>(rank[fax] == rank[fay]) &#123;<span class="hljs-comment">// 如果二者秩相同，作为父节点的节点需要将秩加1</span><br>                rank[fax]++;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Find">Find</h3><p>Find的含义就是找到当前节点所在集合的根节点（父节点为本身的节点就是根节点）。实现方式就是不断向上搜索，递归与循环均可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(x)</span> </span>&#123;<br><span class="hljs-keyword">while</span>(x != parent[x]) &#123;<br>        x = parent[x];<br>    &#125;<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="启发式优化-路径压缩-Path-Compression">启发式优化 - 路径压缩 Path Compression</h4><p>就是降低树的高度。每次进行 <code>find</code> 操作时，使查找路径上的每个节点直接指向根。使得树的高度保持为 1。后续查找效率会大大提升。均摊复杂度可以降低至常数级。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 非递归版本</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-type">int</span> root = x;<br>    <span class="hljs-keyword">while</span>(root != parent[root]) &#123;<span class="hljs-comment">// 第一次循环，确定根节点</span><br>        root = parent[root];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(x != parent[x]) &#123;<span class="hljs-comment">// 第二次循环，路径压缩</span><br>        <span class="hljs-type">int</span> temp = parent[x];<br>        parent[x] = root;<br>        x = temp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><br><span class="hljs-comment">// 递归版本</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(x != parent[x]) &#123;<br>        parent[x] = <span class="hljs-built_in">find</span>(parent[x]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> parent[x];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="判断两点是否属于同一集合">判断两点是否属于同一集合</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isConnected</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x) == <span class="hljs-built_in">find</span>(y);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="效率分析">效率分析</h2><p>这里仅简单给出同时使用 按秩合并 与 路径压缩时 的效率：最坏情况下，运行时间为 $O(m\alpha(n))$。</p><p>其中，$m$ 代表所有操作的总次数，$n$ 代表节点的数量。</p><p>$\alpha(n)$ 是一个增长非常慢的函数，在绝大多数并查集的应用场景下，都有 $\alpha(n) \leq 4$ 。所以可以认定实际运行时间与 $m$ 呈线性关系，或者严格来说是超线性的（superlinear）。</p><p>更多详细的证明与分析见算法导论 Ch-21.4。</p><h2 id="相关题目-11">相关题目</h2><ul class="lvl-0"><li class="lvl-2"><p>684 冗余链接 Redundant Connection (Medium)</p><p>特征：<b>无向图</b> 判断 <b>连通性</b></p><p>查询每条边的两个顶点是否处于同一连通分量。如果已经属于同一连通分量，说明再加一条边会成环。即：</p><ul class="lvl-2"><li class="lvl-4"><p>两个顶点不连通，则加入此边，将两个顶点联通；</p></li><li class="lvl-4"><p>两个顶点已连通，说明不能加入，否则成环。返回答案即可。</p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并查集(Union-Find Set)</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>位运算（Bitwise Operation）</title>
    <link href="/2022/10/02/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <url>/2022/10/02/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<blockquote><p>比较吃技巧，最好临面试前重新熟悉一遍，代码量小，吃思路。</p><p>注意！位运算符的优先级非常低（最值得注意的就是低于<code>==</code>），一定注意加括号。</p></blockquote><p>常用位运算技巧：</p><ol><li class="lvl-3"><p><code>n &amp; (n - 1)</code> : 去除n的位级表示中最低的那一位，即<strong>去除掉最低的那一个1</strong>；该算法常称为Brain Kernighan算法。</p></li><li class="lvl-3"><p><code>n &amp; (-n)</code> : 得到n的位级表示中最低的哪一位，即<strong>保留最后一个1</strong>；</p></li><li class="lvl-3"><p><code>x &amp; 1</code> / <code>x % 2</code> : <strong>获取x的最低位</strong>（掩码操作）。</p></li><li class="lvl-3"><p>异或全1：<strong>翻转二进制位</strong>；</p></li></ol><p>常用的位运算符号有：</p><ul class="lvl-0"><li class="lvl-2"><p><code>^</code> : 按位异或</p><ul class="lvl-2"><li class="lvl-4"><strong>异或全1：翻转二进制位；(LeetCode 476)</strong></li><li class="lvl-4">异或全0：不变；</li><li class="lvl-4">异或本身：全部置0；</li></ul></li><li class="lvl-2"><p><code>&amp;</code> : 按位与</p><ul class="lvl-2"><li class="lvl-4">与全1：不变；</li><li class="lvl-4">与全0：全部置0；</li><li class="lvl-4">与本身：不变；</li></ul></li><li class="lvl-2"><p><code>|</code> : 按位或</p><ul class="lvl-2"><li class="lvl-4">或全1：全部置1；</li><li class="lvl-4">或全0：不变；</li><li class="lvl-4">或本身：不变；</li></ul><p>以上三个为二元操作符，与全0、全1、本身的操作结果要熟记（掩码操作）。</p></li><li class="lvl-2"><p><code>~</code> : 按位取反</p></li><li class="lvl-2"><p><code>&lt;&lt;</code> / <code>&gt;&gt;</code> : 左移与右移，逻辑移位还是算术移位要根据操作数类型来判断。</p></li></ul><hr><h4 id="位运算分治-2">位运算分治</h4><p>即给定一个 $n$ 位二进制数，将其二进制位颠倒。</p><ul class="lvl-0"><li class="lvl-2"><p>190 Reverse Bits 颠倒二进制位 (Easy)</p><ol><li class="lvl-5"><p>解法一：按位颠倒</p></li><li class="lvl-5"><p>解法二：位运算分治</p><p>分而治之，每次都将整个串分成左右两份并颠倒，逻辑如图。自上至下与自下至上的分治均可。每次颠倒利用掩码实现。</p></li></ol></li></ul><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/pics-master/202302271752703.png" style="zoom: 25%;" /><h4 id="位哈希-2">位哈希</h4><ul class="lvl-0"><li class="lvl-2"><p><strong>318 Maximum Product of Word Lengths 最大单词长度乘积 (Medium)</strong></p><p>重点需要优化的操作是：如何判断两个单词不含有公共字母。这里用到位哈希来提升效率。对每个单词使用<strong>位哈希</strong>，即一个整数的26个二进制位分别对应是否存在该字母，则两个不具有公共字母的位哈希相与结果必为0，反之结果不为0；</p></li></ul><h4 id="判断是否为2的幂次方">判断是否为2的幂次方</h4><p>2和4都是基本一个类型，主要是关注二进制位表示的特性：</p><ol><li class="lvl-3"><p>首先注意一个陷阱：只有非负整数满足要求。0与负数均不满足。</p></li><li class="lvl-3"><p>二进制位中只有一个1。这就已经满足了是2的次幂的要求。</p></li><li class="lvl-3"><p>在此基础上，4的次幂中的1一定在偶数次位上（从右起第一个标记为第0位）。</p></li></ol><ul class="lvl-0"><li class="lvl-2"><p>231 Power of Two 2的幂 (Easy)</p><ul class="lvl-2"><li class="lvl-4"><p>解法一：根据二进制位特性判断。</p><p>显然，只需要满足大于0，且去掉最低位的1（<code>n &amp; (n - 1)</code>）后值为0即可。</p></li><li class="lvl-4"><p>解法二：逐位判断。不断除以2，在<code>n == 1</code>前，如果二进制位存在其他的1（即二进制位超过一个1）则表示不满足。</p></li></ul></li><li class="lvl-2"><p>342 Power of Four 4的幂 (Easy)</p><ul class="lvl-2"><li class="lvl-4"><p>解法一：根据二进制位特性判断。</p><p>只需要满足大于0，二进制位只有一个1，且该1在偶数次位上（使用偶/奇数位全1掩码判断）即可。</p></li><li class="lvl-4"><p>解法二：逐位判断。</p></li><li class="lvl-4"><p>解法三：同余定理。4的幂次方模3必余1，2的幂次方如果不是4的幂次方模3余2。</p></li></ul></li></ul><hr><ul class="lvl-0"><li class="lvl-2"><p>461 Hamming Distance 汉明距离 (Easy)</p><p>可以使用内置函数，直接计算二进制表达中1的数量。C++中为<code>__builtin_popcount(x)</code>。</p></li><li class="lvl-2"><p><strong>338 Counting Bits 比特位计数 (Easy)</strong></p><ul class="lvl-2"><li class="lvl-4"><p>解法一：利用位运算统计；</p><p>使用<code>n &amp; (n - 1)</code>的技巧来统计1的个数，该操作复杂度为$O(logn)$，故总体的时间复杂度为<code>O(nlogn)</code>。</p></li><li class="lvl-4"><p>解法二：使用内置函数<code>__builtin_popcount(x)</code>；</p></li><li class="lvl-4"><p>（<b>最优解</b>）解法三：为了实现线性复杂度，使用<strong>动态规划</strong>；</p><p>在使用位运算技巧解题的时候就发现，从小到大1的数量和位置是有一定规律的，联想到使用一维状态转移方程来求解。时间复杂度优化至$O(n)$。令 $dp[i]$ 为 $i$ 二进制位1的个数：<br>$$<br>dp[i] = \begin{cases} dp[i - 1] + 1 &amp;&amp; i \space &amp;&amp;\space 1== 1\<br>dp[i / 2] &amp;&amp; i \space &amp;&amp; \space 1== 0<br>\end{cases}<br>$$</p></li></ul></li><li class="lvl-2"><p>268 Missing Number 丢失的数字 (Easy)</p><ul class="lvl-2"><li class="lvl-4"><p>解法一：给定了$n$，可以通过$\frac{n*(n+1)}{2}$来得到总和，减去数组内的加和即可得到结果；</p></li><li class="lvl-4"><p>解法二：要求线性复杂度（没要求一次扫描，该方法需要两次扫描）+原地，使用位运算技巧来求和；</p><p>第一轮对数组内所有值进行异或，第二轮对$0-n$之间所有值异或，除了缺失的数之外，其他值都出现了两次。</p></li></ul></li><li class="lvl-2"><p>693 Binary Number with Alternating Bits 交替位二进制数 (Easy)</p><p>判断相邻位是否全部相反，显然想到使用异或。交替位二进制数右移一位后异或其本身能够得到低位的全1，再加1后整个二进制表示只有一个1。判断此时二进制位表示是否只有一个1即可。</p><p>$O(1)$ 时间即可完成计算。</p></li><li class="lvl-2"><p><em>476 Number Complement 数字的补数 (Easy)</em></p><p>直接按位求反，会导致高位的0全部变为1，这与题意不符。根据题意，应该定位到数字的最高位1，并从该位置起进行翻转，翻转的方式即为异或二进制全1。</p><p>按照题目中补数的定义，即将二进制位翻转，根据位运算常见技巧，立马反应构造全1的掩码进行异或。从而题目转变为<b>如何构造出不带前导零的指定位数的全1掩码</b>。</p><ul class="lvl-2"><li class="lvl-4"><p>构造方法一：不断构造低位全1掩码，直至掩码大于 $n$；</p></li><li class="lvl-4"><p>构造方法二：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> mask = n;<br>mask |= (mask &gt;&gt; <span class="hljs-number">1</span>);<span class="hljs-comment">// 最高位1向右复制，得到高两位1</span><br>mask |= (mask &gt;&gt; <span class="hljs-number">2</span>);<span class="hljs-comment">// 高两位1向右复制，得到高四位1</span><br>mask |= (mask &gt;&gt; <span class="hljs-number">4</span>);    <span class="hljs-comment">// 高四位1向右复制，得到高八位1</span><br>mask |= (mask &gt;&gt; <span class="hljs-number">8</span>);<span class="hljs-comment">// 高八位1向右复制，得到高十六位1</span><br>mask |= (mask &gt;&gt; <span class="hljs-number">16</span>);<span class="hljs-comment">// 依次类推，如果高位并无1，就相当于无变动</span><br></code></pre></td></tr></table></figure></li></ul></li><li class="lvl-2"><p>136 Single Number 只出现一次的数字 (Easy)</p></li><li class="lvl-2"><p><em>137 Single Number II 只出现一次的数字 (Medium)</em></p><p>题目中每个数字都出现了三次，只有一个例外只出现了一次。</p><ul class="lvl-2"><li class="lvl-4"><p>解法一：按位处理，对从低到高每一位统计数组中元素二进制表示下该位为1的个数，将个数模3即可得到该位答案。</p><p>时间复杂度达到 $O(nlogC)$，其中$C$是数据范围，此处 $logC = 32$。</p></li><li class="lvl-4"><p>解法二：利用<strong>数字电路</strong>中的<strong>状态机</strong>，书写真值表来实现并行处理32个位。具体见题解，不是很复杂的解法。</p></li></ul></li><li class="lvl-2"><p><strong>260 Single Number III 只出现一次的数字 III (Medium)</strong></p><p>题目中每个数字都出现了两次，只有两个例外只出现了一次。</p><ol><li class="lvl-5"><p>首先，根据线性时间复杂度和原地处理的条件可得，使用位运算技巧解题；</p></li><li class="lvl-5"><p>将整个数组异或之后得到的是两个目标值的异或之和，重点考虑如何该结果分开得到两个结果值；</p></li><li class="lvl-5"><p>考虑到136题中的技巧，试图通过<strong>分组</strong>来将题目退化成136题的情况，重点在于如何分组；</p></li><li class="lvl-5"><p>分组的方式为，取异或结果中的<strong>最后一个1</strong>（通过）来区分，那么两个不一样的值必定会分到两个不同的组中，对两组分别进行异或求和即可。</p></li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>位运算(Bitwise Operation)</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图论（Graph）</title>
    <link href="/2022/10/02/%E5%9B%BE-graph/"/>
    <url>/2022/10/02/%E5%9B%BE-graph/</url>
    
    <content type="html"><![CDATA[<h2 id="图的遍历-Traversal-2">图的遍历 Traversal</h2><ul class="lvl-0"><li class="lvl-2">565 Array Nesting 数组嵌套 (Medium)</li></ul><h2 id="拓扑排序-Topological-Sort-2">拓扑排序 Topological Sort</h2><p>拓扑排序就是对有向无环图（Directed Acyclic Graph, DAG）进行排序，其本质还是一个<strong>广度优先搜索</strong>。</p><p>一些性质：</p><ul class="lvl-0"><li class="lvl-2"><p>拓扑序通常不唯一；</p></li><li class="lvl-2"><p>如果图 $G$ 的矩阵为三角矩阵，则该图存在拓扑序。</p><ul class="lvl-2"><li class="lvl-4">反之不能确保成立（必要不充分）。但根据拓扑序重新编号，可使其变为三角矩阵；</li><li class="lvl-4">若为上三角，说明节点为小编号指向大编号；若为下三角，说明节点为大编号指向小编号。</li></ul></li></ul><h3 id="适用情况-4">适用情况</h3><p>常用于处理<strong>有向图中的依赖性问题</strong>（后继依赖前驱），并能够<strong>判断图中是否存在环路</strong>。而对于无向图的连通性问题，更多考虑使用 [并查集](##并查集 Union-find Set)。</p><h3 id="算法实现-2">算法实现</h3><p>具体流程如下：</p><ol><li class="lvl-3"><p>将入度为0的顶点组织到某个线性容器中，常使用队列；</p></li><li class="lvl-3"><p>while 该容器不为空</p><ul class="lvl-2"><li class="lvl-5">弹出队首元素，并按题意做相应处理；</li><li class="lvl-5">队首元素的每个邻接点入度 - 1；如果更新后入度为0，则将该邻接点入队。</li></ul></li><li class="lvl-3"><p>记录输出的的点的个数，如果不等于 $|V|$，说明不存在拓扑序 / 图中存在环路。</p></li></ol><h3 id="DFS实现">DFS实现</h3><p>拓扑排序的实现也可以通过DFS来实现。按照DFS的顺序，我们从一个节点 $u$ 出发，当其能够到达的所有邻接点都访问完毕后，才会重新回溯到节点 $u$。此时我们借助一个栈来记录访问情况，每当重新回溯到节点处时，将其入栈。此时从栈顶往栈底看，$u$ 处在栈顶的位置，$u$ 在其指向的所有相邻节点的前面，即满足 $u$ 的拓扑关系。我们按照这种流程对图进行一遍深度优先搜索。最终栈顶到栈底的序列就是拓扑排序。</p><p>具体实现如下：首先定义每个节点在搜索中的三种状态：</p><ul class="lvl-0"><li class="lvl-2"><p>未搜索：我们还没有搜索到这个节点；</p></li><li class="lvl-2"><p>搜索中：我们搜索过这个节点，但还没有回溯到该节点，即该节点还没有入栈，还有相邻的节点没有搜索完成）；</p></li><li class="lvl-2"><p>已完成：我们搜索过并且回溯过这个节点，即该节点已经入栈，并且所有该节点的相邻节点都出现在栈的更底部的位置，满足拓扑排序的要求。</p></li></ul><p>通过上述的三种状态，我们就可以给出使用深度优先搜索得到拓扑排序的算法流程，在每一轮的搜索搜索开始时，我们任取一个「未搜索」的节点开始进行深度优先搜索。</p><ul class="lvl-0"><li class="lvl-2"><p>我们将当前搜索的节点 $u$ 标记为「搜索中」，遍历该节点的每一个相邻节点 $v$：</p><ul class="lvl-2"><li class="lvl-4">如果 $v$ 为「未搜索」，那么我们开始搜索 $v$，待搜索完成回溯到 $u$；</li><li class="lvl-4">如果 $v$ 为「搜索中」，那么我们就找到了图中的一个环，因此是不存在拓扑排序的；</li><li class="lvl-4">如果 $v$ 为「已完成」，那么说明 $v$ 已经在栈中了，而 $u$ 还不在栈中，因此 $u$ 无论何时入栈都不会影响到 $(u, v)$ 之前的拓扑关系，以及不用进行任何操作。</li></ul></li><li class="lvl-2"><p>当 $u$ 的所有相邻节点都为「已完成」时，我们将 $u$ 放入栈中，并将其标记为「已完成」。</p></li></ul><p>在整个深度优先搜索的过程结束后，如果我们没有找到图中的环，那么栈中存储这所有的 $n$ 个节点，从栈顶到栈底的顺序即为一种拓扑排序。</p><h3 id="效率-3">效率</h3><ul class="lvl-0"><li class="lvl-2"><p>使用邻接表：每个节点输出一次 $O(V)$，每个边处理一次 $O(E)$，总时间复杂度为 $O(V+E)$。</p></li><li class="lvl-2"><p>使用邻接矩阵：因为处理边时需要遍历矩阵的一行，所以相当于内层循环也为 $O(V)$，总时间复杂度为 $O(V^2)$。</p></li></ul><h3 id="相关题目-8">相关题目</h3><ul class="lvl-0"><li class="lvl-2"><p>210 Course Schedule II 课程表 II (Medium)</p></li><li class="lvl-2"><p>剑指Offer II 114. 外星文字典 (Hard)</p><p>重点在于思路和建图。</p></li><li class="lvl-2"><p><a href="http://algorithm.openjudge.cn/2022hw2/solution/36786354/">POJ Genealogical Tree</a></p></li></ul><h2 id="二分图-Bipartite-Graph-2">二分图 Bipartite Graph</h2><blockquote><p>二分图的定义：图中所有顶点可以分割为两个子集合，图中所有边的两个顶点来自于不同的集合，即同一集合中的任意两点之间没有边。</p><p>二分图是图论中一个比较经典的问题，对于其判定除了常见的染色法还有其他的做法待补充（对面试作用不大）。</p><p><a href="https://blog.csdn.net/qq_26822029/article/details/90382581">(17条消息) 二部图（二分图）总结_哆啦A瑶的博客-CSDN博客_二分图</a></p></blockquote><p>通常使用<strong>染色法</strong>解决二分图问题：</p><p>用深搜或广搜从任意一个节点开始，对其相邻节点上与当前节点不同的颜色，如果其任一相邻节点已经染过色且与当前节点颜色相同，那么该图无法被二分。</p><p>节点的颜色状态数组同时也起到了访问数组的作用，能够提供当前节点是否被访问过的信息。</p><ul class="lvl-0"><li class="lvl-2"><p>785 Is Graph Bipartite? 判断二分图 (Medium)</p><p>染色法，通过 深度优先遍历 或 广度优先遍历 均可实现。</p></li><li class="lvl-2"><p><a href="http://algorithm.openjudge.cn/2022hw2/solution/36536600/">POJ Butterfly</a></p></li></ul><h2 id="欧拉通路-回路-2">欧拉通路/回路</h2><p>简单的来讲，就是<strong>图的遍历</strong> + <strong>栈</strong>，要注意的点是</p><ol><li class="lvl-3"><p>删去边：每次访问都要删去当前访问的边；</p></li><li class="lvl-3"><p>何时入栈：通常选择出度已经为0（边已经删干净的）；</p></li><li class="lvl-3"><p>栈存放结果：最终的实际结果往往要把栈倒转过来。</p></li></ol><h3 id="算法原理">算法原理</h3><p>即给定一个起点的<strong>一笔画</strong>问题。</p><h4 id="1-定义-2">1 定义</h4><ul class="lvl-0"><li class="lvl-2"><p>通过图中所有边恰好一次且行遍所有顶点的通路称为欧拉通路。</p></li><li class="lvl-2"><p>通过图中所有边恰好一次且行遍所有顶点的回路称为欧拉回路。</p></li><li class="lvl-2"><p>具有欧拉回路的无向图称为欧拉图。</p></li><li class="lvl-2"><p>具有欧拉通路但不具有欧拉回路的无向图称为半欧拉图。</p></li></ul><h4 id="2-判断-2">2 判断</h4><p>如果没有保证至少存在一种合理的路径，我们需要判别这张图是否是欧拉图或者半欧拉图，具体地：</p><ul class="lvl-0"><li class="lvl-2"><p>对于无向图 G：</p><ul class="lvl-2"><li class="lvl-4"><p>G 是欧拉图当且仅当 G 是连通的且没有奇度顶点。</p></li><li class="lvl-4"><p>G 是半欧拉图当且仅当 G 是连通的且 G 中恰有 2 个奇度顶点。</p></li></ul></li><li class="lvl-2"><p>对于有向图 G</p><ul class="lvl-2"><li class="lvl-4"><p>G 是欧拉图当且仅当 G 的所有顶点属于同一个强连通分量且每个顶点的入度和出度相同。</p></li><li class="lvl-4"><p>G 是半欧拉图当且仅当 G 的所有顶点属于同一个强连通分量且：</p><ul class="lvl-4"><li class="lvl-6">恰有一个顶点的出度与入度差为 1；</li><li class="lvl-6">恰有一个顶点的入度与出度差为 1；</li><li class="lvl-6">所有其他顶点的入度和出度相同。</li></ul></li></ul></li></ul><p>判断及证明放到离散数学/算法导论中具体了解。</p><h4 id="3-求解-2">3 求解</h4><p><strong>Heirholzer算法</strong>：</p><ol><li class="lvl-3"><p>从起点出发，进行深度优先搜索；</p></li><li class="lvl-3"><p>每次沿着某条边从某个顶点移动到另外一个顶点的时候，都需要删除这条边；</p></li><li class="lvl-3"><p>如果没有可移动的路径，则将所在节点加入到栈中，并返回。</p></li></ol><h3 id="相关题目-9">相关题目</h3><ul class="lvl-0"><li class="lvl-2"><p><em>332 Reconstruct Itinerary 重新安排行程 (Hard)</em></p><ul class="lvl-2"><li class="lvl-4"><strong>多重</strong>映射 来记录多个可能的终点，本质其实是一个<em>图</em>的遍历/搜索</li><li class="lvl-4">欧拉回路/通路问题 (DFS)</li></ul></li><li class="lvl-2"><p>753 Cracking the Safe 破解保险箱 (Hard)</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>拓扑排序(Topological Sort)</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Debugging</title>
    <link href="/2022/09/30/Debugging-gdb-valgrind/"/>
    <url>/2022/09/30/Debugging-gdb-valgrind/</url>
    
    <content type="html"><![CDATA[<p>三种常见的 Debug 方式</p><ul class="lvl-0"><li class="lvl-2"><p>Code Tracing: 使用 <code>printf()</code> 输出部分变量值；</p></li><li class="lvl-2"><p>Valgrind: <code>malloc</code> / <code>free</code> bug</p><p>内存分配检测</p></li><li class="lvl-2"><p>GDB: Everything else</p></li></ul><h2 id="Code-Tracing">Code Tracing</h2><p>做题的时候常用，用于在某个阶段查看变量的值，与期望值对比来确定算法有没有正确运行。符合直觉，无需多说。</p><h3 id="When-to-Use">When to Use</h3><ul class="lvl-0"><li class="lvl-2"><p>Easy and relatively simple code</p><p>刷题这种小型、只关注结果的代码；</p></li><li class="lvl-2"><p>Tracing conditional paths in an if statement</p><p>便于检查在分支语句中的走向</p></li></ul><h2 id="Valgrind">Valgrind</h2><p>内存检测利器。Tool for debugging, memory leak detection and profiling.</p><h3 id="When-to-Use-2">When to Use</h3><ul class="lvl-0"><li class="lvl-2"><p>Dealing with <b>memory</b></p><p>especially <b>dynamic memory allocation</b></p></li><li class="lvl-2"><p>Whenever bugs occur, get instant feedback about what the bug is, where it occurred, and why.</p><p>即时反馈 bug 及其发生的位置与原因。</p></li></ul><h3 id="When-Not-to-Use">When Not to Use</h3><ul class="lvl-0"><li class="lvl-2"><p>程序本不会存在内存相关的问题：不存在 <b>无效的读写</b>，也不可能有<b>内存泄漏</b>。</p></li><li class="lvl-2"><p>If the test case is inherently slow, then this is not a good choice.</p><p>程序本身速度慢的情况下尽量避免使用。</p></li></ul><h3 id="How-to-Use">How to Use</h3><div class="tips"><p>Always remember about the man page: <code>man valgrind</code></p></div><h3 id="Memory-Problem">Memory Problem</h3><p>首先我们分析一下产生内存相关问题的原因。总的来说可以分为两大类：无效读写（Invalid reads and writes） 与 内存泄漏（Memory Leaks）。</p><h4 id="Invalid-Reads-and-Writes-无效读写">Invalid Reads and Writes 无效读写</h4><p>无效的读写 顾名思义，即读到不该读的或写入位置的区域，常见分以下几种情况：</p><ul class="lvl-0"><li class="lvl-2"><p>读 已经被释放的变量 Reading freed variables</p></li><li class="lvl-2"><p>读 未初始化的变量 Reading uninitialized variables</p></li><li class="lvl-2"><p>写 未分配的内存 / 地址空间 Writing to uninitialized memory</p><p>Caused by writing to much data  to allocated memory</p><p>比如数组越界。</p></li></ul><p>无效读写在 Valgrind 中的输出：</p><ul class="lvl-0"><li class="lvl-2"><p>Invalid read of size n</p></li><li class="lvl-2"><p>HEAP SUMMARY</p></li><li class="lvl-2"><p>…</p></li></ul><h4 id="Memory-Leaks-内存泄漏">Memory Leaks 内存泄漏</h4><ul class="lvl-0"><li class="lvl-2"><p>内存空间使用后忘记释放，该块空间无法被其他进程所合理使用，即为内存泄露。</p><p>Forgetting to free memory after using it.</p></li><li class="lvl-2"><p>主动申请（<code>malloc</code>）的内存空间在用完之后都应该主动释放（<code>free</code>）。</p><p>Memory that is allocated by a programmer should <b>always</b> be freed.</p></li></ul><p>Types of Memory Leaks:</p><ul class="lvl-0"><li class="lvl-2"><p><b>difinitely lost</b> 一定泄露</p><p>不存在指向该部分内存块的指针。</p><p>No pointer to the block can be found.</p></li><li class="lvl-2"><p><b>indirectly lost</b> 间接泄露</p><p>指针本身所在的内存块泄露，其指向的内存部分即为 indirectly lost。</p><p>Block is “lost” because the blocks themselves that point to it are lost.</p></li><li class="lvl-2"><p><b>possibly lost</b> 可能泄露</p><p>存在指针，但该指针指向了内部部分（internal part）</p><p>Pointer exists but it points to an internal part of the memory block.</p></li><li class="lvl-2"><p><b>still reachable</b> 可达的</p><p>存在指针，仍然可以通过该指针来释放该部分内存空间</p><p>Block is still pointed at, programmer could go back and free it before exiting.</p></li></ul><p>内存泄漏在 Valgrind 中的输出：</p><ul class="lvl-0"><li class="lvl-2"><p>HEAP SUMMARY</p></li><li class="lvl-2"><p>LEAK SUMMARY</p></li></ul><h2 id="GDB">GDB</h2><p><a href="https://sourceware.org/gdb/current/onlinedocs/gdb/">Top (Debugging with GDB) (sourceware.org)</a></p><p>GNU Debugger</p><ul class="lvl-0"><li class="lvl-2"><p>Powerful debugger that lets you inspect your program as it’s executing</p></li><li class="lvl-2"><p>Allows you to see what is going on ‘inside’  another program</p></li><li class="lvl-2"><p>Breaks abstraction between program and machine</p></li></ul><h3 id="When-to-Use-3">When to Use</h3><p>Always super useful.</p><ul class="lvl-0"><li class="lvl-2"><p><i>Complicated</i> code that you need to step through</p></li><li class="lvl-2"><p>Need to find values at specific points</p></li><li class="lvl-2"><p>Valgrind was not helpful</p></li><li class="lvl-2"><p>To inspect machine state</p></li></ul><h3 id="How-to-Use-2">How to Use</h3><h4 id="前提">前提</h4><p>gcc编译时使用<code>-g</code> flag后才能通过gdb进行调试。</p><h4 id="基本操作-3">基本操作</h4><ul class="lvl-0"><li class="lvl-2"><p><code>run</code>：运行程序</p></li><li class="lvl-2"><p><code>CTRL + C</code>：停止执行</p></li></ul><h4 id="单步测试-next-step">单步测试 next &amp; step</h4><ul class="lvl-0"><li class="lvl-2"><p><code>next</code> / <code>n</code> 逐行执行语句，不会进入函数，跳过函数</p><p><code>next X</code> / <code>n X</code> 执行接下来 X 行语句</p><p><code>nexti</code> 逐行执行汇编语句，且不会进入函数</p><p>run next line of program and does NOT step into functions</p><p>执行完next语句后出现的代码行表示下一次next即将执行的代码，即当前还未执行该行。</p></li><li class="lvl-2"><p><code>step</code> 逐行执行语句，遇到函数时，进入函数运行</p><p><code>step X</code> / <code>s X</code> 执行接下来 X 行语句</p><p><code>stepi</code> 逐行执行汇编语句，遇到函数时，进入函数运行</p></li></ul><h4 id="跟踪变量">跟踪变量</h4><ul class="lvl-0"><li class="lvl-2"><p><code>display [var]</code> : display the variable value at every command we run</p><p><code>undisplay id</code>：不能直接用变量名来undisplay，而是要使用display number</p></li><li class="lvl-2"><p><code>whatis [var]</code> / <code>what [var]</code></p></li></ul><h4 id="继续-恢复执行">继续/恢复执行</h4><ul class="lvl-0"><li class="lvl-2"><p><code>finish</code> 运行程序，直到当前函数完成时返回。同时打印函数返回时的对战地址和返回值以及参数值等信息</p></li><li class="lvl-2"><p><code>continue</code> 恢复程序运行，直到 程序结束 或者 遇到断点 或者 遇到错误。</p><p>可以增加参数 <code>ignore-count</code>，<code>continue ignore-count</code> 代表忽略其后的断点次数。</p></li></ul><h4 id="查看源代码与汇编代码">查看源代码与汇编代码</h4><ul class="lvl-0"><li class="lvl-2"><p><code>disassemble</code> / <code>disas</code> 将源代码反汇编为汇编代码</p></li><li class="lvl-2"><p><code>list</code> / <code>l</code> 从当前行起，读出接下来10行源代码</p><p><code>list X</code> / <code>l X</code> 从第 X 行开始，读出接下来10行源代码</p><p><code>list funcName</code> / <code>l funcName</code> 从 <code>funcName</code> 函数中读取出10行源代码</p></li></ul><h4 id="断点-Breakpoints">断点 Breakpoints</h4><blockquote><p>断点：任何时候遇到断点，程序就会停止。<br>A breakpoint makes your program stop whenever a certain point in the program is reached.</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p><code>break func_name</code> / <code>b func_name</code>: 设置关于 “func_name” 函数的断点。</p><p>调用 “func_name” 函数时，触发断点。</p><p>breaks once you call a specific function. (break abbreviated b)</p></li><li class="lvl-2"><p><code>break *0x…</code>: 设置指定地址处的断点。</p><p>“*0x…” 代表地址，即在执行该地址处指令时跳转？</p><p>breaks when you execute instruction at a certain address</p></li><li class="lvl-2"><p><code>info breakpoints</code> /<code>info b</code>: 展示当前设置的所有断点的信息</p><p>displays information about all breakpoints currently set</p><p>info指令可以展示多种内容，这里只介绍了断点一种。</p></li><li class="lvl-2"><p><code>disable #no</code>: 关闭 ID 为 # 号的断点。</p><p>disables breakpoint with ID equal to #</p><p><code>disable</code> 的缩写是 <code>$disa</code> ，区分与 <code>$disas</code></p></li><li class="lvl-2"><p><code>clear [location]</code>: 删除在 location 处的断点</p><p>例如 <code>clear main</code>: 删除 main 函数中的断点</p><p>delete breakpoints according to where they are in your program.</p></li></ul><h4 id="观察点-Watchpoints">观察点 Watchpoints</h4><blockquote><p>观察点：一种特殊的断点。当表达式中的值发生改变时，程序停止。这里的表达式内容可以是 一个变量的值，也可以是用运算符组合的值。<br>A special breakpoint that stops your program when the value of an expression changes.<br>The expression may be a value of a variable, or involve values combined by operators.</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p><code>watch var</code>: 设置一个关于变量 foo 的观察点。</p><p>观察变量 foo 的值的变化，有变化时程序停止。</p><p>watch the value of a single variable</p></li><li class="lvl-2"><p><code>watch *(int *)0x600850</code> : 设置某一指定地址的观察点。</p><p>当指定地址处的值发生变化，触发观察点，程序停止。（注意指明正确的数据类型）</p><p>watch for a change in a numerically entered address</p></li><li class="lvl-2"><p><code>delete [watchpoint/breakpoint]</code> / <code>d</code>: 删除指定编号（而非名字）的断点（breakpoint）或观察点（watchpoint）</p><p>如果后面没接任何参数，则删除所有的断点与观察点。</p></li></ul><h4 id="打印值-Print-Values">打印值 Print Values</h4><p><code>print [any valid expression]</code> / <code>p</code>: 输出参数指定处的值。</p><p>参数可以是某个表达式的值，亦可以是某个显式指定的地址（注意指明正确的数据类型）。</p><ul class="lvl-0"><li class="lvl-2"><p><code>print expr</code> : 输出表达式的值；</p></li><li class="lvl-2"><p><code>print *ptr</code> : 输出指针变量的值；</p></li><li class="lvl-2"><p><code>print *(struct_t*) tmp</code> : 将 tmp 的值以 “struct_t*” 的类型输出。如果 tmp 本身不是该类型，进行强制转换。</p></li></ul><h4 id="查看内存信息-Inspecting-Memory">查看内存信息 Inspecting Memory</h4><p><code>x/nfu [memory address]</code>: 使用 “x” 命令来打印内存的值,格式为“<code>x/nfu addr</code>”。</p><p>等价于 <code>print *(addr)</code></p><p>含义为以<code>f</code>格式打印从<code>addr</code>开始的<code>n</code>个长度单元为<code>u</code>的内存值。参数具体含义如下：</p><ul class="lvl-0"><li class="lvl-2"><p>n：输出单元的个数。</p></li><li class="lvl-2"><p>f：是输出格式；</p><ul class="lvl-2"><li class="lvl-4">n: 下 n 个单位内存，即输出单元的个数；</li><li class="lvl-4">f (format): 定义输出格式<ul class="lvl-4"><li class="lvl-6">d: decimal</li><li class="lvl-6">x: hexadecimal</li><li class="lvl-6">s: string</li></ul></li><li class="lvl-4">u (unit): 定义输出单元大小；<ul class="lvl-4"><li class="lvl-6">b: bytes</li><li class="lvl-6">h: half word / 2 bytes</li><li class="lvl-6">w: word / 4 bytes</li><li class="lvl-6">g: giant word / 8 bytes</li></ul></li></ul></li><li class="lvl-2"><p>u：标明一个单元的长度。<code>b</code>是一个<code>byte</code>，<code>h</code>是两个<code>byte</code>（halfword），<code>w</code>是四个<code>byte</code>（word），<code>g</code>是八个<code>byte</code>（giant word）。</p></li></ul><h4 id="Backtrace-查看函数栈帧">Backtrace 查看函数栈帧</h4><blockquote><p><b>Backtrace</b> see previous function calls.</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p><code>backtrace</code> / <code>bt</code>: 打印程序运行到当前状态的历史状态信息</p><p>prints a summary of how program got where it is / 输出整个call stack（运行时栈）</p><ul class="lvl-2"><li class="lvl-4"><p>到该点处调用的函数序列 Print sequence of function calls that led to this point</p></li><li class="lvl-4"><p>确认程序崩溃原因的时候很有用 Helpful to use when programs crash</p></li></ul></li><li class="lvl-2"><p><code>up N</code> / <code>u N</code>: go up N function calls 向上查看栈帧 / 即查看向上的调用者</p><p>Select and print stack frame that called this one.</p><p>An argument says how many frames up to go.</p></li><li class="lvl-2"><p><code>down N</code> / <code>d N</code>: go down N function calls. 向下查看栈帧 / 即查看被当前函数调用的函数</p><p>Select and print stack frame called by this one.</p><p>An argument says how many frames down to go.</p></li></ul><h4 id="Calling-Functions">Calling Functions</h4><p>Calling your program’s functions.</p><p><code>call expr</code>: Evaluate the expression expr without displaying void returned values.</p><h4 id="Changing-Values">Changing Values</h4><ul class="lvl-0"><li class="lvl-2"><p><code>set [variable] expr</code>: change the value associated with a variable, memory  address, or expression</p></li></ul><p>Evaluates the specified expression. If the expression includes the assignment operator (“=”), that operator will be evaluated and the assignment will be done.</p><p>The only difference between <i>the set variable</i> and <i>the print commands</i> is <b>printing the value</b>.</p><ul class="lvl-0"><li class="lvl-2"><p><code>target record-full</code></p></li><li class="lvl-2"><p><code>reverse-next</code> / <code>rn</code></p><p><code>reverse-step</code></p><p><code>reverse-continue</code></p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Valgrind</tag>
      
      <tag>gdb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译系统（Compilation System）</title>
    <link href="/2022/09/27/%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F-Compilation-System/"/>
    <url>/2022/09/27/%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F-Compilation-System/</url>
    
    <content type="html"><![CDATA[<h2 id="编译系统-Compilation-System">编译系统 Compilation System</h2><p>Four steps for C compiling:</p><p><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/pics-master/202209271418428.png" alt=""></p><h3 id="Preprocessing-Pre-Processor-预处理">Preprocessing - Pre-Processor 预处理</h3><blockquote><p>Unique to the C family. C语言特有，别的语言大都没有。</p></blockquote><h4 id="处理">处理</h4><ul class="lvl-0"><li class="lvl-2"><p>处理头文件（<code>#include</code> ） Combines main source file with headers (textually)</p><p>头文件此时只是文本上（textually）的直接插入。</p></li><li class="lvl-2"><p>处理宏定义（如 <code>#define</code>） Defines and expands macros (token-based shorthand)</p><p>把宏定义/别名（macros）嵌入/替换到代码中。</p></li><li class="lvl-2"><p>处理可能被移除的部分（如 <code>#if</code>） Conditionally removes parts of the code (e.g. specialize for Linux, Mac, …)</p></li><li class="lvl-2"><p>除掉代码中的注释部分</p></li></ul><h4 id="输出">输出</h4><p>仍基本类似于 C code 本身。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -E [flags][filenames]<br><span class="hljs-meta prompt_"># </span><span class="language-bash">preprocess only; <span class="hljs-keyword">do</span> not compile, assemble or <span class="hljs-built_in">link</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">该命令不会生成对应的中间文件，而是输出经过预处理后的代码文本。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果不进行重定向，结果会直接在shell中输出。</span><br></code></pre></td></tr></table></figure><p>使用 <code>gcc -E</code> 重定向保存此时的代码结果，对应上面的内容，能够发现：</p><ul class="lvl-0"><li class="lvl-2"><p>开头部分非常多的头文件相关内容的插入；</p></li><li class="lvl-2"><p>实际代码位于最末部分；</p></li><li class="lvl-2"><p>原注释被除去，会插入一些新的编译器注释；</p></li><li class="lvl-2"><p>宏定义的值被嵌入。</p><p>无论是本文件中的宏定义还是头文件中的宏定义，都会被扩展为实际值。</p></li></ul><h3 id="Compiling-Compiler-编译">Compiling - Compiler 编译</h3><h4 id="处理-2">处理</h4><p>即高级语言翻译成汇编语言。</p><ul class="lvl-0"><li class="lvl-2"><p>改变语言，但保留语义 changes the format and structure of the code but preserves the semantics (what it does)</p></li><li class="lvl-2"><p>会存在性能上的一些优化，即语义不是完全一比一转变，但整体效果一致 can change lots of details for optimization(in terms of performance), as long as the overall effect is the same</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -S [flags][filenames]<br><span class="hljs-meta prompt_"># </span><span class="language-bash">compile only; <span class="hljs-keyword">do</span> not assemble or <span class="hljs-built_in">link</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">输出为 .s 汇编代码</span><br></code></pre></td></tr></table></figure><h4 id="输出-2">输出</h4><p>输出为 .s 汇编代码。其中所有以 ‘.’ 为开头的行都是指导 Assembler 和 Linker 工作的伪指令，分析时通常可以直接忽略。</p><h3 id="Assembling-Assembler-汇编">Assembling - Assembler 汇编</h3><p>全部转化为二进制比特位。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -c [flags][filenames]<br><span class="hljs-meta prompt_"># </span><span class="language-bash">compile and assemble, but <span class="hljs-keyword">do</span> not <span class="hljs-built_in">link</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">文件可以是 .c，也可以是 .o</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">输出为 .o</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">输出的 .o 是二进制文件，无法直接查看，需要借助 objdump</span><br>objdump -d [filenames]<br><span class="hljs-meta prompt_"># </span><span class="language-bash">-d: Display assembler contents of executable sections</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">objdump = display information from object files</span><br></code></pre></td></tr></table></figure><h3 id="Linking-Linker-链接">Linking - Linker 链接</h3><blockquote><p>合并，最后出来一个文件</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -o [exename][flags]&lt;filenames&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">place the output into &lt;filenames&gt;</span><br></code></pre></td></tr></table></figure><h2 id="编译器驱动程序-Compiler-Driver">编译器驱动程序 Compiler Driver</h2><p>例如GCC，按需调用编译系统中的不同组件（preprocessor、compiler、assembler、linker）。</p><p>一个C语言实例如图：</p><p><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/pics-master/202302251900581.png" alt=""></p><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/pics-master/202302251901186.png" style="zoom: 33%;" /><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -Og -o prog main.c sum.c<br></code></pre></td></tr></table></figure><p>整体流程：<code>.c</code>  — <code>.i</code> — <code>.s</code> — <code>.o</code> — executable object file。</p><h3 id="C-preprocessor-cpp">C preprocessor - <code>cpp</code></h3><p>将C的源文件（<code>.c</code>）翻译成ASCII码的中间文件（<code>.i</code>）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cpp [other arguments] main.c /tmp/main.i<br>cpp [other arguments] sum.c /tmp/sum.i<br></code></pre></td></tr></table></figure><h3 id="C-compiler-cc1">C compiler - <code>cc1</code></h3><p>将中间文件·<code>.i</code>翻译成ASCII汇编语言文件（<code>.s</code>）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cc1 /tmp/main.i -Og [other arguments] -o /tmp/main.s<br></code></pre></td></tr></table></figure><h3 id="Assembler-as">Assembler - <code>as</code></h3><p>将汇编文件（<code>.s</code>）翻译为一个可重定位目标文件（relocatable object file，<code>.o</code>）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">as [other arguments] -o /tmp/main.o /tmp/main.s<br></code></pre></td></tr></table></figure><h3 id="Linker-ld">Linker - <code>ld</code></h3><p>将所有<code>.o</code>文件以及一些必要的系统目标文件组合起来，创建出<b>可执行目标文件（executable object file）</b>。</p><h3 id="Loader">Loader - <code>./</code></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./prog<br></code></pre></td></tr></table></figure><p>shell调用操作系统中一个叫做加载器（loader）的函数：</p><ul class="lvl-0"><li class="lvl-2"><p>将可执行文件<code>prog</code>中的代码和数据复制到内存；</p></li><li class="lvl-2"><p>将控制转移至该程序的开头。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>编译器(Compiler)</tag>
      
      <tag>汇编器(Assembler)</tag>
      
      <tag>链接器(Linker)</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉搜索树 Binary Search Tree</title>
    <link href="/2022/09/15/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <url>/2022/09/15/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1>二叉搜索树 BST</h1><h2 id="基本操作-CRUD-2">基本操作 CRUD</h2><blockquote><ul class="lvl-1"><li class="lvl-2"><p>查找：递归实现</p></li><li class="lvl-2"><p>插入：查找失败的位置就是插入的位置</p></li><li class="lvl-2"><p><em>删除</em>：递归，分情况处理</p><ul class="lvl-3"><li class="lvl-4"><p>当前节点值大于待删值，递归向左进入左子树进行删除；</p></li><li class="lvl-4"><p>当前节点值小于待删值，递归向右进入右子树进行删除；</p></li><li class="lvl-4"><p>当前节点即为待删节点：</p><ul class="lvl-5"><li class="lvl-6"><p>被删除节点为叶节点：直接删除，返回<code>nullptr</code>;</p></li><li class="lvl-6"><p>被删除节点仅有一个儿子：直接将其儿子拉上来代替即可；</p></li><li class="lvl-6"><p>被删除节点有两个儿子：取<strong>中序前驱</strong>或<strong>中序后继</strong>来代替，转化为删除这两个节点，退化为前两种情况处理。</p><p>中序前驱：左儿子的最右节点；</p><p>中序后继：右儿子的最左节点。</p></li></ul></li></ul></li></ul><p>删除操作比较重要，BST的基本操作都没有考虑树的结构（一般都在AVL中考虑），实际使用也可以增加对树高平衡的控制。</p></blockquote><ul class="lvl-0"><li class="lvl-3"><p><strong>450 Delete Node in a BST 删除二叉搜索树中的节点 (Medium)</strong></p></li></ul><h2 id="特性-中序序列有序-2">特性 - 中序序列有序</h2><ul class="lvl-0"><li class="lvl-2"><p>99 Recover Binary Search Tree 恢复二叉搜索树 (Medium)</p><p>利用二叉搜索树中序遍历有序的特性来进行恢复</p></li><li class="lvl-2"><p>669 Trim a Binary Search Tree 修剪二叉搜索树 (Easy)</p><p>利用递归实现</p></li><li class="lvl-2"><p>235 Lowest Common Ancestor of a Binary Search Tree 二叉搜索树的最近公共祖先 (Medium)</p><p>重点在于理解其从根节点向下到第一个分叉节点即为两个节点的公共祖先。</p><p>对于BST来说，从根节点开始第一个值大小在二者之间的即为其分叉点。</p><p>鉴于树的相同子结构，递归和非递归算法均可实现。</p></li><li class="lvl-2"><p>538 Convert BST to Greater Tree 把二叉搜索树转换为累加树 (Medium)</p><p>不要因为前中后序遍历而陷入思维定势，这道题就巧妙的利用了逆中序遍历实现了“右根左”的访问顺序。</p><p>同时这道题涉及到BST的性质：中序遍历为有序序列，显然其逆中序遍历序列仍为有序，只是递增和递减的区别。</p></li><li class="lvl-2"><p>108 Convert Sorted Array to Binary Search Tree 将有序数组转换为二叉搜索树 (Easy)</p></li><li class="lvl-2"><p>109 Convert Sorted List to Binary Search Tree 有序链表转换为二叉搜索树 (Medium)</p><ul class="lvl-2"><li class="lvl-4"><p>解法一：将链表转换为有序数组，退化为108</p></li><li class="lvl-4"><p>解法二：题目的重点在于二分，链表的特性则难以随机寻找重点，这里用快慢指针进行查找</p><p>时间复杂度必然提升（搜索中点），空间复杂度得以下降</p></li><li class="lvl-4"><p>解法三：利用BST中序遍历有序的特性，有序序列必定对应一颗二叉搜索树的中序，所以我们先按照元素个数对树进行一个保持平衡的构建，并按照中序顺序有序的填入值。</p><blockquote><p><em>重点</em>：注意递归参数中的指针</p><p>如果在递归体中某一个指针参数变量本身的值会被改变，务必使用<em>引用</em>！</p><p>这才能确保其值是能够正确的向下传递并向上返回！</p><p>理解指针的实质，也是一个变量，如果只修改指针指向的内容而非指针本身，则无需使用引用。</p></blockquote></li></ul></li><li class="lvl-2"><p>897 Increasing Order Search Tree 递增顺序搜索树 (Easy)</p></li><li class="lvl-2"><p>653 Two Sum IV - Input is a BST 两数之和 IV - 输入BST (Easy)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉搜索树（BST）</tag>
      
      <tag>平衡二叉树（AVL）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串（String）</title>
    <link href="/2022/09/02/%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88String%EF%BC%89/"/>
    <url>/2022/09/02/%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88String%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="字符串-String-2">字符串 String</h2><h3 id="基础-3">基础</h3><ul class="lvl-0"><li class="lvl-2"><p>242 Valid Anagram 有效的字母异位词 (Easy)</p><ul class="lvl-2"><li class="lvl-4">其实是个<strong>哈希表</strong>的题目</li></ul></li><li class="lvl-2"><p>205 Isomorphic Strings 同构字符串 (Easy)</p><ul class="lvl-2"><li class="lvl-4">其实还是个<strong>哈希表</strong>的题目。</li><li class="lvl-4">有点小坑，要同时利用两个哈希表。</li></ul></li><li class="lvl-2"><p>696 Count Binary Substrings 计数二进制子串 (Easy)</p><p>思路题：重点在于子串中的0和1是成组连续的，所以每当子串中的字符发生变换时，就可以对子串数进行统计。</p></li><li class="lvl-2"><p>409 Longest Palindrome 最长回文串 (Easy)</p><ul class="lvl-2"><li class="lvl-4">其实又是一个<strong>哈希表</strong>的题目。</li></ul></li><li class="lvl-2"><p>2278 Percentage of Letter in String 字母在字符串中的百分比 (Easy)</p><p>简单模拟</p></li><li class="lvl-2"><p>2296 Design a Text Editor 设计一个文本编辑器 (Hard)</p><p>数据结构设计题，详见<a href="##%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1">数据结构设计部分</a></p></li><li class="lvl-2"><p>1108 IP地址无效化 (Easy)</p><p>简单弱智模拟。</p></li><li class="lvl-2"><p><strong>522 Longest Uncommon Subsequence 最长特殊序列 II (Medium)</strong></p><p>题目的基本含义：找出<strong>最长的独有子序列</strong>。</p><p>解析题意：最长的独有子序列要求不能是任何其他字符串的子序列。然而我们考虑一个满足条件的最长独有子序列，在其前后加上若干任意字符后其仍为最长独有子序列。即，如果某个字符串的子序列是一个最长独有子序列，那么该字符串本身也必定为最长特殊子序列。所以我们只需要考虑每个字符串本身即可，而无需关心其子串。</p><p>所以最终的解决思路是：枚举每个字符串，查看其是否为其他字符串的subsequence。</p><ul class="lvl-2"><li class="lvl-4"><p>首先，可以将字符按照长度顺序进行排序，这样当前字符串只需要与更长的串进行比较；</p></li><li class="lvl-4"><p>判断subsequence的方法：双指针；</p></li></ul></li><li class="lvl-2"><p>899 Orderly Queue 有序队列 (Hard)</p><p>巧解题，分两种情况讨论。</p><ul class="lvl-2"><li class="lvl-4"><p>$k == 1$：就是每次将首个字母移到最末端。那么我们枚举所有结果，选出其中最小的即可。</p><p>一种巧妙地枚举办法是，在字符串后面一模一样拼接一个，然后从前到后挨个遍历就能得到所有结果。</p></li><li class="lvl-4"><p>$k &gt; 1$：脑际急转弯的地方在于，$k&gt;1$ 的情况实际上结果一定会变为最小单词。</p><p>一种浅显的理解方式是，当$k==1$时，每次只移动一个字符，整体相当于一个循环队列，在这个队列中的逆序对是无法被全部消除的（除非题目正好能消除掉）。</p><p>而当 $k&gt;1$ 时，每次是从 $k$ 个里面选出最大的移到最后，并且移动次数为任意次，这意味着从前往后每 $k$ 个单词在若干次移动后应该被消除掉所有逆序对才是最终正确的结果。综上，最终整个字符串不应该还存在逆序对。</p><p>数学上的证明见官方题解。</p></li></ul></li></ul><h3 id="处理字符串中的字符">处理字符串中的字符</h3><blockquote><p>常用到C中的各种库函数，多查工具书。</p><ul class="lvl-1"><li class="lvl-2"><code>cctype</code></li><li class="lvl-2">STL <code>string</code></li></ul></blockquote><ul class="lvl-0"><li class="lvl-2"><p>468 Validate IP Address 验证IP地址 (Medium)</p><p>“面向测试用例编程”、无脑模拟，考虑各种特殊情况、注意字符判断时使用的库函数。</p></li><li class="lvl-2"><p>6079 Apply Discount to Prices 价格减免 (Medium)</p></li><li class="lvl-2"><p>929 独特的电子邮件地址 (Easy)</p><p>简单模拟，或使用<strong>正则表达式</strong>。</p></li><li class="lvl-2"><p>2288 Apply Discount to Prices (Medium)</p><p>考察将字符串中的浮点数转换为<code>double</code>后再按照固定格式转换回字符串。</p><p>用到如下函数：</p><ul class="lvl-2"><li class="lvl-4"><p><code>sprintf</code></p></li><li class="lvl-4"><p><code>stod</code></p></li><li class="lvl-4"><p><code>isdigit</code></p></li></ul></li><li class="lvl-2"><p>811 Subdomain Visit Count 子域名访问计数 (Medium)</p></li></ul><h3 id="回文-Palindrome-2">回文 Palindrome</h3><p>回文子序列/子串的题型有多种变式，常见的解法（除暴力求解外）有以下三种（上面两道题都可以用以下算法解答）。</p><h4 id="解法一：中心拓展">解法一：中心拓展</h4><p>本质上还是暴力枚举，只不过<strong>枚举回文中心</strong>比<strong>枚举出所有子串</strong>方便的多。</p><ul class="lvl-0"><li class="lvl-2"><p>要区分两种情况：奇数回文串和偶数回文串。</p></li><li class="lvl-2"><p>时间复杂度：$O(n^{2})$</p></li></ul><h4 id="解法二：Manacher">解法二：Manacher</h4><p>详见<a href="##Manacher%E7%AE%97%E6%B3%95">Manacher算法</a></p><h4 id="解法三：动态规划">解法三：动态规划</h4><h4 id="相关题目-14">相关题目</h4><ul class="lvl-0"><li class="lvl-2"><p>647 Palindromic Substrings 回文子串 (Medium)</p></li><li class="lvl-2"><p>5 Longest Palindromic Substring 最长回文子串 (Medium)</p></li><li class="lvl-2"><p>214 Shortest Palindrome 最短回文串 (Hard)</p><p>本题的解法实际上是字符串匹配，所以详见字符串匹配部分。</p></li></ul><h3 id="字符串匹配-2">字符串匹配</h3><p>跟字符串匹配相关的解法如下：</p><ol><li class="lvl-3"><p>朴素匹配</p></li><li class="lvl-3"><p><a href="##KMP%E7%AE%97%E6%B3%95">KMP算法</a></p></li><li class="lvl-3"><p><strong>Robin-Karp算法</strong>，即<strong>滚动哈希</strong>。</p><p>本质上就是字符串哈希，即将字符串转换为一个整数从而方便比较。该算法有几个值得注意的点，在此指明：</p><ul class="lvl-2"><li class="lvl-5"><p>因为直接按照进制转换求值有可能会导致哈希值过大，无法在机器字长内表示，所以通常会模上一个大质数；</p></li><li class="lvl-5"><p>对于转换的进制 $base$ 和模数 $mod$ 的选取：</p><p>一般来说，我们选取一个<strong>大于字符集大小</strong>（即字符串中可能出现的字符种类的数目）<strong>的质数</strong>作为 $base$，再选取一个在<strong>字符串长度平方级别左右的质数</strong>作为 $mod$，产生哈希碰撞的概率就会很低。</p><p>对于leetcode中的题目，大都以<strong>全小写字母形式</strong>的字符串出现，这种情况下常用如下设置：</p><ul class="lvl-4"><li class="lvl-7"><p>$base$：略大于字符集大小的质数，选定<strong>29</strong>或<strong>31</strong>（有大写的话就增加就行）；</p></li><li class="lvl-7"><p>$mod$：所有跟哈希计算相关的值都设置为<code>unsigned long long</code>类型，则运算时相当于自动取模，而不会产生任何上下溢出，编译器会自动截断。</p></li></ul></li></ul></li><li class="lvl-3"><p>有限状态机</p></li></ol><p>基本上掌握 <strong>KMP</strong>和<strong>滚动哈希</strong>即可解决相关的大部分问题，且面试出现频率不高，相关题目如下：</p><ul class="lvl-0"><li class="lvl-2"><p>28 实现 strStr() Implement strStr() (Easy)</p></li><li class="lvl-2"><p>796 Rotate String 旋转字符串 (Easy)</p><p>解法一：模拟</p><p>按照题目要求，进行旋转操作，并对比旋转后的结果；</p><p>主要的开销在于旋转操作，每次的旋转要去掉第一个字符，需要 $O(n)$ 的时间。</p><p>解法二：<strong>字符串匹配</strong></p><p>文本串 <strong>$s + s$</strong> 包含了所有 $s$ 可以通过旋转操作得到的字符串，只需要检查 $goal$ 是否为 $s + s$ 的子字符串即可。</p></li><li class="lvl-2"><p><strong>214 Shortest Palindrome 最短回文串 (Hard)</strong></p><blockquote><p>首先思考如何找到该最短回文串，如下图所示：</p><p>我们要在 $s$ 前添加一个字符串，要求得到最短的回文串。实际的字符串构成如图所示，即将 $s$ 的一部分后缀 $s_2$ 反转得到 $\hat{s_2}$，并拼接在 $s$ 的前面。这里为了保证整体是回文串，就要求前缀 $s_1$ 部分必须也是回文的。</p><p>最简单的例子就是将整个字符串倒转后添加在前面，一定能得到一个回文串。而为了满足最短的要求，实际就是找到最短的 $\hat{s_2}$，同理就是【<strong>找到最长的 $s_1$ 满足其为回文串</strong>】。</p><p>由此可得，暴力解法即<strong>从后往前枚举每个元素，查看当前的前缀 $s_1$ 是否为回文串</strong>。该方法的时间复杂度显然为 $O(|s|^2)$ 。</p><p>优化的解法也是在这个思路的基础上进行优化。</p></blockquote><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/pics-master/202205161418594.png" style="zoom: 50%;" /><p>解法一：KMP算法</p><p>为了找到最长的 $s_1$，我们将 $s$ 作为pattern，将 $\hat{s}$ 作为text，进行模式匹配。如图所示，最后匹配的位置就能帮助我们获取到答案。</p><p><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/pics-master/202205161501183.png" alt=""></p><p>解法二：Robin-Karp字符串哈希算法</p></li><li class="lvl-2"><p><strong>1044 Longest Duplicate Substring 最长重复子串 (Hard)</strong></p><ul class="lvl-2"><li class="lvl-4"><p>首先，题目要求找到具有最长长度的子串，所以要对长度进行枚举 - $O(n)$</p><p>优化方法是采用二分，时间复杂度可以降至 $O(logn)$。</p></li><li class="lvl-4"><p>在每一个长度下，要两两遍历子串来查询其是否有出现过 - $O(n^2)$</p><p>采用Robin-Karp算法，判断同一长度下是否有两个相同字符串只需要一趟扫描，即 $O(n)$。</p></li></ul></li><li class="lvl-2"><p><strong>459 Repeated Substring Pattern 重复的子字符串 (Easy)</strong></p><p>解法一：暴力枚举</p><p>对子串长度进行枚举，检查子串符合要求的有两种思路：</p><ol><li class="lvl-5"><p>拼接 $n$ 个字串（假设需要 $n$ 个），拼接后检查是否与原字符串相等。非常慢。</p></li><li class="lvl-5"><p>假设当前子段长度为 $n$，从第二个字串开始到最后为止，检查 $s[i] == s[i - n]$ 。有任意一次不满足相等就可以直接剪枝。</p></li></ol><p>时间复杂度为 $O(n^2)$。</p><p>解法二：<strong>字符串匹配</strong></p><p>详见<a href="##%E5%91%A8%E6%9C%9F%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%A4%E5%88%AB%E9%97%AE%E9%A2%98">周期字符串判别问题</a>。</p></li><li class="lvl-2"><p><em>2301 Match Substring After Replacement 替换字符后匹配 (Hard)</em></p><p>暴力模拟可以通过。即枚举所有长度跟目标串一致的子串，查看是否匹配。</p><p>注意使用<strong>哈希表</strong>加快替换字符的效率。</p></li><li class="lvl-2"><p><strong>30 Substring with Concatenation of All Words 串联所有单词的子串 (Hard)</strong></p><p>虽然题面是字符串匹配，但实际上无需写匹配算法。</p><p>滑动窗口 + 哈希表。</p></li></ul><h3 id="其他-5">其他</h3><ul class="lvl-0"><li class="lvl-2"><p><em>316 Remove Duplicate Letters 去除重复字母 (Medium)</em></p><p>题目中的要求：去除重复字母，保证返回的字典序最小，且不能打乱字符的相对位置。</p><p>关于字符串的知识点在于：<strong>针对一个字符串，在其中删除哪个元素能保证结果字符串的字典序最小/大？</strong></p><p>详见[单调栈部分](###单调栈 Monotone Stack)。</p></li><li class="lvl-2"><p><strong>227 Basic Calculator II 基本计算器 II  (Medium)</strong></p><p>详见<a href="###%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC">表达式求值</a>部分。</p></li><li class="lvl-2"><p><strong>467 Unique Substrings in Wraparound String 环绕字符串中唯一的子字符串 (Medium)</strong></p><ul class="lvl-2"><li class="lvl-4">统计以每种字母为结尾的最长连续子串即可，最大值即为其对最终答案的贡献（自动去重，无需担心前后出现相同的字符串重复统计）；</li><li class="lvl-4">最终对所有字母的贡献求和即可，即前缀和的思想。</li></ul></li><li class="lvl-2"><p>1455 Check If a Word Occurs As a Prefix of Any Word in a Sentence 检查单词是否为句中其他单词的前缀 (Easy)</p></li></ul><h2 id="Manacher算法-2">Manacher算法</h2><p>比较特殊的算法，要背一下其实现，具体写不写的出其实问题不大。</p><blockquote><p>给定一个字符串，<strong>求其最长回文子串的长度</strong>。例如：</p><ol><li class="lvl-3"><code>s=&quot;abcd&quot;</code>，最长回文长度为 1；</li><li class="lvl-3"><code>s=&quot;ababa&quot;</code>，最长回文长度为 5；</li><li class="lvl-3"><code>s=&quot;abccb&quot;</code>，最长回文长度为 4，即 <code>bccb</code>。</li></ol><p>以上问题的传统思路大概是，遍历每一个字符，以该字符为中心向两边查找。其时间复杂度为 O(n2)，效率很差。</p><p>1975 年，一个叫 Manacher 的人发明了一个算法，<em>Manacher 算法</em>（中文名：<em>马拉车算法</em>），该算法可以把时间复杂度提升到 O(n)。</p><p>Manacher 算法依旧需要枚举字符串的每一个位置并先假设它是回文中心，但是它会<strong>利用已经计算出来的状态来更新 <code>p(i)</code></strong>，<strong>而不是向「中心拓展」一样盲目地拓展</strong>。</p></blockquote><p>算法分为三个重点处理部分：</p><h3 id="1-字符串预处理-2">1 字符串预处理</h3><blockquote><p>解决奇偶回文分类问题</p></blockquote><p>由于回文分为偶回文（比如 <code>bccb</code>）和奇回文（比如 <code>bcacb</code>），而在处理奇偶问题上会比较繁琐，所以这里我们使用一个技巧，具体做法是：</p><ol><li class="lvl-3"><p>在字符串首尾及每个字符间都插入一个 “#”，这样可以使得原先的奇偶回文都变为奇回文；</p></li><li class="lvl-3"><p>接着再在首尾两端各插入 “$” 和 “^”，这样中心扩展寻找回文的时候会自动退出循环，不需每次判断是否越界，可参见下面代码。</p></li><li class="lvl-3"><p>上述新插入的三个字符，即 “#”、 “$” 和 “^”，必须各异，且不可以与原字符串中的字符相同。</p></li></ol><p>举个例子：<code>s=&quot;abbahopxpo&quot;</code>，转换为 <code>s_new=&quot;$#a#b#b#a#h#o#p#x#p#o#^&quot;</code>。如此，s 里起初有一个偶回文 <code>abba</code> 和一个奇回文 <code>opxpo</code>，被转换为 <code>#a#b#b#a#</code> 和 <code>#o#p#x#p#o#</code>，长度都转换成了奇数。</p><h3 id="2-引入辅助数组-2">2 引入辅助数组</h3><blockquote><p>记录每个字符为中心的最长回文半径</p></blockquote><p>定义一个辅助数组 <code>int p[]</code>，其中 <code>p[i]</code> 表示以 i 为中心的<strong>最长回文的半径</strong>，例如：</p><table><thead><tr><th>i</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th><th>16</th><th>17</th><th>18</th><th>19</th><th>20</th><th>21</th><th>22</th></tr></thead><tbody><tr><td>s_new[i]</td><td>$</td><td>#</td><td>a</td><td>#</td><td>b</td><td>#</td><td>b</td><td>#</td><td>a</td><td>#</td><td>h</td><td>#</td><td>o</td><td>#</td><td>p</td><td>#</td><td>x</td><td>#</td><td>p</td><td>#</td><td>o</td><td>#</td><td>^</td></tr><tr><td>p[i]</td><td>1</td><td>1</td><td>2</td><td>1</td><td>2</td><td>5</td><td>2</td><td>1</td><td>2</td><td>1</td><td>2</td><td>1</td><td>2</td><td>1</td><td>2</td><td>1</td><td>6</td><td>1</td><td>2</td><td>1</td><td>2</td><td>1</td><td>1</td></tr></tbody></table><p>可以看出， <code>p[i] - 1</code> 正好是<strong>原字符串中最长回文串的长度</strong>，因为此时的半径是添加过预处理符号的半径 。</p><h3 id="3-求解辅助数组-2">3 求解辅助数组</h3><blockquote><p>实现线性复杂度的关键</p></blockquote><p>接下来的重点就是求解 p 数组，如下图：</p><p><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/pics-master/202112271559574.png" alt=""><br>设置两个变量，mx 和 id 。mx 代表以 id 为中心的最长回文的右边界，也就是 <code>mx = id + p[id]</code>。</p><p>假设我们现在求 <code>p[i]</code>，也就是以 i 为中心的最长回文半径，如果 <code>i &lt; mx</code>，如上图，那么：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 求解辅助数组的核心</span><br><span class="hljs-keyword">if</span> (i &lt; mx)  <br>    p[i] = <span class="hljs-built_in">min</span>(p[<span class="hljs-number">2</span> * id - i], mx - i);<br></code></pre></td></tr></table></figure><p><code>2 * id - i</code> 为 i 关于 id 的对称点，即上图的 j 点，而 <strong><code>p[j]</code>表示以 j 为中心的最长回文半径</strong>，因此我们可以利用 <code>p[j]</code> 来加快查找。</p><p>根据回文的性质，<code>p[i]</code> 的值基于以下三种情况得出：</p><p>（1）<strong>j 的回文串有一部分在 id 的之外</strong>，如下图：<img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/pics-master/202112271610871.png" alt=""><br>上图中，黑线为 id 的回文，i 与 j 关于 id 对称，红线为 j 的回文。那么根据代码此时 <code>p[i] = mx - i</code>，即紫线。那么 <code>p[i]</code> 还可以更大么？答案是不可能！见下图：<img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/pics-master/202112271610179.png" alt=""><br>假设右侧新增的紫色部分是 <code>p[i]</code> 可以增加的部分，那么根据回文的性质，a 等于 d ，也就是说 id 的回文不仅仅是黑线，而是黑线+两条紫线，矛盾，所以假设不成立，故 <code>p[i] = mx - i</code>，不可以再增加一分。</p><p>（2）<strong>j 回文串全部在 id 的内部</strong>，如下图：<img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/pics-master/202112271610855.png" alt=""><br>根据代码，此时 <code>p[i] = p[j]</code>，那么 <code>p[i]</code> 还可以更大么？答案亦是不可能！见下图：<img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/pics-master/202112271610897.png" alt=""><br>假设右侧新增的红色部分是 <code>p[i]</code> 可以增加的部分，那么根据回文的性质，a 等于 b ，也就是说 j 的回文应该再加上 a 和 b ，矛盾，所以假设不成立。故 <code>p[i] = p[j]</code>，也不可以再增加一分。</p><p>（3）<strong>j 回文串左端正好与 id 的回文串左端重合</strong>，见下图：<img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/pics-master/202112271611950.png" alt=""><br>根据代码，此时 <code>p[i] = p[j]</code> 或 <code>p[i] = mx - i</code>，并且 <code>p[i]</code> 还可以继续增加，所以需要</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span> (s_new[i - p[i]] == s_new[i + p[i]]) <br>    p[i]++;<br></code></pre></td></tr></table></figure><h4 id="代码-2">代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">char</span> s[<span class="hljs-number">1000</span>];<br><span class="hljs-type">char</span> s_new[<span class="hljs-number">2000</span>];<br><span class="hljs-type">int</span> p[<span class="hljs-number">2000</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> len = <span class="hljs-built_in">strlen</span>(s);<br>    s_new[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;$&#x27;</span>;<br>    s_new[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;#&#x27;</span>;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>        s_new[j++] = s[i];<br>        s_new[j++] = <span class="hljs-string">&#x27;#&#x27;</span>;<br>    &#125;<br>    s_new[j++] = <span class="hljs-string">&#x27;^&#x27;</span>;  <span class="hljs-comment">// 别忘了哦</span><br>    s_new[j] = <span class="hljs-string">&#x27;\0&#x27;</span>;   <span class="hljs-comment">// 这是一个好习惯</span><br>    <span class="hljs-keyword">return</span> j;  <span class="hljs-comment">// 返回 s_new 的长度</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Manacher</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> len = <span class="hljs-built_in">Init</span>();  <span class="hljs-comment">// 取得新字符串长度并完成向 s_new 的转换</span><br>    <span class="hljs-type">int</span> max_len = <span class="hljs-number">-1</span>;  <span class="hljs-comment">// 最长回文长度</span><br>    <span class="hljs-type">int</span> id;<br>    <span class="hljs-type">int</span> mx = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; mx)<br>            p[i] = <span class="hljs-built_in">min</span>(p[<span class="hljs-number">2</span> * id - i], mx - i);  <br>        <span class="hljs-comment">// 需搞清楚上面那张图含义，mx 和 2*id-i 的含义</span><br>        <span class="hljs-keyword">else</span><br>            p[i] = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span> (s_new[i - p[i]] == s_new[i + p[i]])  <span class="hljs-comment">// 不需边界判断，因为左有 $，右有 ^</span><br>            p[i]++;<br>        <span class="hljs-comment">// 我们每走一步 i，都要和 mx 比较，我们希望 mx 尽可能的远，</span><br>        <span class="hljs-comment">// 这样才能更有机会执行 if (i &lt; mx)这句代码，从而提高效率</span><br>        <span class="hljs-comment">// 更新 mx</span><br>        <span class="hljs-keyword">if</span> (mx &lt; i + p[i]) &#123;<br>            id = i;<br>            mx = i + p[i];<br>        &#125;<br>        max_len = <span class="hljs-built_in">max</span>(max_len, p[i] - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> max_len;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入字符串：&quot;</span>)) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, s);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;最长回文长度为 %d\n\n&quot;</span>, <span class="hljs-built_in">Manacher</span>());<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="算法复杂度分析-2">算法复杂度分析</h3><p>根据（1）（2）（3），很容易推出 Manacher 算法的最坏情况，即为字符串内全是相同字符的时候。在这里我们重点研究 <code>Manacher()</code> 中的 for 语句，推算发现 for 语句内平均访问每个字符 5 次，即时间复杂度为：$T_{worst}(n)=O(n)$</p><p>同理，我们也很容易知道最佳情况下的时间复杂度，即字符串内字符各不相同的时候。推算得平均访问每个字符 4 次，即时间复杂度为：$T_{best}(n)=O(n)$。</p><p>综上，<strong>Manacher 算法的时间复杂度为 O(n)</strong>。</p><h2 id="KMP算法-2">KMP算法</h2><p>解决字符串匹配问题，包括几个重点：</p><ul class="lvl-0"><li class="lvl-2"><p>求解next数组</p></li><li class="lvl-2"><p>根据next数组来进行模式匹配</p></li></ul><h3 id="求解next数组-2">求解next数组</h3><p>next数组的<strong>定义</strong>：针对pattern模式串<code>s</code>，<em><code>next[i]</code> 表示子串<code>s[0...i]</code>的【最长相等前后缀】中【前缀的最后一位】的下标。</em></p><h5 id="手动模拟-2">手动模拟</h5><p>根据定义进行手动模拟即可，无对应相等前后缀的值赋 -1。</p><h5 id="递推求解-代码实现-2">递推求解 / 代码实现</h5><p>两个指针的含义：</p><ul class="lvl-0"><li class="lvl-2"><p><code>i</code>： 从1 ~ len - 1之间遍历，表示当前处理的字符；</p></li><li class="lvl-2"><p><code>j</code>： 表示【当前的相等前后缀】中 【前缀】的最后一位 的下标；</p><ul class="lvl-2"><li class="lvl-4"><p>判断 <code>s[i] == s[j + 1] </code>， 即判断当前相等前后缀是否能扩展到下一位；</p></li><li class="lvl-4"><p>如果不能就要向前回溯，为了<strong>减少回溯次数</strong>（使找到的相等前后缀尽可能长，<code>j</code>尽可能大），每次回退使<code>j = next[j]</code> 直至其回退为 -1；</p><p>为什么回退时使 <code>j = next[j]</code> 能够最小化回溯次数？我们根据后面讲解的“实际求解过程”进行手动模拟，并结合下图的例子来实际理解（用图中的字符串做求解next数组的实例练习）：</p><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/pics-master/202205111123247.png" style="zoom:33%;" /><p>此时，最长的相等前后缀为 $aabaa$，并且在 $i$ 处失配。为了使回溯次数尽可能少，就要使得 $j$ 尽可能地大，方法就是寻找 $aabaa$ 中的最长相等前后缀的位置。根据next数组的含义，自然应该将 $j$ 移动到 $next[j]$ 的位置。</p></li></ul></li></ul><p>实际求解过程：</p><ol><li class="lvl-4"><p>初始化 next 数组，令 <code>j = next[0] = -1</code>；</p></li><li class="lvl-4"><p>让 <code>i</code> 在 1 ~ len - 1 范围之间遍历，对每个 <code>i</code> 执行第三步与第四步，以求解 <code>next[i]</code>；</p></li><li class="lvl-4"><p>不断令 <code>j = next[j]</code>， 直到 <code>j</code> 回退为 -1，或是 <code>s[i] == s[j + 1]</code> 成立。</p></li><li class="lvl-4"><p>如果 <code>s[i] == s[j + 1]</code> ， 则 <code>j</code> 自增 1 后 <code>next[i] = j</code>， 否则直接令 <code>next[i] = j</code>。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">getNext</span><span class="hljs-params">(string s)</span> </span>&#123;<br><span class="hljs-type">int</span> j = <span class="hljs-number">-1</span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">next</span><span class="hljs-params">(s.size())</span></span>;<br>    next[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-keyword">while</span>(j != <span class="hljs-number">-1</span> &amp;&amp; s[i] != s[j + <span class="hljs-number">1</span>]) &#123;<br>            j = next[j];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(s[i] == s[j + <span class="hljs-number">1</span>]) &#123;<br>        j++;<br>        &#125;<br>        next[i] = j;<br>    &#125;<br>    <span class="hljs-keyword">return</span> next;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="模式匹配-2">模式匹配</h3><p>KMP的原则在于：<em>文本串的指针 <code>i</code> 绝对不回溯，而模式串的指针 <code>j</code>  也在回溯的过程中保持其尽可能大。</em></p><p>在模式匹配中，next数组的<strong>含义</strong>：<strong>当 j + 1 位失配时，j 应该回退到的位置</strong>。</p><p>模式匹配的求解过程与求解next数组非常相似，实际上求解next数组的过程就是模式串pattern进行自我匹配（并计算得到数组的值）的过程，而KMP算法是将pattern与目标串text进行匹配。</p><p>KMP算法进行模式匹配的作用不唯一，可以用于求解<strong>匹配是否成功</strong>，也可以用于求解<strong>模式串出现的次数</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 匹配是否成功</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">kmp</span><span class="hljs-params">(string text, string pattern)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = text.<span class="hljs-built_in">size</span>(), m = pattern.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">-1</span>;<br>    vector&lt;<span class="hljs-type">int</span>&gt; next = <span class="hljs-built_in">getNext</span>(pattern);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">while</span>(j != <span class="hljs-number">-1</span> &amp;&amp; text[i] != pattern[j + <span class="hljs-number">1</span>]) &#123;<br>            j = next[j];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(text[i] == pattern[j + <span class="hljs-number">1</span>]) &#123;<br>            j++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(j == m - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 统计模式串出现的次数</span><br><span class="hljs-comment">// 重点要注意模式串在文本串中多次的出现可能会【重叠】</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kmp</span><span class="hljs-params">(string text, string pattern)</span> </span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> n = text.<span class="hljs-built_in">size</span>()， m = pattern.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">-1</span>;<br>    vector&lt;<span class="hljs-type">int</span>&gt; next = <span class="hljs-built_in">getNext</span>(string pattern);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">while</span>(j != <span class="hljs-number">-1</span> &amp;&amp; text[i] != pattern[j + <span class="hljs-number">1</span>]) &#123;<br>            j = next[j];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(text[i] == pattern[j + <span class="hljs-number">1</span>]) &#123;<br>            j++;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 统计次数的代码唯一的区别如下</span><br>        <span class="hljs-keyword">if</span>(j == m - <span class="hljs-number">1</span>) &#123;<br>            ans++;<br>            j = next[j];<span class="hljs-comment">// 因为模式串的出现可能会重叠，所以不能从头开始匹配，否则会少统计重叠的部分</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="优化-nextval数组-2">优化 - nextval数组</h3><p>next数组对应的模式匹配在失配的情况下，<code>j</code> 指针有可能产生多次无用的回溯（一直失配，直至 <code>j</code> 为-1）。具体情况如下，结合图示例子来理解：</p><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/pics-master/202205111539729.png" style="zoom:33%;" /><p>图中黑色的指针 $i, j$ 代表生成 $nextval$ 数组时的指针，红色的指针 $i, j$ 代表进行模式匹配时的指针。此处失配后，根据 $next$ 数组可以看到，会不断进行回退：</p><ul class="lvl-0"><li class="lvl-2"><p>第一次失配：此时 $j + 1 = 5$ 处为 $b$，先回退到 $j = next[4] = 2$， 显然此时仍然失配；</p></li><li class="lvl-2"><p>第二次失配：此时 $j + 1 = 3$ 处仍然为 $b$，再回退到 $j = next[2] = 0$，显然此时再次失配；</p></li><li class="lvl-2"><p>第三次失配：此时 $j + 1 = 1$ 处又一次为 $b$，继续回退到 $j = next[1] = -1$ 处，回退停止。</p></li></ul><p>综上三次失配与回退可以发现：每次回退之后的 $j + 1$ 处的字符都相等为 $b$ ，失配是显而易见的，白白进行了多次比较。</p><p>$nextval$ 数组就是避免了这种 <em>$patter[j + 1] == patter[next[j] + 1]$</em> 的情况，一次性跳跃到正确的比对位置。</p><p>在进行模式匹配时，模式串在 $i$ 处失配意味着 $i + 1$ 与文本串对应位置不符，即 $i + 1$ 处的字符有问题（上图例子中的$b$）。所以如果再次跳回一个同样的错误字符，即 $j + 1$ 处等于 $i + 1$处的失配字符时，肯定还需要再重复回退一次，所以具体实现代码如下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">getNextval</span><span class="hljs-params">(string pattern)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = pattern.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextval</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">-1</span>;<br>    nextval[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span>(j != <span class="hljs-number">-1</span> &amp;&amp; pattern[i] != pattern[j + <span class="hljs-number">1</span>]) &#123;<br>        <span class="hljs-comment">// 根据nextval的定义，求解数组和模式匹配中的while都可以改成if，因为至多只会执行一次</span><br>        j = <span class="hljs-built_in">nextval</span>(j)；    <br>        &#125;<br>        <span class="hljs-keyword">if</span>(pattern[i] == pattern[j + <span class="hljs-number">1</span>]) &#123;<br>            j++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(j == <span class="hljs-number">-1</span> || pattern[i + <span class="hljs-number">1</span>] != pattern[j + <span class="hljs-number">1</span>]) &#123;<br>            nextval[i] = j;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            nextval[i] = nextval[j];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，$nextval$ 数组虽然失去了其定义中最大前后缀的含义，但是其指向了<strong>每次回退时的真正最佳位置</strong>，减少了无效的回退操作。</p><h3 id="时间复杂度-2">时间复杂度</h3><p><code>O(n + m)</code> ： 其中 <code>n</code>为目标字符串text的长度， <code>m</code> 为模式串pattern的长度</p><ul class="lvl-0"><li class="lvl-2"><p>计算next数组需要 <code>O(m)</code>；</p></li><li class="lvl-2"><p>进行模式匹配需要 <code>O(n)</code>；</p></li></ul><h2 id="周期字符串判别问题-2">周期字符串判别问题</h2><p><strong>周期字符串判别问题</strong>有两种常见解法：</p><ul class="lvl-0"><li class="lvl-2"><p>双倍字符串方法</p></li><li class="lvl-2"><p>KMP 方法</p></li></ul><p>本题的难点在于证明与推演，其解题思路与代码都比较简单。</p><h3 id="问题-2">问题</h3><p>判断一个字符串是否由其一个子串重复多次构成。</p><p>例如：字符串 <code>&quot;abcabc&quot;</code> 是由子串 <code>&quot;abc&quot;</code> 重复两次构成的。</p><h3 id="双倍字符串方法-2">双倍字符串方法</h3><p>把字符串翻倍，掐头去尾，如果原字符串在其中，那么原字符串就是周期串 。</p><p>假设字符串是 <code>s</code> ，把它的头尾字符分别染上黄色和蓝色：</p><p><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/pics-master/202205151303835.png" alt=""></p><p>把字符串 <code>s</code> 接到自身后面，然后掐头去尾，形成新字符串 <code>s'</code>：</p><p><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/pics-master/202205151303981.png" alt=""></p><h5 id="匹配意味着周期性-2">匹配意味着周期性</h5><p>下面讨论原字符串 <code>s</code> 在新字符串 <code>s'</code> 中存在的情况。</p><p>一步一步对各部分涂色，使得相等的字符串颜色一样 。</p><p><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/pics-master/202205151304030.png" alt=""></p><p>经过几轮的染色，可以看到最终 <code>s</code> 确实是一个周期串。</p><p>是否巧合？可以做一般性说明。</p><p>下图，不妨设右边匹配的少一些。对其中的任一字符 <code>A</code> ，可以按照如下的规则推演：</p><p><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/pics-master/202205151304895.png" alt=""></p><p>如此，任一此区间上的字符 <code>A</code> 会在 <code>s</code> 中周期性出现。</p><p>即说明字符串 <code>s</code> 是周期串。</p><h5 id="周期性意味着匹配-2">周期性意味着匹配</h5><p>反过来，如果一个字符串 <code>s</code> 是周期串，那么它一定在对应的 <code>s'</code> 中吗？</p><p>任何一个周期串可以表达为： 由某个模式子串的重复多次构成 。</p><p><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/pics-master/202205151305541.png" alt=""></p><p>将周期串 <code>s</code> 的头字符对齐在第一个模式串后面， 每次右移一个模式串的长度。</p><p>可知，<code>s</code> 会在 <code>s'</code> 中有匹配，且可以有多个匹配。</p><p><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/pics-master/202205151305963.png" alt=""></p><p>图中可看出， 因为模式串重复 <code>n</code> 次，所以会有 <code>n</code> 次匹配 。</p><p>构造双倍串 <code>s'</code> 时，移除头尾字符， 正是为了剔除最左和最右的两次必然匹配。 只有中间的 <code>n</code> 次匹配才用到了周期串重复模式串的性质。</p><h5 id="结论-2">结论</h5><p>综上两方面说明了充分性和必要性，结论：</p><p>如果字符串在其掐头去尾的双倍字符串中，它就是周期串 。</p><h3 id="KMP-方法-2">KMP 方法</h3><p>假设要判断的字符串叫做 <code>s</code> ，将其尾巴字符标记为蓝色。</p><p>取 <code>q</code> 为不包含尾巴字符的前缀。</p><p><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/pics-master/202205151305388.png" alt=""></p><p>取 <code>c</code> 为 <code>q</code> 的最长前后公共缀。</p><p>前后公共缀的意思是，它是既出现在字符串的最前面，也出现在字符串的最后面的真子串 。</p><p>举例来说，比如 <code>s</code> 是字符串串 <code>&quot;abcabcabc&quot;</code> ，<code>q</code> 则是 <code>&quot;abcabcab&quot;</code> 。</p><p><code>q</code> 的最长前后公共缀 <code>c</code> 则是 <code>&quot;abcab&quot;</code> 。</p><p><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/pics-master/202205151305522.png" alt=""></p><p>将说明，<code>s</code> 是周期串等价于 <code>len(s)</code> 是 <code>len(q)-len(c)</code> 的倍数 。</p><h5 id="必要性说明-2">必要性说明</h5><p>假设字符串 <code>s</code> 是一个周期串，它由模式串 <code>p</code> 重复多次构成。</p><p><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/pics-master/202205151305620.png" alt=""></p><p>现在， 取 <code>c1</code> 为 <code>q</code> 中剔去一个模式串 <code>p</code> 后的后缀 。</p><p><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/pics-master/202205151306852.png" alt=""></p><p>显然，字符串 <code>c1</code> 是 <code>q</code> 的一个 <a href="https://writings.sh/post/algorithm-repeated-string-pattern#what-is-common-prefix-and-suffix">前后公共缀</a>。</p><p>比如周期串 <code>&quot;abcabcabc&quot;</code> ，对应的 <code>c1</code> 是 <code>&quot;abcab&quot;</code> 。</p><p><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/pics-master/202205151306288.png" alt=""></p><p>可以证明，<code>c1</code> 就是 <code>q</code> <strong>最长的</strong>前后公共缀 <code>c</code> ，详细可展开下面内容。</p><details open="" style="padding: 0px; margin: 0px;"><summary style="padding: 0px; margin: 0px; color: rgb(197, 142, 4); outline: 0px; cursor: pointer;"><span class="MathJax_Preview" style="padding: 0px; margin: 0px; color: inherit;"></span><span id="MathJax-Element-1-Frame" class="mjx-chtml MathJax_CHTML" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mstyle displaystyle=&quot;true&quot;><mi>c</mi><mn>1</mn></mstyle></math>" role="presentation" style="padding: 1px 0px; margin: 0px; outline: 0px; display: inline-block; line-height: 0; text-indent: 0px; text-align: left; text-transform: none; font-style: normal; font-weight: normal; font-size: 20.4px; letter-spacing: normal; overflow-wrap: normal; word-spacing: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; position: relative;"><span id="MJXc-Node-1" class="mjx-math" aria-hidden="true" style="padding: 0px; margin: 0px; display: inline-block; border-collapse: separate; border-spacing: 0px;"><span id="MJXc-Node-2" class="mjx-mrow" style="padding: 0px; margin: 0px; display: inline-block; text-align: left; box-sizing: content-box !important;"><span id="MJXc-Node-3" class="mjx-mstyle" style="padding: 0px; margin: 0px; display: inline-block; text-align: left; box-sizing: content-box !important;"><span id="MJXc-Node-4" class="mjx-mrow" style="padding: 0px; margin: 0px; display: inline-block; text-align: left; box-sizing: content-box !important;"><span id="MJXc-Node-5" class="mjx-mi" style="padding: 0px; margin: 0px; display: inline-block; text-align: left; box-sizing: content-box !important;"><span class="mjx-char MJXc-TeX-math-I" style="padding: 0.199em 0px 0.297em; margin: 0px; display: block; text-align: left; box-sizing: content-box !important; white-space: pre; font-family: MJXc-TeX-math-I, MJXc-TeX-math-Ix, MJXc-TeX-math-Iw;">c</span></span><span id="MJXc-Node-6" class="mjx-mn" style="padding: 0px; margin: 0px; display: inline-block; text-align: left; box-sizing: content-box !important;"><span class="mjx-char MJXc-TeX-main-R" style="padding: 0.395em 0px 0.346em; margin: 0px; display: block; text-align: left; box-sizing: content-box !important; white-space: pre; font-family: MJXc-TeX-main-R, MJXc-TeX-main-Rw;">1</span></span></span></span></span></span><span class="MJX_Assistive_MathML" role="presentation" style="padding: 1px 0px 0px !important; margin: 0px; top: 0px; left: 0px; clip: rect(1px, 1px, 1px, 1px); user-select: none; position: absolute !important; border: 0px !important; height: 1px !important; width: 1px !important; overflow: hidden !important; display: block !important;"><math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mi>c</mi><mn>1</mn></mstyle></math></span></span><span>&nbsp;</span>就是<span>&nbsp;</span><span class="MathJax_Preview" style="padding: 0px; margin: 0px; color: inherit;"></span><span id="MathJax-Element-2-Frame" class="mjx-chtml MathJax_CHTML" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mstyle displaystyle=&quot;true&quot;><mi>q</mi></mstyle></math>" role="presentation" style="padding: 1px 0px; margin: 0px; outline: 0px; display: inline-block; line-height: 0; text-indent: 0px; text-align: left; text-transform: none; font-style: normal; font-weight: normal; font-size: 20.4px; letter-spacing: normal; overflow-wrap: normal; word-spacing: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; position: relative;"><span id="MJXc-Node-7" class="mjx-math" aria-hidden="true" style="padding: 0px; margin: 0px; display: inline-block; border-collapse: separate; border-spacing: 0px;"><span id="MJXc-Node-8" class="mjx-mrow" style="padding: 0px; margin: 0px; display: inline-block; text-align: left; box-sizing: content-box !important;"><span id="MJXc-Node-9" class="mjx-mstyle" style="padding: 0px; margin: 0px; display: inline-block; text-align: left; box-sizing: content-box !important;"><span id="MJXc-Node-10" class="mjx-mrow" style="padding: 0px; margin: 0px; display: inline-block; text-align: left; box-sizing: content-box !important;"><span id="MJXc-Node-11" class="mjx-mi" style="padding: 0px; margin: 0px; display: inline-block; text-align: left; box-sizing: content-box !important;"><span class="mjx-char MJXc-TeX-math-I" style="padding: 0.199em 0.014em 0.493em 0px; margin: 0px; display: block; text-align: left; box-sizing: content-box !important; white-space: pre; font-family: MJXc-TeX-math-I, MJXc-TeX-math-Ix, MJXc-TeX-math-Iw;">q</span></span></span></span></span></span><span class="MJX_Assistive_MathML" role="presentation" style="padding: 1px 0px 0px !important; margin: 0px; top: 0px; left: 0px; clip: rect(1px, 1px, 1px, 1px); user-select: none; position: absolute !important; border: 0px !important; height: 1px !important; width: 1px !important; overflow: hidden !important; display: block !important;"><math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mi>q</mi></mstyle></math></span></span><span>&nbsp;</span>最长的前后公共缀<span>&nbsp;</span><span class="MathJax_Preview" style="padding: 0px; margin: 0px; color: inherit;"></span><span id="MathJax-Element-3-Frame" class="mjx-chtml MathJax_CHTML" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mstyle displaystyle=&quot;true&quot;><mi>c</mi></mstyle></math>" role="presentation" style="padding: 1px 0px; margin: 0px; outline: 0px; display: inline-block; line-height: 0; text-indent: 0px; text-align: left; text-transform: none; font-style: normal; font-weight: normal; font-size: 20.4px; letter-spacing: normal; overflow-wrap: normal; word-spacing: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; position: relative;"><span id="MJXc-Node-12" class="mjx-math" aria-hidden="true" style="padding: 0px; margin: 0px; display: inline-block; border-collapse: separate; border-spacing: 0px;"><span id="MJXc-Node-13" class="mjx-mrow" style="padding: 0px; margin: 0px; display: inline-block; text-align: left; box-sizing: content-box !important;"><span id="MJXc-Node-14" class="mjx-mstyle" style="padding: 0px; margin: 0px; display: inline-block; text-align: left; box-sizing: content-box !important;"><span id="MJXc-Node-15" class="mjx-mrow" style="padding: 0px; margin: 0px; display: inline-block; text-align: left; box-sizing: content-box !important;"><span id="MJXc-Node-16" class="mjx-mi" style="padding: 0px; margin: 0px; display: inline-block; text-align: left; box-sizing: content-box !important;"><span class="mjx-char MJXc-TeX-math-I" style="padding: 0.199em 0px 0.297em; margin: 0px; display: block; text-align: left; box-sizing: content-box !important; white-space: pre; font-family: MJXc-TeX-math-I, MJXc-TeX-math-Ix, MJXc-TeX-math-Iw;">c</span></span></span></span></span></span><span class="MJX_Assistive_MathML" role="presentation" style="padding: 1px 0px 0px !important; margin: 0px; top: 0px; left: 0px; clip: rect(1px, 1px, 1px, 1px); user-select: none; position: absolute !important; border: 0px !important; height: 1px !important; width: 1px !important; overflow: hidden !important; display: block !important;"><math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mi>c</mi></mstyle></math></span></span><span>&nbsp;</span>的详细说明</summary><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;">采用反证法，假设存在一个字符串<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">c'</code><span>&nbsp;</span>也是<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">q</code><span>&nbsp;</span>的前后公共缀，而且它比<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">c1</code><span>&nbsp;</span>长一位。</p><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;">另外，假设尾巴字符叫做<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">A</code><span>&nbsp;</span>。</p><figure style="padding: 0px; margin: 30px auto; width: 768px;"><img class="post-img lazyload max-width-100 medium-zoom-image" src="https://writings.sh/assets/images/posts/algorithm-repeated-string-pattern/repeated-string-pattern-kmp-5-1.jpeg" data-src="/assets/images/posts/algorithm-repeated-string-pattern/repeated-string-pattern-kmp-5-1.jpeg" alt="" data-loaded="true" style="padding: 0px; margin: 0px auto; display: block; max-width: 100%; cursor: zoom-in; transition: transform 0.3s cubic-bezier(0.2, 0, 0.2, 1) 0s !important;"></figure><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;"></p><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;">现在有两条性质：</p><ol style="padding: 0px 0px 0px 30px; margin: 15px 0px; list-style: decimal;"><li style="padding: 0px; margin: 0px;">周期性质：字符串<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">s</code><span>&nbsp;</span>的周期性。</li><li style="padding: 0px; margin: 0px;">前后公共缀性质：<code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">c'</code><span>&nbsp;</span>是<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">q</code><span>&nbsp;</span>的前后公共缀。</li></ol><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;">以下，反复利用此两条性质：</p><ol style="padding: 0px 0px 0px 30px; margin: 15px 0px; list-style: decimal;"><li style="padding: 0px; margin: 0px;"><p style="padding: 0px; margin: 0px 0px 15px; letter-spacing: 0.5px;">由于「前后公共缀性质」，<code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">q</code><span>&nbsp;</span>的第一个字符也是<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">A</code>。</p><figure style="padding: 0px; margin: 30px auto; width: 738px;"><img class="post-img lazyload max-width-100 medium-zoom-image" src="https://writings.sh/assets/images/posts/algorithm-repeated-string-pattern/repeated-string-pattern-kmp-5-2.jpeg-small.svg" data-src="/assets/images/posts/algorithm-repeated-string-pattern/repeated-string-pattern-kmp-5-2.jpeg" alt="" style="padding: 0px; margin: 0px auto; display: block; max-width: 100%; cursor: zoom-in; transition: transform 0.3s cubic-bezier(0.2, 0, 0.2, 1) 0s !important;"></figure><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;"></p></li><li style="padding: 0px; margin: 0px;"><p style="padding: 0px; margin: 0px 0px 15px; letter-spacing: 0.5px;">由于「周期性质」，后续的循环子串中的第一个字符也是<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">A</code><span>&nbsp;</span>。</p><figure style="padding: 0px; margin: 30px auto; width: 738px;"><img class="post-img lazyload max-width-100 medium-zoom-image" src="https://writings.sh/assets/images/posts/algorithm-repeated-string-pattern/repeated-string-pattern-kmp-5-3.jpeg-small.svg" data-src="/assets/images/posts/algorithm-repeated-string-pattern/repeated-string-pattern-kmp-5-3.jpeg" alt="" style="padding: 0px; margin: 0px auto; display: block; max-width: 100%; cursor: zoom-in; transition: transform 0.3s cubic-bezier(0.2, 0, 0.2, 1) 0s !important;"></figure><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;"></p></li><li style="padding: 0px; margin: 0px;"><p style="padding: 0px; margin: 0px 0px 15px; letter-spacing: 0.5px;">由于「前后公共缀性质」，<code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">q</code><span>&nbsp;</span>的第二个字符也是<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">A</code>。</p><figure style="padding: 0px; margin: 30px auto; width: 738px;"><img class="post-img lazyload max-width-100 medium-zoom-image" src="https://writings.sh/assets/images/posts/algorithm-repeated-string-pattern/repeated-string-pattern-kmp-5-4.jpeg-small.svg" data-src="/assets/images/posts/algorithm-repeated-string-pattern/repeated-string-pattern-kmp-5-4.jpeg" alt="" style="padding: 0px; margin: 0px auto; display: block; max-width: 100%; cursor: zoom-in; transition: transform 0.3s cubic-bezier(0.2, 0, 0.2, 1) 0s !important;"></figure><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;"></p></li><li style="padding: 0px; margin: 0px;"><p style="padding: 0px; margin: 0px 0px 15px; letter-spacing: 0.5px;">由于「周期性质」，后续的循环子串中的第二个字符也是<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">A</code><span>&nbsp;</span>。</p><figure style="padding: 0px; margin: 30px auto; width: 738px;"><img class="post-img lazyload max-width-100 medium-zoom-image" src="https://writings.sh/assets/images/posts/algorithm-repeated-string-pattern/repeated-string-pattern-kmp-5-5.jpeg-small.svg" data-src="/assets/images/posts/algorithm-repeated-string-pattern/repeated-string-pattern-kmp-5-5.jpeg" alt="" style="padding: 0px; margin: 0px auto; display: block; max-width: 100%; cursor: zoom-in; transition: transform 0.3s cubic-bezier(0.2, 0, 0.2, 1) 0s !important;"></figure><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;"></p></li><li style="padding: 0px; margin: 0px;"><p style="padding: 0px; margin: 0px 0px 15px; letter-spacing: 0.5px;">如上反复进行，最终，推断整个<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">q</code><span>&nbsp;</span>以及<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">s</code><span>&nbsp;</span>都由字符<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">A</code><span>&nbsp;</span>构成。</p><figure style="padding: 0px; margin: 30px auto; width: 738px;"><img class="post-img lazyload max-width-100 medium-zoom-image" src="https://writings.sh/assets/images/posts/algorithm-repeated-string-pattern/repeated-string-pattern-kmp-5-6.jpeg-small.svg" data-src="/assets/images/posts/algorithm-repeated-string-pattern/repeated-string-pattern-kmp-5-6.jpeg" alt="" style="padding: 0px; margin: 0px auto; display: block; max-width: 100%; cursor: zoom-in; transition: transform 0.3s cubic-bezier(0.2, 0, 0.2, 1) 0s !important;"></figure><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;"></p><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;">此时的模式串<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">p</code><span>&nbsp;</span>即单个字符<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">A</code><span>&nbsp;</span>。</p><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;">根据<span>&nbsp;</span><a href="https://writings.sh/post/algorithm-repeated-string-pattern#kmp-c1-definition" style="padding: 0px; margin: 0px; color: rgb(197, 142, 4); text-decoration: none;">前面的定义</a><span>&nbsp;</span>可以知道，此时的<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">c1</code><span>&nbsp;</span>如上图，长度是<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">len(q)-1</code><span>&nbsp;</span>。</p><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;">前后公共缀是真子串，显然，不会存在比它更长的前后公共缀，造成矛盾。</p></li></ol><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;">因此，所定义的<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">c1</code><span>&nbsp;</span>就是<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">q</code><span>&nbsp;</span>的最长前后公共缀<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">c</code><span>&nbsp;</span>。</p></details><p>根据 <a href="https://writings.sh/post/algorithm-repeated-string-pattern#kmp-c1-definition">前面的定义</a> ，可知周期长度是 <code>len(p) = len(q)-len(c)</code> 。</p><p>因为字符串 <code>s</code> 是周期串，所以其长度一定是周期长度的倍数。</p><p>必要性得到说明。</p><h5 id="充分性说明-2">充分性说明</h5><p>令 <code>d = len(q)-len(c)</code> ， 如果 <code>s</code> 的长度是 <code>d</code> 的倍数，是否 <code>s</code> 一定是周期串？</p><p>此时 <code>s</code> 一定可以每 <code>d</code> 个字符一份，切分为整数个小份串：</p><p><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/pics-master/202205151307596.png" alt=""></p><p>同样假设尾巴字符是蓝色的 <code>A</code> ， 剔除尾巴字符后 <code>q</code> 和 其最长前后公共缀 <code>c</code> 如下所示：</p><p><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/pics-master/202205151307241.png" alt=""></p><p>首先，显然 <code>len(c)+1</code> 是 <code>d</code> 的倍数。</p><details open="" style="padding: 0px; margin: 0px;"><summary style="padding: 0px; margin: 0px; color: rgb(197, 142, 4); outline: 0px; cursor: pointer;"><span class="MathJax_Preview" style="padding: 0px; margin: 0px; color: inherit;"></span><span id="MathJax-Element-4-Frame" class="mjx-chtml MathJax_CHTML" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mstyle displaystyle=&quot;true&quot;><mi>c</mi></mstyle></math>" role="presentation" style="padding: 1px 0px; margin: 0px; outline: 0px; display: inline-block; line-height: 0; text-indent: 0px; text-align: left; text-transform: none; font-style: normal; font-weight: normal; font-size: 20.4px; letter-spacing: normal; overflow-wrap: normal; word-spacing: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; position: relative;"><span id="MJXc-Node-17" class="mjx-math" aria-hidden="true" style="padding: 0px; margin: 0px; display: inline-block; border-collapse: separate; border-spacing: 0px;"><span id="MJXc-Node-18" class="mjx-mrow" style="padding: 0px; margin: 0px; display: inline-block; text-align: left; box-sizing: content-box !important;"><span id="MJXc-Node-19" class="mjx-mstyle" style="padding: 0px; margin: 0px; display: inline-block; text-align: left; box-sizing: content-box !important;"><span id="MJXc-Node-20" class="mjx-mrow" style="padding: 0px; margin: 0px; display: inline-block; text-align: left; box-sizing: content-box !important;"><span id="MJXc-Node-21" class="mjx-mi" style="padding: 0px; margin: 0px; display: inline-block; text-align: left; box-sizing: content-box !important;"><span class="mjx-char MJXc-TeX-math-I" style="padding: 0.199em 0px 0.297em; margin: 0px; display: block; text-align: left; box-sizing: content-box !important; white-space: pre; font-family: MJXc-TeX-math-I, MJXc-TeX-math-Ix, MJXc-TeX-math-Iw;">c</span></span></span></span></span></span><span class="MJX_Assistive_MathML" role="presentation" style="padding: 1px 0px 0px !important; margin: 0px; top: 0px; left: 0px; clip: rect(1px, 1px, 1px, 1px); user-select: none; position: absolute !important; border: 0px !important; height: 1px !important; width: 1px !important; overflow: hidden !important; display: block !important;"><math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mi>c</mi></mstyle></math></span></span><span>&nbsp;</span>的长度加一是<span>&nbsp;</span><span class="MathJax_Preview" style="padding: 0px; margin: 0px; color: inherit;"></span><span id="MathJax-Element-5-Frame" class="mjx-chtml MathJax_CHTML" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mstyle displaystyle=&quot;true&quot;><mi>d</mi></mstyle></math>" role="presentation" style="padding: 1px 0px; margin: 0px; outline: 0px; display: inline-block; line-height: 0; text-indent: 0px; text-align: left; text-transform: none; font-style: normal; font-weight: normal; font-size: 20.4px; letter-spacing: normal; overflow-wrap: normal; word-spacing: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; position: relative;"><span id="MJXc-Node-22" class="mjx-math" aria-hidden="true" style="padding: 0px; margin: 0px; display: inline-block; border-collapse: separate; border-spacing: 0px;"><span id="MJXc-Node-23" class="mjx-mrow" style="padding: 0px; margin: 0px; display: inline-block; text-align: left; box-sizing: content-box !important;"><span id="MJXc-Node-24" class="mjx-mstyle" style="padding: 0px; margin: 0px; display: inline-block; text-align: left; box-sizing: content-box !important;"><span id="MJXc-Node-25" class="mjx-mrow" style="padding: 0px; margin: 0px; display: inline-block; text-align: left; box-sizing: content-box !important;"><span id="MJXc-Node-26" class="mjx-mi" style="padding: 0px; margin: 0px; display: inline-block; text-align: left; box-sizing: content-box !important;"><span class="mjx-char MJXc-TeX-math-I" style="padding: 0.493em 0.003em 0.297em 0px; margin: 0px; display: block; text-align: left; box-sizing: content-box !important; white-space: pre; font-family: MJXc-TeX-math-I, MJXc-TeX-math-Ix, MJXc-TeX-math-Iw;">d</span></span></span></span></span></span><span class="MJX_Assistive_MathML" role="presentation" style="padding: 1px 0px 0px !important; margin: 0px; top: 0px; left: 0px; clip: rect(1px, 1px, 1px, 1px); user-select: none; position: absolute !important; border: 0px !important; height: 1px !important; width: 1px !important; overflow: hidden !important; display: block !important;"><math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mi>d</mi></mstyle></math></span></span><span>&nbsp;</span>的倍数的说明</summary><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;">根据<span>&nbsp;</span><a href="https://writings.sh/post/algorithm-repeated-string-pattern#kmp-d-definition" style="padding: 0px; margin: 0px; color: rgb(197, 142, 4); text-decoration: none;"><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">d</code><span>&nbsp;</span>的定义</a>， 得<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">len(c) + 1 = len(q) - d + 1</code><span>&nbsp;</span>。</p><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;">又因<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">len(q) = len(s) - 1</code><span>&nbsp;</span>，且<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">len(s)</code><span>&nbsp;</span>可以写作<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">len(s) = k*d</code><span>&nbsp;</span>。</p><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;">所以<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">len(c) + 1 = k*d - d = (k-1)*d</code><span>&nbsp;</span>，是<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">d</code><span>&nbsp;</span>的倍数。</p></details><p>因此，在下图中， <code>c</code> 必然上下对齐于某个 <a href="https://writings.sh/post/algorithm-repeated-string-pattern#kmp-small-pattern-p">小份串</a> 的开头。</p><p>又因 <code>len(c)+1 = (k-1)*d</code> ，所以 <code>c</code> 就是 <code>q</code> 中剔除第一个小份串 <code>p1</code> 的后缀 。</p><p><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/pics-master/202205151307726.png" alt=""></p><p>下面将说明，<code>s</code> 是一个周期串。</p><p>在最后一个小份串，从尾部取倒数第 <code>j</code> 个字符 <code>B</code> ，反复推演， 可以知道前面的所有小份串的相同位置，都是字符 <code>B</code> 。</p><p><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/pics-master/202205151307501.png" alt=""></p><p>上面的图中：</p><ol><li class="lvl-3"><p>① 号推演，由于上面后缀和下面前缀相等。</p></li><li class="lvl-3"><p>② 号推演，由于下面的小份串和上面的自身相等。</p></li><li class="lvl-3"><p>如此，反复进行。</p></li></ol><p>对最后一个小份串上的所有字符， 都会在前面的小份串相同位置重复，那么 <code>s</code> 是一个周期串。</p><details open="" style="padding: 0px; margin: 0px;"><summary style="padding: 0px; margin: 0px; color: rgb(197, 142, 4); outline: 0px; cursor: pointer;">推演的一个细节处理</summary><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;">上面推演中的一个细节是，无法推演小份串的倒数第一个字符。</p><figure style="padding: 0px; margin: 30px auto; width: 768px;"><img class="post-img lazyload max-width-100 medium-zoom-image" src="https://writings.sh/assets/images/posts/algorithm-repeated-string-pattern/repeated-string-pattern-kmp-7-3.jpeg" data-src="/assets/images/posts/algorithm-repeated-string-pattern/repeated-string-pattern-kmp-7-3.jpeg" alt="" data-loaded="true" style="padding: 0px; margin: 0px auto; display: block; max-width: 100%; cursor: zoom-in; transition: transform 0.3s cubic-bezier(0.2, 0, 0.2, 1) 0s !important;"></figure><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;"></p><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;">原因在于，尾巴字符不在最长前后公共缀的范围内。</p><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;">细节处理就是，需要判断一次尾巴字符<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">A</code><span>&nbsp;</span>是否和 上一个小份串对应位置的字符相等。</p><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;">一旦此细节满足，即可完成整体推演过程，<code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">s</code><span>&nbsp;</span>就一定是一个周期串。</p><figure style="padding: 0px; margin: 30px auto; width: 768px;"><img class="post-img lazyload max-width-100 medium-zoom-image" src="https://writings.sh/assets/images/posts/algorithm-repeated-string-pattern/repeated-string-pattern-kmp-7-4.jpeg" data-src="/assets/images/posts/algorithm-repeated-string-pattern/repeated-string-pattern-kmp-7-4.jpeg" alt="" data-loaded="true" style="padding: 0px; margin: 0px auto; display: block; max-width: 100%; cursor: zoom-in; transition: transform 0.3s cubic-bezier(0.2, 0, 0.2, 1) 0s !important;"></figure><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;"></p></details><p>至此，充分性也说明完毕。</p><h5 id="KMP-算法求解-2">KMP 算法求解</h5><p>KMP 算法中的 Next 数组的含义就是前后公共缀的长度 ，即 <code>len(c) = next[n-1]</code> 。</p><p>由 KMP 算法预处理的时间复杂度 可知，此方法的时间复杂度是 <code>O(n)</code> ，空间复杂度是 <code>O(n)</code> 。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>算法基础</title>
    <link href="/2022/09/02/Algorithm/"/>
    <url>/2022/09/02/Algorithm/</url>
    
    <content type="html"><![CDATA[<h2 id="时间复杂度-数据规模-2">时间复杂度 - 数据规模</h2><table><thead><tr><th style="text-align:center">复杂度</th><th style="text-align:center">数量级</th></tr></thead><tbody><tr><td style="text-align:center">$logn$</td><td style="text-align:center">long long 以内都可以</td></tr><tr><td style="text-align:center">$\sqrt{n}$</td><td style="text-align:center">$10^{12}$</td></tr><tr><td style="text-align:center">$n$</td><td style="text-align:center">$10^{6} \sim 10^{7}$</td></tr><tr><td style="text-align:center">$nlogn$</td><td style="text-align:center">$10^{5}$ $\sim$ $5*10^{5}$</td></tr><tr><td style="text-align:center">$n^2$</td><td style="text-align:center">$1000 \sim 5000$</td></tr><tr><td style="text-align:center">$n^3$</td><td style="text-align:center">$100\sim 500$</td></tr><tr><td style="text-align:center">$n^4$</td><td style="text-align:center">$50$</td></tr><tr><td style="text-align:center">$2^n$</td><td style="text-align:center">$20\sim 24$</td></tr><tr><td style="text-align:center">$3^n$</td><td style="text-align:center">$14$</td></tr><tr><td style="text-align:center">$n!$</td><td style="text-align:center">$9 \sim 12$</td></tr></tbody></table><h2 id="数学证明-Proof">数学证明 Proof</h2><h4 id="证明-Proof">证明 Proof</h4><p>A <i><u>mathematical proof</u></i> of a <i><u>proposition</u></i> is a chain of <i><u>logical deductions</u></i> leading to the proposition from a base set of <i><u>axioms</u></i>.<br><b>命题</b> 的<b>数学证明</b> 是指基于一系列 <b>公理</b>，经过一连串的 <b>逻辑推理</b>，最后得出这个命题。</p><h4 id="命题-Proposition">命题 Proposition</h4><p>A <i>preposition</i> is a statement (communication) that is either true of false.<br><b>命题</b>是一个或真或假的语句。</p><ul class="lvl-0"><li class="lvl-2"><p>单纯的表述，而非判断。区分于断言。</p></li><li class="lvl-2"><p>真假性随不同情况而变化的语句 <b>不是</b> 命题。</p></li></ul><h4 id="断言-Claim">断言 Claim</h4><p>可能是错误的一种判断语句。</p><h4 id="猜想-Conjecture">猜想 Conjecture</h4><p>顾名思义。</p><h4 id="谓词-Predicate">谓词 Predicate</h4><p>A <i>predicate</i> can be understood as a <i>proposition</i> whose truth depends on the value of one or more variables.<br><b>谓词</b> 相当于 真假性取决于一个或多个变量值的 <b>命题</b>。例如：“ $n$ 是一个完全平方数” 描述的就是一个谓词。只有 $n$ 的值确定后才能确定其真假。</p><h4 id="公理化方法-The-Axiomatic-Method">公理化方法 The Axiomatic Method</h4><p>不证自明、无可争辩的命题被称为 公理（Axiom）。以下几个通用术语用来描述已经被证明的命题，不同的术语表示该命题的作用不同：</p><ul class="lvl-0"><li class="lvl-2"><p><b>定理 Theroem</b> ：重要的真命题。</p></li><li class="lvl-2"><p><b>引理 Lemma</b> ：预备性命题，为后面的命题证明做准备。</p></li><li class="lvl-2"><p><b>推论 Corollary</b> ：从定理出发，只需几步逻辑推导就能得出的命题。</p></li></ul><h2 id="渐进记号-Asymptotic-Notation">渐进记号 Asymptotic Notation</h2><p>渐进记号的引入是用来刻画随着输入规模增长，算法运行时间的变化情况。我们可以抽象出：运行时间函数 $T(n)$ 是定义在自然数集 $N$ 上的。考虑的也是函数增长的速度。</p><p>那么我们在此处给出限制 / 假设：所有涉及到的函数 $f(n)$，均为 <b>渐进非负（asympototically nonnegative）</b>。即，当 $n$ 足够大时，$f(n)$ 非负。</p><div class="tips"><p>对于 $\Theta$ 和 $O$ 两个记号，我们在日常使用中可以给出一个非形式化的求解，即 <strong>去掉低阶项</strong> 并 <strong>忽略最高阶项前的系数</strong>。</p></div><h3 id="渐进符号在数学公式中的含义">渐进符号在数学公式中的含义</h3><p>所有的渐进符号表征的其实都是一个 <b>集合</b>。因此，我们可以记 “$f(n) \in \Theta(g(n))$”，表示函数 $f(n)$ 属于该集合。但实际应用中，我们使用 <b>等号</b> 来表征相同的意思，即写作 “$f(n) = \Theta(g(n))$” 。</p><p>当渐近符号位于公式中的不同位置时，其表征的含义也略有不同：</p><ul class="lvl-0"><li class="lvl-2"><p>当渐进记号 <b>独立</b> 于公式的 <b>右侧</b> 时：如上所述，定义等号指明集合的成员关系。</p><p>例如，$n = O(n^2)$ 即代表 $n \in O(n^2)$。</p></li><li class="lvl-2"><p>当渐进记号出现在右侧某个公式（的一部分）中时：代表某个我们不关注的匿名函数集。可以用于消除一个公式中无关紧要的细节部分。</p><blockquote><p>例如对于归并排序：<br>$$<br>T(n) = \begin{cases} \Theta(1)&amp; \mbox{if} \space n \leq c \<br>aT(n / b) + Divide(n) + Combine(n) &amp; else<br>\end{cases}<br>$$<br>其中 $aT(n / b)$ 表示将原问题分解为 $a$ 个子问题，每个子问题的规模是原问题的 $\frac{1}{b}$ （此处二者值均为 2）；$Divide(n)$ 代表分解子问题消耗的时间、$Combine(n)$ 代表合并子问题的解成原问题的解消耗的时间。</p><p>其中：</p><ul class="lvl-3"><li class="lvl-2"><p>分解 $Divide(n)$：仅需计算子数组的分割位置，需要常量时间，即 $\Theta(1)$；</p></li><li class="lvl-2"><p>解决 $2T(n/2)$：递归求解规模更小的子问题；</p></li><li class="lvl-2"><p>合并 $Combine(n)$：显然为线性时间，$\Theta(n)$。</p></li></ul><p>对整体算法运行时间的贡献，取决于解决部分的递归运算。所以 <b>把分解和合并这种不重点关注的部分简写为 $\Theta(n)$ </b>。即：<br>$$<br>T(n) = \begin{cases} \Theta(1)&amp; \mbox{if} \space n \leq c \<br>2T(n / 2) + \Theta(n) &amp; else<br>\end{cases}<br>$$</p></blockquote></li><li class="lvl-2"><p>当渐进符号出现在公式的左边时，可以理解为 <b>等式右边比左边提供的细节更粗糙，对界的要求更松散</b>。</p><p>通常右侧一定会出现渐进符号，所以可以以一个等式链的实例来理解此种情况：<br>$$<br>2n^2 + 3n + 1 = 2n^2 + \Theta(n) = \Theta(n^2)<br>$$<br>直观上看，右侧提供的紧确界相对松散，即：无论如何选择等号左侧的匿名函数，总有一种对右侧匿名函数的选择使得整个公式/归属成立。</p></li></ul><h3 id="Theta-notation">$\Theta$-notation</h3><p>$\Theta$记号渐进地给出一个函数的上界和下界，即 $g(n)$ 为 $f(n)$ 的 <b>渐进紧确界（asymptotically tight bound）</b>。</p><p>实际应用中表征算法 <b>在某种输入情况下的实际运行时间</b>。</p><p>对于一个给定的函数 $g(n)$ ，用 $\Theta(g(n))$ 来表示以下函数的集合：<br>$$<br>\Theta(g(n)) = {f(n): \mbox{there} \space \mbox{exist} \space \mbox{positive}\space \mbox{constants}\space  c_1, c_2,\space \mbox{and} \space n_0 \space \mbox{such}\space \mbox{that}\space \0 \leq c_1g(n) \leq f(n)\leq c_2g(n)\space \mbox{for} \space \mbox{all}\space n \geq n_0 }<br>$$<br><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/pics-master/202211231929165.png" style="zoom:50%;" /></p><p>通常，将 $c_1$ 设置为一个稍小于最高阶项系数的值，并将 $c_2$ 设置为稍大于最高阶项系数的值，能够使 $\Theta$ 记号定义中的不5678568等式得到满足。</p><h3 id="O-notation">$O$-notation</h3><p>$O$ 记号表征函数的 <b>渐进上界（asymptotic upper bound）</b>。实际应用中表征算法的 <b>最坏情况运行时间</b>。</p><p>对于一个给定的函数 $g(n)$ ，用 $O(g(n))$ 来表示以下函数的集合：<br>$$<br>O(g(n)) = {f(n): \mbox{there} \space \mbox{exist} \space \mbox{positive}\space \mbox{constants}\space  c\space \mbox{and} \space n_0 \space \mbox{such}\space \mbox{that}\space \ 0  \leq f(n)\leq cg(n)\space \mbox{for} \space \mbox{all}\space n \geq n_0 }<br>$$<br>显然，$f(n) = \Theta(g(n))$ 蕴含着 $f(n) = O(g(n))$。</p><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/pics-master/202211231929578.png" style="zoom:50%;" /><h3 id="Omega-notation">$\Omega$-notation</h3><p>$\Omega$ 记号表征函数的 <b>渐进下界（asymptotic lower bound）</b>。实际应用中表征算法的 <b>最好情况运行时间</b>。</p><p>对于一个给定的函数 $g(n)$ ，用 $\Omega(g(n))$ 来表示以下函数的集合：<br>$$<br>\Omega(g(n)) = {f(n): \mbox{there} \space \mbox{exist} \space \mbox{positive}\space \mbox{constants}\space  c\space \mbox{and} \space n_0 \space \mbox{such}\space \mbox{that}\space \ 0  \leq cg(n)\leq f(n)\space \mbox{for} \space \mbox{all}\space n \geq n_0 }<br>$$<br>显然，$f(n) = \Theta(g(n))$ 蕴含着 $f(n) = \Omega(g(n))$。</p><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/pics-master/202211231930256.png" style="zoom:50%;" /><h3 id="渐进确界-Asymptotic-Tight-Bound">渐进确界 Asymptotic Tight Bound</h3><p>要注意理解 <b>渐进确界 / 紧确（tight）</b> 的含义：</p><ul class="lvl-0"><li class="lvl-2"><p>渐进上/下界（$O$，$\Omega$）意味着，对算法在 <b>每个输入</b> 上的运行时间，都能满足该界；</p><p>注意，这两个记号提供的界可能是非渐进紧确、也可能是渐进紧确的，要看具体的输入情况。</p></li><li class="lvl-2"><p>渐进确界（$\Theta$）给出的是一个更紧凑的范围，不能保证每个输入都满足其要求。</p></li></ul><p>以插入排序为例：</p><ul class="lvl-0"><li class="lvl-2"><p>在最坏情况下，运行时间为平方级，可以说同时满足于 $O(n^2)$ 与 $\Theta(n^2)$；</p></li><li class="lvl-2"><p>在最好情况下，整个输入为有序序列，则插入排序的运行时间为线性。即 $\Theta(n)$，可得对于确界，最坏情况与最好情况为两种不同结果。而对于上界来说，线性仍然满足集合 $O(n^2)$ 的要求，即满足每个输入的情况。</p></li></ul><p>结合插入排序的实例可以说：$n^2 = O(n^2)$ 是渐进紧确（tight）的，而 $n = O(n^2)$ 则不是。</p><p>理解了渐进确界的情况，我们可以引入下述两个表示非渐进确界的渐进记号。</p><h3 id="o-notation">$o$-notation</h3><p>$O$ 记号提供的渐进上界可能是紧确也可能是非紧确的。我们使用 $o$ 记号来表示一个一定非渐进紧确的上界。</p><p>对于一个给定的函数 $g(n)$ ，用 $o(g(n))$ 来表示以下函数的集合：<br>$$<br>o(g(n)) = {f(n): \mbox{there} \space \mbox{exist} \space \mbox{positive}\space \mbox{constants}\space  c\space \mbox{and} \space n_0 \space \mbox{such}\space \mbox{that}\space \ 0  \leq f(n)&lt; cg(n)\space \mbox{for} \space \mbox{all}\space n \geq n_0 }<br>$$<br>例如：$2n = o(n^2)$ ，但 $2n^2 \neq o(n^2)$。</p><p>直观来看，$f(n) =o(g(n))$ 表示 $g(n)$ 为 $f(n)$ 不紧确的上界。从数学角度来看，即当 $n$ 趋于无穷大时，$f(n)$ 相对于 $g(n)$ 无穷小：<br>$$<br>\mathop{lim}\limits_{n\rightarrow \infty}\frac{f(n)}{g(n)} = 0<br>$$</p><h3 id="omega-notation">$\omega$-notation</h3><p>与 $o$ 同理，$\omega$ 对应 $\Omega$ 记号，表征一个一定非渐进紧确的下界。</p><p>对于一个给定的函数 $g(n)$ ，用 $\omega(g(n))$ 来表示以下函数的集合：<br>$$<br>\omega(g(n)) = {f(n): \mbox{there} \space \mbox{exist} \space \mbox{positive}\space \mbox{constants}\space  c\space \mbox{and} \space n_0 \space \mbox{such}\space \mbox{that}\space \ 0  \leq cg(n) &lt; f(n)\space \mbox{for} \space \mbox{all}\space n \geq n_0 }<br>$$<br>例如：$2n^2 = \omega(n)$ ，但 $2n \neq \omega(n)$。</p><p>直观来看，$f(n) =\omega(g(n))$ 表示 $g(n)$ 为 $f(n)$ 不紧确的下界。从数学角度来看，即当 $n$ 趋于无穷大时，$f(n)$ 相对于 $g(n)$ 无穷大：<br>$$<br>\mathop{lim}\limits_{n\rightarrow \infty}\frac{f(n)}{g(n)} = \infty<br>$$</p><h3 id="不同记号之间的运算性质">不同记号之间的运算性质</h3><p>实数的许多关系性指适用于渐进比较：包括传递性（Transitivity）、自反性（Reflexivity）、对称性（Symmetry）、转置对称性（Transpose Symmetry）等。</p><p>实数的三分性不能带到渐进记号中。</p><p>（算法导论Ch3.1）</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>时间复杂度</tag>
      
      <tag>数学证明(Proof)</tag>
      
      <tag>渐进记号(Asymptotic Notation)</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字典树（Trie Tree）</title>
    <link href="/2022/08/30/%E5%AD%97%E5%85%B8%E6%A0%91%EF%BC%88Trie-Tree%EF%BC%89/"/>
    <url>/2022/08/30/%E5%AD%97%E5%85%B8%E6%A0%91%EF%BC%88Trie-Tree%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1>字典树 Trie Tree</h1><blockquote><p>切实在实际工程中有所应用的结构。后续深入了解其实际适用场景。</p></blockquote><h2 id="定义-6">定义</h2><p>字典树的定义与概念还是很简单的，这里不加赘述，重点关注实现细节。</p><h2 id="实现-3">实现</h2><p>重点关注树中的<strong>节点</strong>定义。这里的节点和定义不完全一致，主要存放两种信息：</p><ol><li class="lvl-3"><p>指针：因为节点存放的是下一层的指针，本身并不指明该节点所代表的字符。每个节点代表哪个字符由其上层的指针来决定。</p><p>通常用一个长度为26的指针数组。</p></li><li class="lvl-3"><p>结尾指示：指明当前节点是否为单词结尾。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TrieNode</span> &#123;<br><span class="hljs-type">bool</span> isEnd;<br>TrieNode* child[<span class="hljs-number">26</span>];<br><br><span class="hljs-built_in">TrieNode</span>(): <span class="hljs-built_in">isEnd</span>(<span class="hljs-literal">false</span>) &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span> ; i++) &#123;<br>child[i] = <span class="hljs-literal">nullptr</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其他的各种操作并不繁杂，在节点的基础上进行衍生与拓展即可。</p><h2 id="相关题目-10">相关题目</h2><ul class="lvl-0"><li class="lvl-2"><p>208 Implement Trie (Prefix Tree) 实现Trie（前缀树）(Medium)</p></li><li class="lvl-2"><p>648 Replace Words 单词替换 (Medium)</p><p>时间复杂度显然为线性（从建树到查找），即$O(d +s)$，其中d为词典长度，s为句子长度。</p></li><li class="lvl-2"><p><strong>676 Implement Magic Dictionary 实现一个魔法字典 (Medium)</strong></p><p>DFS + Trie，好题，在字典树上进行深搜，非常有助于加深对字典树的理解，多练习。</p></li><li class="lvl-2"><p><em>440 K-th Smallest in Lexicographical Order 字典序的第K小数字 (Hard)</em></p><p><em>字节超高频考题，面试前关注！</em></p><p>字典树形式的模拟，并没有实际建树，只是按照树的形式模拟。</p><p>以下题解来自宫水三叶：</p><p>我们可以将该过程分两步操作 :「确定前缀」和「从以某个前缀开始找目标值」。</p><p>假定我们存在某个函数 <code>int getCnt(int x, int limit)</code>，该函数实现了统计范围 $[1, limit]$ 内以 $x$ 为前缀的数的个数。</p><p>有了该函数之后，我们可以从最小的前缀 $1$ 开始枚举，假设当前枚举到前缀 $x$，根据 <code>cnt = getCnt(x, n)cnt=getCnt(x,n) </code>与 $k$ 的大小关系进行分情况讨论：</p><ul class="lvl-2"><li class="lvl-4"><p>$cnt &lt; k$： 说明所有以 $x$ 为前缀的数组均可跳过，此时让 $x$ 自增，$k$ 减去 $cnt$。含义为从下一个「数值比 $x$ 大」的前缀中找目标值；</p></li><li class="lvl-4"><p>$cnt \geqslant k$： 说明目标值前缀必然为 $x$，此时我们需要在以 $x$ 为前缀的前提下找目标值。此时让 $x$ 乘 $10$，$k$ 减 $1$（代表跳过了 $x$ 本身）。含义为从下一个「字典序比 $x$ 大」的前缀中找目标值。当 $k = 1$ 时，当前前缀 $x$ 即是答案（含义为以 $x$ 为前缀的所有数中，最小的数，也就是 $x$ 本身）。</p></li></ul><p>然后重点看看 <code>int getCnt(int x, int limit)</code> 函数如何实现。</p><p>为了方便，记 $x$ 的位数为 $n$，$limit$ 位数为 $m$。</p><p>根据 <code>getCnt</code> 的函数定义，在范围 $[1, limit]$ 内，以 $x$ 为前缀的数值数量等于下面所有情况的数量之和：</p><ul class="lvl-2"><li class="lvl-4"><p>位数为 $n$ 的数：仅有 $x$ 本身，共 $1$ 个；</p></li><li class="lvl-4"><p>位数为 $n + 1 &lt; m$ 的数，有 $x_0$ 到 $x_9$，共 $10$ 个；</p></li><li class="lvl-4"><p>位数为 $n + 2 &lt; m$ 的数，有 $x_{00}$ 到 $x_{99}$，共 $100$ 个；</p></li><li class="lvl-4"><p>…</p></li><li class="lvl-4"><p>位数为 $m$ 的数，此时根据「$limit$ 长度与 $x$ 等同的前缀 $u$」和「$x$」的大小关系，进一步分情况讨论（举个 🌰，当 $limit = 12456$，$x$ 为 $123$ 时，$u = 124$，两者位数相差 $k = 2$ 位）：</p><ul class="lvl-4"><li class="lvl-6">$u &lt; x$：此时所有位数为 $m$ 的数均大于$ limit$，合法个数为 $0$；</li><li class="lvl-6">$u == x$：此时所有位数为 $m$ 的数中部分满足 $limit$ 限制，合法个数为$ limit - x * 10^k + 1$ 个（只有 $[x0…0, limit]$ 为合法数）；</li><li class="lvl-6">$u &gt; x$：此时所有位数为 $m$ 的数均小于 $limit$，合法个数为 $10^k$。</li></ul></li></ul></li><li class="lvl-2"><p>745 Prefix and Suffix Search 前缀和后缀搜索 (Hard)</p><p>常规Trie，但是要为前缀和后缀建立两颗字典树。</p><p>重点在于一些提升效率的细节，如数组容器这种复杂结构采用引用，防止TLE，详见代码。</p><p>通过两棵树得到前缀和后缀两组符合条件的数组，通过双指针选择共有成员中下标最大者。</p></li><li class="lvl-2"><p>720 Longest Word in Dictionary 词典中最长的单词 (Medium)</p><p>Trie + DFS回溯。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字典树(Trie Tree)</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单调栈 Monotone Stack</title>
    <link href="/2022/08/22/%E5%8D%95%E8%B0%83%E6%A0%88-Monotone-Stack/"/>
    <url>/2022/08/22/%E5%8D%95%E8%B0%83%E6%A0%88-Monotone-Stack/</url>
    
    <content type="html"><![CDATA[<h1>单调栈 Monotone Stack</h1><blockquote><p>单调栈的定义与特点非常简单，即栈内元素呈递增/递减的趋势。以从底到顶递减为例，当元素入栈时：</p><ul class="lvl-1"><li class="lvl-2">若当前插入元素小于栈顶元素，则直接入栈；</li><li class="lvl-2">若当前插入元素大于栈顶元素，则将栈顶元素弹出，直至 栈顶元素大于待插入元素 或 栈空 为止，然后再进行入栈操作。</li></ul><p>单调栈通常用于解决【在<strong>线性时间复杂度</strong>内寻找<strong>相邻的下一个最大/最小元素</strong>】问题。</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>739 每日温度 Daily Temperatures (Medium)</p><p>很直白的，寻找数组中下一个更大的元素$^{[1]}$ ，并求解其和本身的下标差 $^{[2]}$。</p><ol><li class="lvl-5"><p>寻找相邻的下一个元素：显然使用单调栈可以将整体复杂度降至线性；</p></li><li class="lvl-5"><p>因为题目要求解是天数的差距，实际也就是下标的差距，所以这里要注意栈中存放的应该是下标即日期。这样才方便统计结果；</p></li><li class="lvl-5"><p>单调栈中最后剩下的元素说明不存在下一个更大的元素，按照题意结果应该置0，所以在开结果数组时，默认所有值均为0。</p></li></ol></li><li class="lvl-2"><p><em>42 Trapping Rain Water 接雨水 (Hard)</em></p><p>首先思考朴素暴力解法：对每一个位置，寻找其左侧与右侧的最高点，取二者中的较小者减去当前位置的高度即为此处能接的雨水。如果该值小于当前高度，则此处无法接住雨水。</p><ol><li class="lvl-5"><p><strong>动态规划</strong></p><p>显然，从每个点往左右两侧搜索最高点时，存在大量的重复计算与搜索。显然可以通过动态规划来进行优化。重点在于要进行两次dp，其中左侧最大值使用prefix前缀子问题，右侧最大值使用suffix后缀子问题，此处以前缀为例，后缀类似：</p><ul class="lvl-4"><li class="lvl-7"><p><strong>Subproblem:</strong> $left(i)$, 表示下标从 $0 \sim i$ 中的最大值；</p></li><li class="lvl-7"><p><strong>Relate:</strong> $left(i) = max{left(i - 1), height(i)}, 0 &lt; i &lt; n$</p></li><li class="lvl-7"><p><strong>Topological Order:</strong> Increasing $i$</p></li><li class="lvl-7"><p><strong>Base:</strong> $left(0) = height(0)$</p></li><li class="lvl-7"><p><strong>Original Problem:</strong> $left(n - 1)$</p></li><li class="lvl-7"><p><strong>Time:</strong> 共$n$个子问题，每个子问题常数运算时间，共$\Theta(n)$。</p></li></ul></li><li class="lvl-5"><p><strong>单调栈</strong></p><p>通过单调栈求出左右下一个更大的边界。此时相当于按照横条区间来求解，和动态规划的按位置解法不太一致。</p><p>时间复杂度为线性。空间复杂度仍为 $O(n)$ ，有优化空间。</p></li><li class="lvl-5"><p><strong>双指针</strong> 基于动态规划的解法进行<strong>空间复杂度优化</strong></p><p>每一个点处能接多少雨水显然由 $min{leftMax, rightMax}$ 来决定。我们使用双指针从两侧向内收入，指针的移动根据两侧维护的最大值而定：当 $leftMax$ 小于 $rightMax$ 时，说明 $left$ 指针处的雨水量由 $leftMax$ 来决定，即此位置的雨水量为 $leftMax - height[left]$。同时将 $right$ 指针向左移动（直至 $rightMax$ 小于 $leftMax$）；反之同理，即哪一侧的最大值更小，哪一侧就将指针继续移动。</p><p>双指针也是按位置进行处理，具体过程结合代码进行更深入的理解。</p><p>该解法为综合最优解法，其空间复杂度优化至 $O(1)$。</p></li></ol></li><li class="lvl-2"><p><em>84 Largest Rectangle in Histogram 柱状图中最大的矩形 (Hard)</em></p><p>首先思考朴素算法，对【高度】进行枚举。即以每个柱子的为中心向两侧探测，直至遇到比其更矮的柱子为止。此时可得到该位置上<strong>以该柱子高度为高</strong>的最大矩形面积。最后对每个位置取最大值即可。</p><p>仔细分析，本质是对两侧探测，直至找到相邻更矮的柱子。即<strong>寻找下一个相邻的较小元素</strong>。明显应该使用单调栈。此时需要进行【两次扫描】，每个方向扫描一次从而获得每个点的左侧边界与右侧边界。</p><p>优化：实际上在从左向右扫描求解右侧边界时，每次插入元素时，说明当前栈顶元素是更小的，即其实左侧边界（要先检查栈是否为空）。所以只需要【一次扫描】即可完成左右两侧的边界求解。</p></li><li class="lvl-2"><p>* <strong>85 Maximum Rectangle 最大矩形 (Hard)</strong></p><p>巧解题，想到思路比较难。84题的升级版。</p><p>本质和84一样，但是要记住这个解法（比较巧）。实际上就是【<strong>对每一行进行一个84题的单调栈处理</strong>】，如图所示。</p><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/pics-master/202204211941410.png" style="zoom: 25%;" /></li><li class="lvl-2"><p><em>316 Remove Duplicate Letters 去除重复字母 (Medium)</em></p><p>题目中的要求：去除重复字母，保证返回的字典序最小，且不能打乱字符的相对位置。</p><ol><li class="lvl-5"><p>保证返回字典序最小</p><p>首先理解字典序排序的定义：从前往后比，只要有一位小，就说明该字符串更小，与后面的无关。</p><p>然后思考问题：从一个字符串中删除一个字符，如何保证结果字符串字典序最小。</p><p>因为字典序是对最靠前不同的字符作比较，所以一定是从前往后考虑。所以我们<strong>找到最靠前的下标满足$s[i] &gt; s[i + 1]$，并将$s[i]$ 删除</strong>，即可得到结果。即将最早的能替换成更小字符的位置去掉。</p></li><li class="lvl-5"><p>去重，且保证相对位置</p><p>因为要保证相对位置，所以去重也要按照单向扫描（从前往后或从后往前）的方式考虑。</p><ul class="lvl-4"><li class="lvl-7"><p>为保证字典序最小，按照上面讨论过的方式进行删除，但删除的同时要确保后面还有该字符，方便检测这里需要开一个哈希表来统计每个字符出现的次数；</p></li><li class="lvl-7"><p>同时，已经确定位置进栈的元素不用继续考虑，所以维护一个入栈集合。因为进栈的元素后面仍然可能出栈，所以当弹栈时要注意也从集合中删除该元素。</p></li></ul></li></ol><p>至此，问题就转换成了【从前往后考虑每个字母 $\alpha$，如果<strong>其后有比其更小的字母</strong>，且后面仍然有更多的 $\alpha$，则将 $\alpha$ 删除】。后面是否存在的问题已经通过哈希表统计得到解决，但如果对每个位置都向后探测寻找更小的字母，时间复杂度会来到$O(n^{2})$。显然针对<strong>寻找下一个更小元素</strong>的问题，应该使用<strong>单调栈</strong>对其进行优化。</p></li><li class="lvl-2"><p>402 Remove K Digits 移掉K位数字 (Medium)</p><p>和316基本一致，简化版。字典序和最小整数其实是一样的策略。</p><p>唯一要注意的是，当所有数字是按照从小到大顺序排列时，不会有弹栈操作。所以循环结束后要检查是否已经弹出K个数字，如果没有要从尾部弹栈补齐。</p></li><li class="lvl-2"><p>496 Next Greater Element I 下一个更大元素 I (Easy)</p><p>在两个不同的数组中寻找下一个更大元素。</p></li><li class="lvl-2"><p>503 Next Greater Element II 下一个更大元素 II (Medium)</p><p>一个数组中寻找下一个更大元素，但是可以进行循环查找。</p><p>简单的处理方式是，从头到尾循环两次即可。或者直接通过模运算将循环两次的数组“拉直”。</p></li><li class="lvl-2"><p><em>2281 Sum of Total Strength of Wizards 巫师的总力量和 (Hard)</em></p><p>单调栈 + 前缀和（以及前缀和的前缀和）</p><p>首先考虑暴力解法：复杂度主要在于枚举所有的连续子数组（$O(n^2)$ ），还需要求出子数组的和以及子数组中的最小值（$O(n)$）。嵌套后达到$O(n^3)$的复杂度。</p><p>其中，子数组自身的求和显然可以通过<strong>前缀和</strong>来简化至常数时间。那么对于枚举子数组的优化思路就变成了最重要的问题。从思路上来看：</p><ul class="lvl-2"><li class="lvl-4"><p>枚举子数组是无法通过排序等方式使得复杂度由平方降至$O(nlogn)$；</p></li><li class="lvl-4"><p>考虑回数组本身，因为涉及到子数组的最小值，我们可以对数组中的单个巫师力量值进行考虑；</p><p>每个巫师都有一个“管辖范围”，即在这个管辖范围内，所有包含其本身的子数组的最小值都为其力量值。</p><p>显然我们应该可以每个巫师求出其管辖范围后进行进一步的处理。</p></li></ul><p>至此问题分为两部分：</p><ol><li class="lvl-5"><p>求出巫师的管辖范围 —— 单调栈</p><p>管辖范围即巫师为最小值的区间，即向左向右寻找比其更小的元素作为边界。<strong>寻找下一个更小元素</strong>显然应该使用<strong>单调栈</strong>。</p><p>这里要注意的是小心区间的重复。例如<code>[1,3,1,2]</code>中，如果两侧都以严格小于作为边界，那么两个1会出现重复计算的区间。这里将一侧改为小于等于即可解决重复计算：</p><p>比如右侧边界为小于等于，左侧边界为严格小于，那么第一个1的管辖范围为 <code>[1,3]</code>，第二个1的管辖范围为<code>[1,3,1,2]</code>。</p></li><li class="lvl-5"><p>求出管辖范围内所有子数组的和。</p><p>得到管辖范围后，我们要求出范围内所有包括当前巫师力量值的所有子数组以及其数组和。</p><ul class="lvl-4"><li class="lvl-7"><p>找出所有子数组比较简单：假设当前第 $i$ 号巫师的管辖范围为 $[left, right]$，枚举每个子数组的两侧边界 $[x, y]$，显然有 $left \leq x \leq i, \space\space i \leq y \leq right$；</p></li><li class="lvl-7"><p>得到了所有子区间后，要对其进行求和，这里根据公式推导，明确这里要使用<em>前缀和的前缀和</em>来优化计算。</p></li></ul></li></ol></li></ul><p><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/pics-master/202206161502854.png" alt=""></p><ul class="lvl-0"><li class="lvl-2"><p>907 Sum of Subarray Minimums 子数组的最小值之和 (Medium)</p><p>2281的简化版，放一块复习，使用单调栈。</p></li><li class="lvl-2"><p>769 Max Chunks To Make Sorted 最多能完成排序的块 (Medium)</p></li><li class="lvl-2"><p>768 Max Chunks To Make Sorted II 最多能完成排序的块 II (Hard)</p><p>TBD</p></li><li class="lvl-2"><p>2289 Steps to Make Array Non-decreasing 使数组按非递减顺序排列 (Medium)</p><p>单调栈 + 动态规划</p><p>首先，手动模拟来感受如何计算出结果。可以发现结果的执行操作数即为每个元素被删除的时刻中的最大值。</p><p>关键点在于如何求出每个元素被删除的时刻：</p><ul class="lvl-2"><li class="lvl-4"><p>以 <code>[9,1,2,3,4,1,5]</code> 为例，5是被其左侧最近的更大值9删掉的，显然我们需要求出<strong>每个元素左侧的下一个更大元素</strong>，这说明应该使用<strong>单调栈</strong>来记录元素；</p></li><li class="lvl-4"><p>找到了左侧的更大值后，就要确定5是在什么时刻被删掉的，显然删除5之前要把9和5之间的所有值全部删掉。从这里能够看出删除5的时刻即为中间这些元素最晚被删除的时刻+1，且我们并不关心这中间是怎样的删除顺序。所以问题的关键变成了如何求出区间内的最大值（可以使用线段树）。</p></li><li class="lvl-4"><p>结合单调栈，我们建立一个数组dp，<code>dp[i]</code>记录了第<code>i</code>个元素被删除的时刻。那么我们结合单调栈，从左向右处理数组中每个元素，当当前元素大于栈顶元素时，栈顶元素弹出，并求出这个过程所有弹栈元素的<code>dp[i]</code>的最大值，即区间内最后被删除的时刻。</p></li></ul></li><li class="lvl-2"><p><em>654 Maximum Binary Tree 最大二叉树 (Medium)</em></p><ul class="lvl-2"><li class="lvl-4"><p>解法一：模拟，复杂度为 $O(n^2)$</p></li><li class="lvl-4"><p>解法二：线段树。题目显然是一个RMQ问题，构建子树就是从部分数组中选出最大值。复杂度为 $O(nlogn)$</p></li><li class="lvl-4"><p>解法三：单调栈</p><p>每一个节点的选取都是选最大值，即，每一颗子树的根节点都是这颗子树中的最大值。</p><p>这就说明：</p><p>在最终构造出的树上，以 $nums[i]$ 为根节点的子树，在原数组中对应的区间，左边界为 $nums[i]$ 左侧第一个比它大的元素所在的位置，右边界为 $nums[i]$ 右侧第一个比它大的元素所在的位置。左右边界均为开边界。</p><p>如果某一侧边界不存在，则那一侧边界为数组的边界。如果两侧边界均不存在，说明其为最大值，即根节点。</p><p>同时：</p><p>$nums[i]$ 的父结点是两个边界中较小的那个元素对应的节点。</p><p>实现细节：</p><p>开辟一个存放树中节点的数组，通过数组下标来访问节点，并构建节点之间的树形关系。</p></li></ul></li></ul><p><em>相似题目</em>：</p><ul class="lvl-0"><li class="lvl-4"><p><input type="checkbox" id="checkbox5" checked="true"><label for="checkbox5">907 子数组的最小值之和</label></p></li><li class="lvl-4"><p><input type="checkbox" id="checkbox6"><label for="checkbox6">1508 子数组和排序后的区间和</label></p></li><li class="lvl-4"><p><input type="checkbox" id="checkbox7"><label for="checkbox7">1856 子数组最小乘积的最大值</label></p></li><li class="lvl-4"><p><input type="checkbox" id="checkbox8"><label for="checkbox8">2104 子数组范围和</label></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>单调栈（Monotone Stack）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Shallow Copy &amp; Deep Copy</title>
    <link href="/2022/08/03/Shallow%20Copy%20&amp;%20Deep%20Copy/"/>
    <url>/2022/08/03/Shallow%20Copy%20&amp;%20Deep%20Copy/</url>
    
    <content type="html"><![CDATA[<h1>Shallow Copy &amp; Deep Copy</h1><h2 id="What-is-Shallow-Copy">What is Shallow Copy?</h2><p>Shallow copy is a bit-wise copy of an object. A new object is created that has an exact copy of the values in the original object. If any of the fields of the object are references to other objects, only the reference addresses are copied i.e., only the memory address is copied.</p><p><img src="https://i.stack.imgur.com/LnDQh.png" alt="Shallow Copy"></p><p>In this figure, the <code>MainObject1</code> has fields <code>field1</code> of type int, and <code>ContainObject1</code> of type <code>ContainObject</code>. When you do a shallow copy of <code>MainObject1</code>, <code>MainObject2</code> is created with <code>field2</code> containing the copied value of <code>field1</code> and still pointing to <code>ContainObject1</code> itself. Note that since <code>field1</code> is of primitive type, its value is copied to <code>field2</code> but since <code>ContainedObject1</code> is an object, <code>MainObject2</code> still points to <code>ContainObject1</code>. So any changes made to <code>ContainObject1</code> in <code>MainObject1</code> will be reflected in <code>MainObject2</code>.</p><p>Now if this is shallow copy, lets see what’s deep copy?</p><h2 id="What-is-Deep-Copy">What is Deep Copy?</h2><p>A deep copy copies all fields, and makes copies of dynamically allocated memory pointed to by the fields. A deep copy occurs when an object is copied along with the objects to which it refers.</p><p><img src="https://i.stack.imgur.com/kocda.png" alt="Deep Copy"></p><p>In this figure, the MainObject1 have fields <code>field1</code> of type int, and <code>ContainObject1</code> of type <code>ContainObject</code>. When you do a deep copy of <code>MainObject1</code>, <code>MainObject2</code> is created with <code>field2</code> containing the copied value of <code>field1</code> and <code>ContainObject2</code> containing the copied value of <code>ContainObject1</code>. Note any changes made to <code>ContainObject1</code> in <code>MainObject1</code> will not reflect in <code>MainObject2</code>.</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>动态规划（Dynamic Programming）</title>
    <link href="/2022/06/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-Dynamic-Programming/"/>
    <url>/2022/06/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-Dynamic-Programming/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Constant-sized program to solve arbitrary input 338—— Recursion or Looping.</p></blockquote><p>6.006描述算法的核心在于 “constant-sized program to solve arbitrary input”。所以整门课程的大多算法都与 <b>递归</b> 或 <b>循环</b> 有关。对于一些我们已知的问题，我们可以 reduce to a problem we already know 。比如使用搜索算法、排序算法以及图算法等来解决相应的问题；而这一部分重点关注的是 <b>如何设计递归算法</b> ，并给出一个 <b>设计范式（SRTBOT）</b>。</p><div class="tips"><p><b>子问题图</b></p><p>Recursive algorithm implies a graph of computation.</p><p>子问题图能够清晰的表达子问题以及子问题之间的依赖关系。</p><p>自底向上的动态规划算法就是按照拓扑序来求解子问题。即，对于任何子问题，直至它 <b>依赖的所有子问题均已求解完成（所有入度/出度边被砍掉）</b> 才会去求解它。</p></div><details open><summary><span class="pre-summary">&nbsp;</span><b>Review from 6.006</b></summary><p><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/pics-master/202208271745831.png" alt=""></p></details><p>对于动态规划问题，主要分为以下几个角度来切入：</p><ol><li class="lvl-3"><p><strong>什么时候需要适用动态规划算法？</strong></p><p>最优子结构（optimal substructure） 与 子问题重叠（overlapping subproblem）。</p></li><li class="lvl-3"><p><strong>如何适用SRTBOT来设计DP算法？</strong></p><p>定义子问题及其之间的关系（状态转移方程）。</p></li><li class="lvl-3"><p><strong>常见的DP题目有哪些类型？逐个击破。</strong></p><p>LCS, LIS, Fibonacci… the lists goes on.</p></li></ol><h2 id="使用场景-4">使用场景</h2><blockquote><p>关注最优值与最优解（的重构）。</p></blockquote><p>动态规划通常用来解决 <b>最优化问题</b>。</p><p>We typically apply dynamic programming to <b>counting/optimization problems</b>.</p><p>最优化问题的定义是：一个问题有很多种可行解，我们要从这些可行解中选出具有 <b>最优值</b>（人为选择最优的概念，比如最大或最小值）的解。</p><p>最优解很可能不止一个，即多种可行解都具有相同的最优值。</p><p>根据题目的不同要求，有的题目只需要求出最优值，而有的题目需要更进一步 <b>重构出最优解</b>。</p><p>Such problems can have many possible solutions. Each solution has a value, and we wish to find a solution with the optimal (minimum or maximum) value. We call such a solution <b>an</b> optimal solution to the problem, as opposed to <b>the</b> optimal solution, since there may be <b>several</b> solutions that achieve the optimal value.</p><p>划分子问题时，都需要做出一个选择，每次选择会产生一个或者多个待解的子问题。而解的重构通常也比较简单，我们将每个子问题所作的选择存入表中即可。</p><h2 id="适用情况-3">适用情况</h2><div class="success"><p>确定使用前提是使用动态规划的第一步，即，<b>在什么情况下我们应该寻求用动态规划方法来解决问题呢？</b></p></div><p>适合应用动态规划方法求解的最优化问题应该具备的两个要素：子问题重叠 与 最优子结构。</p><h3 id="子问题重叠">子问题重叠</h3><p><strong>子问题重叠（overlapping subproblem）</strong>：即不同的子问题具有公共的子问题。直接结果就是造成大量重复计算。</p><p>动态规划与分治相似，都是通过 <b>组合子问题的解</b> 来求解原问题。区别在于，分治法每次将问题二分，即子问题之间互不相交；而动态规划则应用于子问题重叠的情况，即不同的子问题会有公共的子问题。</p><p>如何判断子问题是否重叠？观察同样的子问题是否有重复计算即可。从子问题图上来看，子问题重叠即<b>存在节点的入度大于1</b>（DAG， in-degree &gt; 1）。</p><p>处理不同子问题的时候，如果每次对于重叠的子子问题都再计算一遍，显然十分的浪费。动态规划对每个子问题只求解一次，具体的方法则有 <b>自顶向下（递归+备忘）</b> 和 <b>自底向上（拓扑序）</b> 两种，后面会详细讲解。</p><h3 id="最优子结构">最优子结构</h3><p><strong>最优子结构（optimal substructure）</strong>：问题的最优解由相关子问题的最优解组合而成，而这些子问题可以独立求解。</p><p>如何判断问题具有最优子结构：<strong>子问题无关（independent）</strong>。即同一个原问题的其中一个子问题的解不会影响另一个子问题的解。</p><p>值得注意的是，最优子结构是使用动态规划的必要条件而非充分条件。事实上，最优子结构常常意味着应该使用 <b>贪心算法</b>。</p><p>除此之外，还有一个重要的概念就是针对状态的 <b>无后效性</b>。</p><h3 id="无后效性">无后效性</h3><ul class="lvl-0"><li class="lvl-2"><p>一旦当前状态确定，就不会再改变。</p></li><li class="lvl-2"><p>未来的状态只决定于已有的一个或若干个状态。</p></li></ul><p>无后效性会影响 状态转移方程 与 空间压缩 的设计。</p><ul class="lvl-0"><li class="lvl-2"><p>状态转移方程：如果当前设计的状态之间的转移不满足无后效性，不妨把状态进行升维，即增加参数扩大子问题规模。</p></li><li class="lvl-2"><p>空间压缩：对于能够划分状态阶段的问题，我们可以尝试将多维的状态压缩至较低维度。即当前状态只和前面有限个状态有关。</p></li></ul><h3 id="最优化问题">最优化问题</h3><p>很多问题难以从表面看出其存在子问题重叠与最优子结构的特性，那么动态规划作为题解的另外一个很显著的特点就是 <strong>最优化问题</strong>。</p><h2 id="两种实现">两种实现</h2><h3 id="带备忘的自顶向下法-top-down-with-memoization">带备忘的自顶向下法 top-down with memoization</h3><p>递归 + 备忘（Memoization），付出额外的内存空间记录已经求解过的子问题解，从而节省计算时间，典型的时空权衡（time-memory trade-off）。</p><p>Recurse but re-use: record and lookup subproblem solutions.</p><h3 id="自底向上法-bottom-up-method">自底向上法 bottom-up method</h3><p>按照子问题图的拓扑序来求解子问题防止重复计算。即，当某个子问题需要其他子子问题的解时，我们先求得这些子子问题的解。</p><p>Careful brute force: do each subproblem in (topological) order.</p><p>二者的效率对比上：</p><p>In general practice, if all subproblems must be solved at least once, a bottom-up dynamic-programming algorithm usually outperforms the corresponding top-down memoized algorithm by a constant factor, because the bottom-up algorithm has no overhead for recursion and less overhead for maintaining the table. Moreover, for some problems we can exploit the regular pattern of table accesses in the dynamic programming algorithm to reduce time or space requirements even further. Alternatively, if some subproblems in the subproblem space need not be solved at all, the memoized solution has the advantage of solving only those subproblems that are definitely required.</p><ul class="lvl-0"><li class="lvl-2"><p>自底向上没有 <b>递归调用</b> 和 <b>维护备忘表</b> 的开销；</p></li><li class="lvl-2"><p>自底向上会把所有子问题的解求出来，有些情况我们并不需要计算所有子问题，此时备忘的自顶向下方式就体现出优势了，因为其只计算必要的子问题。</p></li></ul><h2 id="SRTBOT">SRTBOT</h2><blockquote><p>设计属于自己的递归算法的一套范式。这并非仅限于动态规划，而是一种解决大规模数据适用的设计范式。</p></blockquote><p><strong>How to Solve a Problem Recursively？</strong></p><ol><li class="lvl-3"><p><b>Subproblem</b>: 定义子问题。是整个范式中最难的部分，有多种方法来辅助定义，后面会详细说明。</p></li><li class="lvl-3"><p><b>Relate</b>: 写出子问题之间的关系，也就是我们常说的，定义 <b>状态转移方程</b>；</p></li><li class="lvl-3"><p><b>Topological Order</b>: 子问题求解的顺序</p></li><li class="lvl-3"><p><b>Base</b>: 边界情况</p></li><li class="lvl-3"><p><b>Original</b>: 通过子问题最终求解出来的原问题</p><p>Reconstruct: possibly use parent pointers to recover actual solution, that is,  store parent pointers to reconstruct subsequence.</p></li><li class="lvl-3"><p><b>Time</b>: 算法的时间效率</p></li></ol><p>以上六步中，3-6条是比较显而易见的步骤。对于复杂的问题来说，最难的点就在于 <b>发现对DP的需求</b>、<b>定义子问题</b>，并 <b>定义子问题之间的求解关系 / 写出状态转移方程</b> 。</p><blockquote><p>Hard part is thinking inductively to construct recurrence on <strong>subproblems</strong>.</p></blockquote><h3 id="1-Subproblem-定义子问题">1 Subproblem 定义子问题</h3><blockquote><p>一个值得注意的常识：</p><ul class="lvl-1"><li class="lvl-2"><p><b>substring</b> 指的是连续的子序列，如 $(1, 2, 3)$；</p><p>遍历一个序列的所有substring的时间复杂度为 $O(n^2)$。显而易见。</p></li><li class="lvl-2"><p><b>subsequence</b> 指的是可以不连续的子序列，任意子元素按照其相对顺序排列即可，如 $(1, 3, 5)$；</p><p>遍历一个序列的所有subsequence的时间复杂度为 $O(2^n)$。即对每个元素都要决定其选或者不选。</p></li></ul></blockquote><p>A general tool for subproblem design. Good subproblems are:</p><ul class="lvl-0"><li class="lvl-2"><p>prefixes: $x[0\ldots i], \space \Theta(n)$ ；</p></li><li class="lvl-2"><p>suffixes: $x[i\ldots n], \space \Theta(n)$；</p></li><li class="lvl-2"><p>substring: $x[i\ldots j], \space \Theta(n^2)$。</p></li></ul><h4 id="Subproblem-Expansion-Constraints-2">Subproblem Expansion &amp; Constraints</h4><ul class="lvl-0"><li class="lvl-2"><p>If you find yourself lacking information to check the desired conditions of the problem, or lack the natural subproblem to recurse on, try subproblem constraint/expansion!</p></li><li class="lvl-2"><p>More subproblems and constraints give the relation more to work with, so can make DP more feasible</p></li><li class="lvl-2"><p>Usually a trade-off between number of subproblems and branching/complexity of relation</p><p>子问题规模扩展，即通过 增加子问题数量 来 降低子问题之间关系的复杂性 。</p><p>从 <b>无后效性</b> 的角度来看，如果当前设计的状态之间的转移不满足无后效性，不妨把状态进行<b>升维</b>，即增加参数扩大子问题规模。</p></li></ul><p>常见的子问题扩展情况</p><ul class="lvl-0"><li class="lvl-2"><p>Often record partial state: add subproblems by <b>incrementing some auxiliary variables</b></p><p>比如：Alternating Coin Game，<b>股票类题目</b></p></li><li class="lvl-2"><p>Often multiply possible subsets across multiple inputs</p><p>Subproblems for <b>multiple inputs</b> (多个输入，比如LCS有两个字符串作为输入): multiply subproblem spaces - get the product. (二维DP)</p><p>比如：LCS</p></li></ul><h4 id="常见的子问题定义技巧">常见的子问题定义技巧</h4><ul class="lvl-0"><li class="lvl-2"><p>不是单纯的缩小规模，而是要求某点为<b>边界</b>；</p><ul class="lvl-2"><li class="lvl-5"><p>一维：以某点为<b>结尾（prefix）/ 起点（suffix）</b>的最优解</p></li><li class="lvl-5"><p>二维：以某点为<b>右下角（prefix）/ 左上角（suffix）</b>的最优解</p></li></ul><p>这种情况下要注意原问题的定义。</p></li></ul><h3 id="2-Relate-求解子问题之间的关系">2 Relate 求解子问题之间的关系</h3><blockquote><p>How to relate subproblem solutions ?</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>确保问题规模能够越来越小</p><p>Identify a question about a subproblem solution that, if you knew the answer to, reduces the subproblem to smaller subproblem(s)</p></li><li class="lvl-2"><p>定义了合适的子问题之后，就是简单的在本地暴力求最优解</p><p>Locally brute-force all possible answers to the question</p></li></ul><h3 id="3-实例">3 实例</h3><h4 id="Bowling-2">Bowling</h4><h4 id="Alternating-Coin-Game">Alternating Coin Game</h4><h4 id="Bellman-Ford">Bellman-Ford</h4><h2 id="空间压缩-2">空间压缩</h2><p>使用滚动数组进行空间复杂度上的优化。</p><ul class="lvl-0"><li class="lvl-2"><p>一维：压缩至原地，<code>dp[i]</code>仅与<code>dp[i - 1]</code>和<code>dp[i - 2]</code>相关。</p></li><li class="lvl-2"><p>二维：压缩至一维。</p></li></ul><h2 id="分类-4">分类</h2><h3 id="基本一维DP">基本一维DP</h3><ul class="lvl-0"><li class="lvl-2"><p>70 Climbing Stairs 爬楼梯 (Easy)</p><p>Fibonacci，注意 边界条件 和 空间压缩。</p></li><li class="lvl-2"><p>198 House Robber 打家劫舍 (Medium)</p><p>难以寻找暴力解法  + 显而易见可以缩小的问题规模 —— 尝试SRTBOT：</p><ul class="lvl-2"><li class="lvl-4"><p>Subproblem: using prefix, $dp[i]$ 表示能够获得的最高金额。</p></li><li class="lvl-4"><p>Relate: $dp[i] = max{dp[i - 1], dp[i - 2] + nums[i]}$  待选方案分别代表两种不同选择：</p><ol><li class="lvl-7">抢第 $i$ 家：那么第 $i - 1$ 家必定不抢，此时只需要考虑前 $i - 2$ 家抢劫的最大值即可，即 $dp[i - 2] + nums[i]$</li><li class="lvl-7">不抢第 $i$ 家：意味着第 $i - 1$ 家可以抢（但未必会抢），取决于前 $i - 1$ 家抢劫的最大值，即 $dp[i - 1]$</li></ol></li><li class="lvl-4"><p>Topological Order: Increasing $i$</p></li><li class="lvl-4"><p>Base: $dp[0] = nums[0]$，$dp[1] = max{nums[0], nums[1]}$</p></li><li class="lvl-4"><p>Original Problem: $dp[n - 1]$</p></li><li class="lvl-4"><p>Time: $O(n)$</p></li></ul><p>空间压缩：进一步使用滚动数组，可以将空间复杂度降低至 $O(1)$。</p></li><li class="lvl-2"><p>213 House Robber II 打家劫舍 (Medium)</p><p>与198的区别在于不能同时抢第一家和最后一家——增加限制——升维即可。增加状态“抢第0家”与“不抢第0家”。</p><p>状态转移方程与198无差，最后选择两种情况下的最大值作为答案即可。</p></li><li class="lvl-2"><p>413 Arithmetic Slices 等差数列划分 (Medium)</p><p>从暴力解法来看，从前往后每个起点，都要重新计算后面元素的间距情况，时间复杂度达到$O(n^2)$。</p><p>重点关注子问题的定义：以xxx为结尾的xxx</p><p>SRTBOT：</p><ul class="lvl-2"><li class="lvl-4"><p>Subproblem: 取 prefix，$dp[i]$ 表示以 $nums[i]$ 为<b>结尾</b>的等差数列的数量</p></li><li class="lvl-4"><p>Relate:<br>$$<br>dp[i] = \begin{cases} dp[i - 1] +  1 &amp;&amp; nums[i] - nums[i - 1] = nums[i - 1] - nums[i - 2] \ 0 &amp;&amp; else \end{cases}<br>$$</p></li><li class="lvl-4"><p>Topological Order: Increasing $$</p></li><li class="lvl-4"><p>Base: $dp[0] = 0$，$dp[1] = 0$，$dp[2]=(nums[1] - nums[0] == nums[2] - nums[1])\space ?\space 1 : 0$</p></li><li class="lvl-4"><p>Original Problem: $\sum\limits^{n - 1}_{i = 0} dp[i]$，对 $dp$ 数组求和</p></li><li class="lvl-4"><p>Time: $T(n) + T(n) = O(n)$</p></li></ul><p>空间压缩：根据状态转换方程，显然可以将空间复杂度降低至 $O(1)$</p></li><li class="lvl-2"><p>650 2 Keys Keyboard 只有两个键的键盘 (Medium)</p><p>解法一：DP</p><p>从题面上来看，是一道 <b>最优化问题（最少的操作次数）</b>且 <b>题目规模显然可以缩小</b>，尝试使用SRTBOT：</p><ul class="lvl-2"><li class="lvl-4"><p>Subproblem: $dp[i]$ 代表输出 $i$ 个 <code>A</code> 的最少操作次数</p></li><li class="lvl-4"><p>Relate:<br>$$<br>dp[i] = \mathop{min}\limits_{i\space % \space j=0 } { dp[j] + i / j }<br>$$<br>即找出 $i$ 的因数，如 $i = 8$ ，$j = 2$ 时，需要 1 次复制 + 3 次粘贴，即 $i / j$ 次额外操作。</p></li><li class="lvl-4"><p>Topological Order: Increasing $i$ and $j$</p><p>内层的 $j$ 不必从 $0$ 到 $i$ 完全遍历，可以根据其含义进行剪枝：</p><ul class="lvl-4"><li class="lvl-6"><p>初步优化：$j &lt;= i / 2$，显然更大的时候必定无法构成 $i$ ；</p><p>此时内层复杂度优化了一半。</p></li><li class="lvl-6"><p>进一步优化：从 <b>因数</b> 的角度考虑，$j$ 必定为 $i$ 的因数，所以 $i$ 会被分为 $j$ 与 $i / j$ ，二者必定一大一小。</p><p>此时，我们可以使 $j * j &lt;= i$，并在每次循环时同时考虑 $j$ 与 $i / j$ 的情况。此时内层复杂度降低至 $O(\sqrt i)$。</p></li></ul></li><li class="lvl-4"><p>Base: $dp[1] = 0$，1个 <code>A</code> 的情况无需操作</p></li><li class="lvl-4"><p>Original Problem: $dp[n]$</p></li><li class="lvl-4"><p>Time: 经过剪枝优化后，$O(n\sqrt n)$。</p></li></ul><p>解法二：质因数分解</p><p>通过上面的解法，我们能概括出求解的基本操作，即“1 次 Copy All + x 次 Paste”。</p><p>整体流程最终可以等价概括如下：</p><ol><li class="lvl-5"><p>起始长度为 1，对其进行 1 次复制 + $k_1 - 1$ 次粘贴，此时长度为 $k_1$，操作次数为 $k_1$；</p></li><li class="lvl-5"><p>此时长度为 $k_1$，对其进行 1 次复制 + $k_2 - 1$ 次粘贴，此时长度为 $k_1 \times k_2$，操作次数为 $k_1 + k _2$ ；</p><p>…</p></li></ol><p>最终我们想要得到长度为 $n$ 的串，经过 $x$ 次操作后，即有:<br>$$<br>n = k_1 \times k_2 \times … \times k_x<br>$$<br>而此时的操作次数为：<br>$$<br>n = k_1 + k_2 +… + k_x<br>$$<br>此时我们的欲求问题转换为，<b>如何对 $n$ 进行因数分解，使得其所有因数的加和最小</b>。</p><p>利用一个不等式来帮助我们的证明：当 $a, b &gt; 0$ 时，$a\times b &gt;= a +b$ 。</p><p>对于任意一个合数 $k_i$ ，我们将其分解为 $k_{i1} \times k_{i2}$。如果我们将其拆分为 $k_{i1}$ 和 $k_{i2}$，那么我们的消耗就会从 $k_i = k_{i1} \times k_{i2}$ 降至 $k_{i1} + k_{i2}$ ，因为 $k_{i1} \times k_{i2} &gt;= k_{i1} + k_{i2}$ 。所以进一步对合数因数进行拆分必定会使得消耗减少。</p><p>综上，我们只需要将 $n$ 进行质因数分解即可。最终加和所有的操作次数即为答案。</p><p>质因数分解的方式就是，从最小的质数2开始尝试能否整除，能的话就继续整除后继续检查至不能整除，再换下一个质数来继续重复同样的尝试。尝试的上限是 $\sqrt n$。</p><p>时间复杂度为最优，$O(\sqrt n)$。</p></li><li class="lvl-2"><p>53 Maximum Subarray 最大子数组和 (Medium)</p><p>解法一：动态规划</p><ul class="lvl-2"><li class="lvl-4"><p>Subproblem: $dp[i]$ 以 $nums[i - 1]$ 为结尾的子数组的最大和</p></li><li class="lvl-4"><p>Relate: $dp[i] = max(nums[i - 1], dp[i - 1] + nums[i - 1])$  即两种选择：</p><ol><li class="lvl-7">$nums[i]$ 为开头重新开始构成子数组，即前半部分总和为负数，对后面没有贡献；</li><li class="lvl-7">$nums[i]$ 接在前面子数组的最后，即前半部分总和为正数。</li></ol></li><li class="lvl-4"><p>Topological Order: Increasing $i$</p></li><li class="lvl-4"><p>Base: $nums[0] = 0$，初始情况为空</p></li><li class="lvl-4"><p>Original Problem: $\mathop{max}\limits_{1\leq i \leq n}{dp[i]}$</p></li><li class="lvl-4"><p>Time: $O(n)$</p><p>空间压缩后，空间复杂度优化为常数。</p></li></ul><p>解法二：分治</p></li><li class="lvl-2"><p>1824 Minimum Sideway Jumps 最少横跳次数（Medium）</p><p>子问题扩展 - 状态升维。</p></li></ul><h3 id="基本二维DP">基本二维DP</h3><blockquote><p>二维DP的一些注意事项：</p><ul class="lvl-1"><li class="lvl-2">常常借助 <b>子问题图</b> 来更清晰的理解状态转换的过程。</li><li class="lvl-2">二维的 <b>空间压缩</b> ：LC 64，LC 1143</li></ul></blockquote><ul class="lvl-0"><li class="lvl-2"><p>64 Minimum Path Sum 最小路径和 (Medium)</p><p>本题重点关注二维DP的空间优化。</p><p>SRTBOT：</p><ul class="lvl-2"><li class="lvl-4"><p>Subproblem: 二维 prefix, $dp[i][j]$ 表示至 $(i, j)$ 点的最短路径长</p></li><li class="lvl-4"><p>Relate: $dp[i][j] = min{dp[i - 1][j], dp[i][j - 1]} + grid[i][j]$ ，要么从上面来，要么从左边来，选其中最小的</p></li><li class="lvl-4"><p>Topological Order: Increasing $i$ and $j$</p></li><li class="lvl-4"><p>Base: 对于点 $(x, y)$ ，满足 $x = 0$ 或 $y = 0$ 的点均为边界条件</p></li><li class="lvl-4"><p>Original Problem: $dp[m - 1][n - 1]$</p></li><li class="lvl-4"><p>Time: $O(mn)$</p></li></ul><p><b>空间压缩</b>：将二维压缩至一维。相当于一行一行更新。注意哪部分是已更新（左侧和上半部分），哪部分未更新。</p><p>压缩后的状态转移方程：$dp[j] = min(dp[j], dp[j - 1]) + grid[i][j]$ ，其中两个选项分别代表：</p><ul class="lvl-2"><li class="lvl-4"><p>$dp[j]$ ：上方元素，此时还未更新，仍为上一行的值，即 $dp[j] = dp[i -1][j]$；</p></li><li class="lvl-4"><p>$dp[j - 1]$：左侧元素，此时已更新，为当前行左侧值，即 $dp[j - 1] = dp[i][j - 1]$ 。</p></li></ul></li><li class="lvl-2"><p><strong>542 01 Matrix 01矩阵 (Medium)</strong></p><p>解法一：</p><p><b>多次扫描</b> 的DP</p><p>SRTBOT：</p><ul class="lvl-2"><li class="lvl-4"><p>Subproblem: 二维，$dp[i][j]$ 就代表最终的答案，即到最近的0的距离</p></li><li class="lvl-4"><p>Relate: 来自上下左右四个方向的最小值即为最终答案。分两次（行优先）遍历实现：</p><ul class="lvl-4"><li class="lvl-6">第一次顺序：行优先的顺序即从左上到右下，每一个点的左侧与上侧均已更新，选择二者中的较小值；</li><li class="lvl-6">第二次逆序：行优先的逆序即从右下到左上，每一个点的右侧与下侧均已更新，选择二者中的较小值；</li></ul><p>如上两次扫描即可选出上下左右四个方向中的最小值。</p><p>相比于 分类讨论上下左右 与 上下左右分四次扫描 的两种方式，这种方式显然在逻辑与速度上是最优的。</p></li><li class="lvl-4"><p>Topological Order: 两次扫描分别是不同的顺序</p></li><li class="lvl-4"><p>Base: 所有为值为0的点答案初始化为0，值为1的点初始化为 <code>INT_MAX - 1</code> （<i>减一是因为后面扫描过程中要加一，防止溢出</i>）</p></li><li class="lvl-4"><p>Original Problem: $dp$ 数组即为欲求答案</p></li><li class="lvl-4"><p>Time: 线性时间 $O(mn)$</p></li></ul><p>解法二：BFS</p><p>先将所有值为0的点入队，再进行一次BFS即可得到答案。</p></li><li class="lvl-2"><p><strong>221 Maximal Square 最大正方形 (Medium)</strong></p><p>暴力解法：每个点向外扩张搜索，显然时间复杂度会爆炸至$O(m^2n)$。</p><p>SRTBOT：</p><ul class="lvl-2"><li class="lvl-4"><p>Subproblem: $dp[i][j]$ 表示以点 $(i, j)$ 为 <b>右下角</b> 的正方形的最大边长；</p></li><li class="lvl-4"><p>Relate: 这个子问题之间的关系是比较难以看出的，结合图示来理解。<br>$$<br>dp[i][j] = min{dp[i - 1][j-1], dp[i - 1][j], dp[i][j - 1]} + 1<br>$$<br><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/pics-master/202208301414549.png" alt=""></p><p><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/pics-master/202208301426836.png" alt=""></p></li><li class="lvl-4"><p>Topological Order: Increasing $i$ and $j$</p></li><li class="lvl-4"><p>Base: 因为要考虑来自左上、左和上三个方向，所以左侧边和上侧边为边界条件。<br>$$<br>dp[i][j] = matrix[i][j] \space \space , if \space i=0 \space or \space j = 0<br>$$</p></li><li class="lvl-4"><p>Original Problem: 所有 $dp[i][j]$ 中的最大值（的平方）</p></li><li class="lvl-4"><p>Time: $O(mn)$</p></li></ul><p>存在空间压缩的可能，需要用到临时变量。</p></li><li class="lvl-2"><p>1277 统计全为1的正方形子矩阵 (Medium)</p><p>跟221一样的题目，只是最后 Original Problem 为对 $dp$ 数组求和。</p></li><li class="lvl-2"><p>1143 Longest Common Subsequence 最长公共子序列 (Medium)</p><p>下面LCS会讲。</p></li></ul><h3 id="分割">分割</h3><blockquote><p>分割类型问题的子问题定义并不复杂，关键在于找到子问题之间的联系，即如何定义状态转移方程。</p><p>难以找到和相邻位置的关系，在求状态转移方程时难以在本地完成，需要在所有可能的解中进行本地暴力判断。</p><p>分割的含义时 $dp[i]$ 的含义与相邻位置（$dp[i-  1],dp[i-2]$ 等）无关，那么我们要在小于 $i$ 的部分做出所有可能的切割方案，并本地暴力求出其中的最优解。</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>279 Perfect Squares 完全平方数 (Medium)</p><p>解法一：</p><p>规模显然可以缩小，存在最优子结构。尝试SRTBOT：</p><ul class="lvl-2"><li class="lvl-4"><p>Subproblem: 选择 prefix , $dp[i]$ 表示和为 $i$ 的完全平方数的最少数量；</p></li><li class="lvl-4"><p>Relate: 分析后发现，虽然是一维的前缀，但是<b>很难找到和相邻位置的关系</b>，应该在本地暴力的选出所有可能的解中的最小值（locally brute force）。</p><p>不断切掉平方数的部分，找出所有解中的最小值。<br>$$<br>dp[i] = \mathop{min}_{j=1}^{j * j &lt;=i}{dp[j]} + 1<br>$$</p></li><li class="lvl-4"><p>Topological Order: Increasing $i$</p></li><li class="lvl-4"><p>Base: $dp[0] = 0$ ，代表 $i$ 本身就是平方数的情况。</p></li><li class="lvl-4"><p>Original Problem: $dp[n]$</p></li><li class="lvl-4"><p>Time: 外层为线性 $O(n)$ ，内层显然渐进复杂度应该为 $O(\sqrt{n})$，故总复杂度为 $O(n\sqrt{n})$。</p></li></ul><p>解法二：</p><p>一个拥有更低时间复杂度的数学解法使用：四平方和定理。</p><p>首先四平方和定理给出了上界：任意一个正整数都可以表示为至多四个正整数的平方和。</p><p>其余结论如下：</p><ul class="lvl-2"><li class="lvl-4"><p>当 $n = 4^k \times (8m + 7)$ 时：$n$ 只能表示为四个正整数的平方和，即 $n=4$ ；</p></li><li class="lvl-4"><p>当 $n\neq 4^k \times (8m + 7)$ 时：$n$ 可以被表示为至多三个正整数的平方和。此时：</p><ul class="lvl-4"><li class="lvl-6"><p>当 $n$ 为完全平方数时，答案为 1 ；</p></li><li class="lvl-6"><p>当 $n=a^2 + b^2$ 时，答案为 2 ；</p><p>此时，枚举所有的 $a(1 \leq a \leq \sqrt n)$，判断 $n - a^2$ 是否为完全平方数即可。</p></li><li class="lvl-6"><p>答案为 3 的情况难以判断，我们通过排除法检查前两种情况即可。</p></li></ul></li></ul></li><li class="lvl-2"><p><strong>139 Word Break 单词拆分 (Medium)</strong></p><p>解法一：动态规划</p><p>DFS 爆搜显然会存在大量重复操作/重叠子问题，且后面的状态与前面部分子问题的状态相关，尝试SRTBOT：</p><ul class="lvl-2"><li class="lvl-4"><p>Subproblem: $dp[i]$  代表从 $0$ 到 $i - 1$ 的字符串能否用字典中的词来构成；</p></li><li class="lvl-4"><p>Relate: $ dp[i] = dp[j] \space \verb’&amp;’ \verb’&amp;’ \space check(s[j…i-1])$</p></li><li class="lvl-4"><p>Topological Order: Increasing $i$，decreasing $j$</p><p>$j$ 为逆序遍历，便于剪枝：当前访问的字串长度已经超过了最长单词长度时，退出循环。</p></li><li class="lvl-4"><p>Base: $dp[0] = true$，代表哨兵，相当于前半部分整个单词完全匹配的情况；</p></li><li class="lvl-4"><p>Original Problem: $dp[s.size()]$</p></li><li class="lvl-4"><p>Time:</p><ul class="lvl-4"><li class="lvl-6">$j$ 在内层要对小于 $i$ 的情况遍历，为 $O(n)$；</li><li class="lvl-6">外层也是线性；</li></ul><p>综上，时间复杂度为 $O(n^2)$ 。</p></li></ul><p>解法二：字典树 + DFS + 记忆化搜索</p><p>只实现了字典树爆搜，memoization日后挑战实现。</p></li><li class="lvl-2"><p>343 Integer Break 整数拆分 (Medium)</p><p>DP特征：</p><ul class="lvl-2"><li class="lvl-4"><p>最优化问题：最大乘积；</p></li><li class="lvl-4"><p>重叠子问题：多次重复使用同一中间范围的解；</p></li><li class="lvl-4"><p>最优子结构：可缩小问题规模；</p></li><li class="lvl-4"><p>拆分：有可能是切割类型DP，需要多一层遍历来对比切割方案的结果；</p></li></ul><p>解法一：动态规划</p><ul class="lvl-2"><li class="lvl-4"><p>Subproblem: 定义 $dp[i]$, 代表 $i$ 拆分后对应的最大乘积</p></li><li class="lvl-4"><p>Relate:<br>$$<br>dp[i] = \mathop{max}\limits_{0&lt;\space j&lt;= \space i/2}{j \times  max{i - j, dp[i - j]}}<br>$$<br>即，从小到大依次切掉 $j$ （即该部分不拆），剩余部分对比 拆 或 不拆 选出最优解。</p></li><li class="lvl-4"><p>Topological Order: Increasing i and j</p></li><li class="lvl-4"><p>Base: $dp[1] = 1$</p></li><li class="lvl-4"><p>Original Problem: $dp[n]$</p></li><li class="lvl-4"><p>Time: $O(n^2)$</p></li></ul><p>解法二：动态规划的数学优化</p><p>我们列出从 2 到 10 的结果，来观察其规律：</p><table><thead><tr><th>$i$</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td>$dp[i]$</td><td>1</td><td>2</td><td>4</td><td>6</td><td>9</td><td>12</td><td>18</td><td>27</td><td>36</td></tr></tbody></table><p>我们能够发现，当 $i &gt; 3$ 时，有 $dp[i] &gt; i$，即此时一定会选择拆分，因为拆分后结果更大。那么原问题就缩减为如下情况：2 与 3 的部分一定不拆，而剩余部分必定会拆。减少了内层循环后，状态转移方程变为：<br>$$<br>dp[i] = max{ 2 \times dp[i - 2], 3 \times dp[i - 3]}<br>$$<br>此时，时间复杂度优化至线性。注意 $n &lt;= 3$的情况，单独处理即可。</p><p>解法三：数学综上可以得到结论：</p><ul class="lvl-2"><li class="lvl-4"><p>当 $i &gt; 3$ 时，一定会进行拆分；</p></li><li class="lvl-4"><p>当 $i &lt;= 3$ 时，不会被拆分；由此可以推断：</p></li></ul><ol><li class="lvl-5"><p>当 $n &gt; 3$ 时，原数一定会被拆分为若干个 2 和 3。</p></li></ol><p>接下来要确定的就是 2 和 3 的个数，考虑其最小公倍数 6 的情况：<br>$$<br>2 \times 2 \times 2 &lt; 3 \times 3<br>$$<br>可以确定：<br>2. 最终拆分结果中 2 的个数一定不会超过 3 个。因为 3 个 2 以上的情况都会被 3 所代替。</p><p>根据以上两个条件，我们可以获得答案。根据 $ n % 3 $ 的结果，答案分为以下几种情况：</p><ul class="lvl-2"><li class="lvl-4"><p>$n % 3 = 0$: 拆分为若干个 3 ;</p></li><li class="lvl-4"><p>$n % 3 = 1$: 拆分为若干个 3 + 1 个 4（即 2 个 2）；</p></li><li class="lvl-4"><p>$n % 3 = 2$: 拆分为若干个 3 + 1 个 2；</p></li></ul><p>数学方法可以在原地时间内立刻完成解答判断，是最快的解决方法。更详细的数学证明见 LeetCode 官方题解。</p></li></ul><h3 id="子序列-Subsequence">子序列 Subsequence</h3><h4 id="LCS-最长公共子序列">LCS 最长公共子序列</h4><ul class="lvl-0"><li class="lvl-2"><p>1143 Longest Common Subsequence 最长公共子序列 (Medium)</p><p>实际应用场景：其实最长公共子序列相当于对两个序列做一个 <b>相似度</b> 的判断。</p><p>暴力搜索：必定存在穷举子序列的情况，即对每一个元素有选、或者不选两种情况，运行时间必定会达到指数级（exponential）。且题目显然可以缩小规模，存在最优子结构，所以使用SRTBOT：</p><ul class="lvl-2"><li class="lvl-4"><p>Subproblems: 二维的prefix，$dp[i][j]$ 代表以 $i, j$ 为结尾部分两个字串的LCS；</p></li><li class="lvl-4"><p>Relate: 二维的DP可以通过子问题图来加深对状态转换的理解。</p><p><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/pics-master/202209031219880.png" alt=""><br>$$<br>dp[i][j] = \begin{cases} 0 &amp; \mbox{if} \space i = 0 \space \mbox{or} \space j = 0 \<br>dp[i-1,j-1] + 1 &amp; \mbox{if}\space i,j &gt; 0 \space \mbox{and} \space text1[i] = text[j] \<br>\mbox{max}(dp[i- 1][j], dp[i][j-1]) &amp; \mbox{if}\space i,j &gt; 0 \space \mbox{and} \space text1[i] \neq text[j]<br>\end{cases}d<br>$$</p></li><li class="lvl-4"><p>Topological Order: 行优先（row-major order）或者列优先（column-major order）均可，对状态转换方程做微调即可。</p></li><li class="lvl-4"><p>Base: 即状态转移方程中第一行，行或列坐标为0时；</p></li><li class="lvl-4"><p>Original Problem: $dp[text1.size()][text2.size()]$</p></li><li class="lvl-4"><p>Time: $O(n^2)$</p></li></ul><p><b>解的重构：构造LCS</b></p><p>维护一个指明状态转移方向的表 $path$，构造一个递归程序（由内向外）来打印出具体的路径。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printLCS</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; path, string&amp; s, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(x == <span class="hljs-number">0</span> || y == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(path[x][y] == <span class="hljs-number">0</span>) &#123;      <span class="hljs-comment">// 0代表左上，即当前字符相同</span><br>        <span class="hljs-built_in">printLCS</span>(path, s, x - <span class="hljs-number">1</span>, y - <span class="hljs-number">1</span>);<br>        cout &lt;&lt; s[x - <span class="hljs-number">1</span>];<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(path[x][y] == <span class="hljs-number">1</span>) &#123;      <span class="hljs-comment">// 1代表 上</span><br>        <span class="hljs-built_in">printLCS</span>(path, s, x - <span class="hljs-number">1</span>, y);<br>    &#125; <span class="hljs-keyword">else</span> &#123;     <span class="hljs-comment">// if(path[x][y] == 2)     2代表 </span><br>        <span class="hljs-built_in">printLCS</span>(path, s, x, y - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>要注意的是，如果想要实现解的重构，就不能使用滚动数组来对空间进行优化，即至少需要 $O(m\times n)$ 的空间储存信息才能实现解的重构。</p><p><b>空间优化</b></p><p>二维滚动数组的压缩，特别要注意哪部分值是已更新过的，哪部分值是未更更新过的。</p><p>分析：$dp[i][j]$ 的更新有三个方向的来源，分别是左上对角线、左侧、和上侧。</p><ul class="lvl-2"><li class="lvl-4"><p>首先看选择左侧和上侧最小值的情况，此时很容易进行压缩：因为左侧的值处于已更新状态，上侧的值处于未更新状态，与我们想要得到的值状态一致，可以直接压缩至一维；</p></li><li class="lvl-4"><p>再来看来自左上对角线的情况，此时我们希望得到的是未更新的左上值，但是如果完全压缩至一维的情况，该值此时已被更新为左侧值，而非左上对角线的实际值，所以我们需要引入辅助数组。</p></li></ul><p>辅助的方式很多样，此处仅做一例：构建两个 $dp$ 数组，$prev$ 与 $curr$ 分别代表上一行与当前行的值。此时状态转移方程为：<br>$$<br>curr[j] = \begin{cases} 0 &amp; \mbox{if} \space i = 0 \space \mbox{or} \space j = 0 \<br>prev[j-1] + 1 &amp; \mbox{if}\space i,j &gt; 0 \space \mbox{and} \space text1[i] = text[j] \<br>\mbox{max}(prev[j], curr[j-1]) &amp; \mbox{if}\space i,j &gt; 0 \space \mbox{and} \space text1[i] \neq text[j]<br>\end{cases}<br>$$<br>每一行结束后要更新 $prev$ 与 $curr$ 的值，即 $prev = curr$ 。至此，空间压缩至线性级别。</p></li><li class="lvl-2"><p>583 Delete Operation for Two Strings 两个字符串的删除操作 (Medium)</p><p>本质就是一道LCS。这里不再赘述。</p><p>也可以直接根据题目定义直接DP。</p></li></ul><h4 id="LIS-最长递增子序列">LIS 最长递增子序列</h4><ul class="lvl-0"><li class="lvl-2"><p>300 Longest Increasing Subsequence 最长递增子序列 (Medium)</p><p>解法一：DP</p><p>暴力求解：子序列问题，对每一位都有两种选择情况，复杂度会达到指数级的 $O(2^n)$</p><p>缩小问题规模，发现每个子问题与前面的更小规模子问题相关：</p><ul class="lvl-2"><li class="lvl-4"><p>Subproblems: 采取prefixes，$dp[i]$ 代表以 <code>s[i]</code>字符为结尾的前缀的LIS最大长度；</p></li><li class="lvl-4"><p>Relate: $dp[i]=1 + max{dp[j]\space | \space 0\leq j &lt; i, s[j] &lt; s[i]} \cup {0}$</p><p>其中0代表没有比 $s[i]$ 更小的字符。</p></li><li class="lvl-4"><p>Topological order: Increasing $i$</p></li><li class="lvl-4"><p>Base Case: $dp[0] = 1$</p></li><li class="lvl-4"><p>Original Problem: $ans = max{dp[i], \space 0\leq i \leq n - 1}$</p></li><li class="lvl-4"><p>Time:</p><ol><li class="lvl-7">$O(n)$ - subproblems 子问题个数</li><li class="lvl-7">$O(n)$ - 每个子问题的运算时长</li></ol><p>二者嵌套，总时间复杂度为 $O(n^2)$，再加上最终遍历状态数组时的线性时间，复杂度仍为平方级。</p></li></ul><p><b>解法二：贪心 + 二分查找</b></p><p>比较明显的贪心思路，易于模拟：如果我们要使上升子序列尽可能的长，则我们需要让序列上升得尽可能慢，因此我们希望每次在上升子序列最后加上的那个数尽可能的小。</p><p>维护一个数组 $dp[i]$，代表长度为 $i$ 的递增子序列的最后一位的 <b>最小值</b>。当每次遇到比前面的元素更小的元素，我们要确定其在数组 $dp$ 中的位置。而 $dp$ 根据其定义与维护的过程，显然是递增的，所以使用二分来优化搜索效率。</p><p>外层仍然是线性，而内层通过二分优化至对数级。综上，时间复杂度为 $O(nlogn)$。</p><p><b>解的重构 / 输出路径</b></p><p>重构解应该使用DP解法，因为贪心的解法并不存在元素的前后关系。动态规划的解法只要增加一个类似Dijkstra中的游标数组即可实现解的重构，无论是<b>输出所有路径</b>还是<b>字典序最小的路径均</b>可通过增加判断逻辑实现。</p></li><li class="lvl-2"><p><a href="http://algorithm.openjudge.cn/2022algohw3/solution/37246429/">POJ 最大上升子序列和</a></p><p>LIS的简单变式，思路不变，只是将 $dp$ 数组的含义修改为最大的和。</p><p>重点注意 $dp$ 数组的初始化！必须设置为数组的对应值。</p></li></ul><h3 id="背包问题-Knapsack-Problem">背包问题 Knapsack Problem</h3><p>背包问题是一种组合优化的 <b>NP完全</b> 问题。其题型灵活多变。问题的基本定义如下：</p><blockquote><p>有 $n$ 件物品，每件物品的重量为 $w[i]$，价值为 $v[i]$ 。选取物品放入一个容量为 $C$ 的背包中，使得背包内物品的总价值最大。</p><p>将模型抽象为：</p><ul class="lvl-1"><li class="lvl-2"><p><b>数量</b>：$n$ 件物品</p></li><li class="lvl-2"><p><b>总容量</b>：$C$ 为背包容量</p></li><li class="lvl-2"><p><b>单位重量</b>：$w[i]$ 为第 $i$ 件物品中量</p></li><li class="lvl-2"><p>最<b>优化目标</b>：总价值最大。单位价值为 $v[i]$</p></li></ul></blockquote><p>显然，背包问题也是一个最优化问题。背包问题大体上可以分为两类：</p><ul class="lvl-0"><li class="lvl-2"><p>01背包问题：限定每种物品的数量，通常一件物品只能拿一次；</p></li><li class="lvl-2"><p>完全背包问题：不限定物品的数量，可以取任意次。</p></li></ul><p>对于背包问题，我们首先对暴力枚举的方式进行分析，每一个物品放或者不妨有两种选择，时间复杂度显然会来到指数级。我们希望使用动态规划的方式来使时间降低到多项式级。</p><h4 id="01背包">01背包</h4><p>首先考虑问题的最优子结构，显然从 <b> 物品的数量 $i$ </b>， 和 <b>背包的剩余容量 $j$  </b> 上问题规模是可缩小的。我们先根据这个子问题考虑一个最基本的SRTBOT解决方案：</p><ul class="lvl-0"><li class="lvl-2"><p>Subproblem: $dp[i][j]$ 代表前 $i$ 件物品在容量 $j$ 下能够达到的最大价值</p></li><li class="lvl-2"><p>Relate: 对于每一个物品，显然都有选或者不选两种策略，我们直接暴力选取其中更优的那个：</p><ul class="lvl-2"><li class="lvl-4">不选择第 $i$ 号物品：即在 容量 $j$ 下在前 $i - 1$ 件物品中选取，即 $dp[i- 1][j]$ ；</li><li class="lvl-4">选择第 $i$ 号物品：即前 $i - 1$ 件物品要在 $j - v[i]$ 的容量中选取，即 $dp[i - 1][j - w[i]] + v[i]$</li></ul><p>$$<br>dp[i][j] = \begin{cases}<br>max{dp[i-1][j], dp[i - 1][j - w[i]] + v[i]} &amp;  \space j &gt;= w[i] \<br>dp[j] &amp;  \space j&lt; w[i]<br>\end{cases}<br>$$</p></li><li class="lvl-2"><p>Topological Order: 先假定都按照顺序来访问，Increasing $i$ and $j$</p></li><li class="lvl-2"><p>Base: 当 $i == 0$ 或 $j == 0$ 时，$dp[i][j] = 0$ 。两种情况分别代表：</p><ul class="lvl-2"><li class="lvl-4">$i ==0$： 0 件物品放入背包中；</li><li class="lvl-4">$j == 0$：物品放入容量为 0 的背包中。</li></ul><p>二者显然均应该为 0。</p></li><li class="lvl-2"><p>Original Problem: $dp[n][C]$</p></li><li class="lvl-2"><p>Time: $O(nC)$</p></li></ul><p><b>空间压缩</b>：观察状态转换方程，显然 $dp[i][j]$ 仅与上一行的值有关，应考虑使用滚动数组进行空间优化。</p><p>将二维的 $dp$ 数组压缩为一维，即长为 $C$ 的一维数组。这时我们要考虑压缩后，值是否还是我们想要的：</p><ul class="lvl-0"><li class="lvl-2"><p>$dp[i - 1][j]$ ：想要的是 $i- 1$ 件物品放入容量 $j$ 中。即来自上方的、未更新过的旧值。此时直接压缩成 $dp[j]$ 即可，因为当前 $dp[j]$ 还未被更新，仍然保留着上一行的旧值。</p></li><li class="lvl-2"><p>$dp[i - 1][j - w[i]]$ ：想要仍然是来自左上方、未更新过的旧值。但如果我们按照 $j$ 的正序进行更新的话，因为 $j -w[i]$ 在左侧，其已经被更新。即 $dp[j - w[i]$ 的值已经被更新为 $dp[i][j - w[i]]$ 。</p><p>为了避免这个更新覆盖的问题，我们可以改为按照 $j$ 的逆序进行更新，此时处于左侧的值就能保持旧值的状态而不会被覆盖。</p></li></ul><p>如上分析，状态转移方程变为如下：<br>$$<br>dp[j] = \begin{cases}<br>max{dp[j], dp[j - w[i]] + v[i]} &amp;  \space j \geq w[i] \<br>dp[j] &amp;  \space j&lt; w[i]<br>\end{cases}<br>$$<br>其中，$0 \leq j \leq V$，且 $j$ 为逆序遍历。</p><h4 id="完全背包">完全背包</h4><p>同样尝试SRTBOT：</p><ul class="lvl-0"><li class="lvl-2"><p>Subproblem: 和01背包一样的子问题定义</p></li><li class="lvl-2"><p>Relate: 同样是两种选择，放或者不放：</p><ul class="lvl-2"><li class="lvl-4"><p>不选择第 $i$ 号物品：即在容量 $j$ 下放前 $i - 1$ 件物品，仍然为 $dp[i - 1][j]$</p></li><li class="lvl-4"><p>选择第 $i$ 号物品：即在容量 $j - w[i]$ 下放前 $i$ 件物品，因为第 $i$ 件物品可以放若干次。</p><p>即 $dp[i][j - w[i]] + v[i]$ 。</p></li></ul></li></ul><p>$$<br>dp[i][j] = \begin{cases}<br>max{dp[i - 1][j] , dp[i][j - w[i]] + v[i]   &amp; j \geq w[i]  \<br>dp[i - 1][j] &amp; j &lt; w[i]<br>\end{cases}<br>$$</p><ul class="lvl-0"><li class="lvl-2"><p>Topological Order: Increasing $i$ and $j$</p></li><li class="lvl-2"><p>Base: 当 $i$ 或 $j$ 为0时，$dp[i][j] = 0$</p></li><li class="lvl-2"><p>Original Problem: $dp[n][C]$</p></li><li class="lvl-2"><p>Time: $O(nC)$</p></li></ul><p><b>空间压缩</b>: 分析状态转换方程，$dp[i][j]$ 的值取决于其上方（未更新）与其左侧（已更新）的值，显然可以直接压缩至一维而不存在冲突，且必须保持按照正序更新。即<br>$$<br>dp[j] = \begin{cases}<br>max{dp[j] , dp[j - w[i]] + v[i]   &amp; j \geq w[i]  \<br>dp[j] &amp; j &lt; w[i]<br>\end{cases}<br>$$</p><h4 id="相关题目-5">相关题目</h4><ul class="lvl-0"><li class="lvl-2"><p>416 Partition Equal Subset Sum 分割等和子集 (Medium)</p><p>表面上，这并不是一道最优化问题。我们首先考虑常规的暴力解法：</p><p>我们想要等分为两个子集，显然应该先求出整个数组的和，然后遍历所有的子集（这里是 subsequence），查看其值是否为和的一半即可。暴力法显然会达到 $O(n^2)$ 。</p><p>此时问题已经简化成了从数组中选定子集并求其值，显然这是一个简单的01背包问题。</p><ul class="lvl-2"><li class="lvl-4"><p>Subproblem: 因为本题不是最优化问题，而是检查是否存在符合条件的解，所以我们开一个布尔数组即可。</p><p>$dp[i][j]$ 代表前 $i$ 个元素中是否存在子集的和为 $j$。</p><p>可以通过滚动数组进行空间优化，即子问题变为 $dp[j]$。</p></li><li class="lvl-4"><p>Relate:<br>$$<br>dp[i][j] = \begin{cases} dp[i-1][j]\space || \space dp[i-1][j - nums[i]] &amp;j \geq nums[i] \<br>dp[i - 1][j] &amp; j &lt; nums[i]<br>\end{cases}<br>$$</p><p>滚动数组优化后：<br>$$<br>dp[j] = \begin{cases} dp[j]\space || \space dp[j - nums[i]] &amp;j \geq nums[i] \<br>dp[j] &amp; j &lt; nums[i]<br>\end{cases}<br>$$</p></li><li class="lvl-4"><p>Topological Order: Increasing $i$ ，decreasing $j$</p><p>为了进行空间压缩，内层必须是逆序遍历。</p></li><li class="lvl-4"><p>Base: $dp[0] = true$ ，代表任意子集都能满足容量为0的情况（一个数都不选就行了）。</p></li><li class="lvl-4"><p>Original Problem: $dp[sum]$</p></li><li class="lvl-4"><p>Time: $O(n\times sum)$，显然这是一个 pseudopolynomial 的情况。</p></li></ul></li><li class="lvl-2"><p>474 Ones and Zeroes 一和零 (Medium)</p><p>明面的01背包问题，特点其容量分为了两部分，即0的容量和1的容量。</p><p>相当于：物品的价值均为1（价值的本质其实就是数量），求放入对0的容量为 $m$ 和对1的容量为 $n$ 的背包中的最大价值（最大物品个数）。</p><ul class="lvl-2"><li class="lvl-4"><p>Subproblem: $dp[i][j][k]$ 前 $i$ 个字符串，在对0的容量为 $j$、对1的容量为 $k$ 的情况下的最大子集长度</p></li><li class="lvl-4"><p>Relate:<br>$$<br>dp[i][j][k] = \begin{cases} max{dp[i - 1][j][k], dp[i - 1][j - zero[i]][k - one[i]] + 1 }  &amp; j \geq zero[i] \space &amp;&amp;\space k \geq one[i] \<br>dp[i - 1][j][k] &amp; else<br>\end{cases}<br>$$<br>空间压缩后：<br>$$<br>dp[j][k] = \begin{cases} max{dp[j][k], dp[j - zero[i]][k - one[i]] + 1 }  &amp; j \geq zero[i] \space &amp;&amp;\space k \geq one[i] \<br>dp[j][k] &amp; else<br>\end{cases}<br>$$</p></li><li class="lvl-4"><p>Topological Order: 空间压缩后，内层必须逆序遍历。</p><p>即Increasing $i$, decreasing $j$ and $k$</p></li><li class="lvl-4"><p>Base: $dp[0][0] = 0$，当容量为0时，显然结果也为0。</p></li><li class="lvl-4"><p>Original Problem: $dp[len][m][n]$</p></li><li class="lvl-4"><p>Time: $O(len\times m\times n + L)$ 其中 $len$ 为数组长度，$L$ 为所有字符串长度之和（因为要求出所有字符串中的01个数）。</p><p>空间复杂度则优化至 $O(mn)$。</p></li></ul></li><li class="lvl-2"><p>322 Coin Change 零钱兑换 (Medium)</p><p>从零钱中凑出想要的金额，并选出其中最少的硬币个数，其中每个面额的金币数量不限。显然是适用完全背包模型的最优化问题。</p><ul class="lvl-2"><li class="lvl-4"><p>Subproblem: $dp[i][j]$ 代表前 $i$ 个硬币中能够凑成 $j$ 元的最少硬币个数</p></li><li class="lvl-4"><p>Relate:<br>$$<br>dp[i][j] = \begin{cases}<br>min{dp[i - 1][j], dp[i][j - coins[i]] + 1} &amp; j \geq coins[i]  \<br>dp[i - 1][j] &amp; j &lt; coins[i] \space | \space coins[i] &gt; 10^4<br>\end{cases}<br>$$<br>空间压缩后：<br>$$<br>dp[j] = \begin{cases}<br>min{dp[j], dp[j - coins[i]] + 1} &amp; j \geq coins[i]  \<br>dp[j] &amp; j &lt; coins[i] \space | \space coins[i] &gt; 10^4<br>\end{cases}<br>$$<br>其中 $j$ 必须正序访问。</p></li><li class="lvl-4"><p>Topological Order: Increasing $i$ and $j$</p></li><li class="lvl-4"><p>Base: $dp[0] = 0$ 显然，0元只需要0个硬币。</p></li><li class="lvl-4"><p>Original Problem: $dp[amount]$</p></li><li class="lvl-4"><p>Time:</p></li></ul></li></ul><h3 id="字符串">字符串</h3><ul class="lvl-0"><li class="lvl-2"><p>91 Decode Ways 解码方法 (Medium)</p><p>首先来看暴力搜索解法，逻辑必定很复杂，时间复杂度上粗略分析一下：对每一个位置而言，大致可以分为两种情况——独立成字母、以及和前一个位置组成一个字母，那么渐进时间复杂度大概在 $O(2^n)$ 级别，显然爆炸。</p><p>问题显然可以缩小规模，所以尝试SRTBOT。题目的关键点在于，其状态转换方程由多种情况下的多个公式组成，要注意细节和各种情况，进行分类讨论。</p><ul class="lvl-2"><li class="lvl-4"><p>Subproblem: prefix，$dp[i]$ 表示前 $i$ 个字符的解码方法总数</p></li><li class="lvl-4"><p>Relate:<br>$$<br>dp[i] = \begin{cases} 0  &amp; s[i] = 0 \space &amp;&amp;\space s[i-1] &gt; 2 \<br>dp[i - 2] &amp; s[i] = 0 \space&amp;&amp;\space s[i-1] &lt;= 2 \<br>dp[i - 1] + dp[i - 2] &amp; s[i - 1] \times 10 + s[i] &lt;= 26 \<br>dp[i - 1] &amp; else<br>\end{cases}<br>$$<br>从上到下四种情况分别代表：</p><ul class="lvl-4"><li class="lvl-6">当前位为 0，前一位大于 2，说明不存在可行解码，此时剪枝，直接返回 0；</li><li class="lvl-6">当前位为 0， 前一位小于等于 2，说明当前的 0 能够且必须与前一位组合编码；</li><li class="lvl-6">当前位不为 0，且和前一位组成的数字小于等于 26，说明二者组合可以解码；</li><li class="lvl-6">当前位不为 0，但和前一位组成的数字不合法，说明二者无法组合编码，该位只能单独解码。</li></ul></li><li class="lvl-4"><p>Topological Order: Increasing $i$</p></li><li class="lvl-4"><p>Base:</p><ul class="lvl-4"><li class="lvl-6"><p>$dp[0] = 1$ ，哨兵，代表前两位组合编码的缺省情况；</p></li><li class="lvl-6"><p>$dp[1] = 1$，表示第一位单独解码的情况。</p></li></ul></li><li class="lvl-4"><p>Original Problem: $dp[n]$</p></li><li class="lvl-4"><p>Time: $O(n)$</p></li></ul><p>空间压缩：因为 $dp[i]$ 在各种情况下都仅与 $dp[i - 1]$ 和 $dp[i - 2]$ 有关，所以可以使用滚动数组进行空间优化。</p></li><li class="lvl-2"><p>72 Edit Distance 编辑距离 (Hard)</p><blockquote><p>求解两个字符串之间的编辑距离其实也是一种 <b>相似度</b> 的度量，显然可以联想到LCS的做法。</p><p>首先我们直观的将两个字符串放到一块，尝试手动去进行转换。为了减少总操作次数，我们会倾向于保留二者相同的子序列部分，对其他部分进行改动，这显然和LCS问题高度相似。</p></blockquote><p>接下来我们对题中给出的操作加以分析：有插入、删除、替换三种操作，分别应用在两个不同的字符串上，对应出六种操作。但这六种操作其实很多情况下都等价，最终简化成三种情况：</p><ul class="lvl-2"><li class="lvl-4"><p>在A中插入 等价于 在B中删除</p></li><li class="lvl-4"><p>在A中删除 等价于 在B中插入</p></li><li class="lvl-4"><p>在A中修改 等价于 在B中修改</p></li></ul><p>接下来可以尝试将问题规模缩小：</p><ul class="lvl-2"><li class="lvl-4"><p>Subproblem: $dp[i][j]$ 代表 $word1$ 的前 $i$ 部分与 $word2$ 的前 $j$ 部分之间的编辑距离（最少操作数）。</p></li><li class="lvl-4"><p>Relate:<br>$$<br>dp[i][j] = \begin{cases}<br>min{dp[i - 1][j - 1], dp[i - 1][j] + 1, dp[i][j - 1] + 1} &amp; word1[i] = word2[j] \<br>min{dp[i - 1][j - 1] + 1, dp[i - 1][j] + 1, dp[i][j - 1] + 1} &amp; word1[i] \neq word2[j]<br>\end{cases}<br>$$<br>状态转移方程分别对应三种情况：</p><ol><li class="lvl-7">$dp[i - 1][j - 1]$ 考虑 $word1[i]$ 和 $word2[j]$ 的情况：<ul class="lvl-6"><li class="lvl-9">$word1[i] = word2[j]$ ：无需变动，无需加1</li><li class="lvl-9">$word1[i] \neq word2[j]$ ：需要修改 $word1$ 中 $i$ 位置，等价于在 $word2$ 中修改 $j$ 位置，需要加1</li></ul></li><li class="lvl-7">$dp[i - 1][j] + 1$ : 对应在 $word1$ 中删除 $i$ 位置，等价于 在 $word2$ 中增加 $j$ 位置</li><li class="lvl-7">$dp[i][j - 1] + 1$：对应在 $word1$ 中增加 $i$ 位置，等价于 在 $word2$ 中删除 $j$ 位置</li></ol><p>分析三种来源，可以进行空间压缩。由于 $j - 1$ 有两个来源，需要辅助空间来存储上一行的情况：<br>$$<br>dp_curr[j] = \begin{cases}<br>min{dp_prev[j - 1], dp_prev[j] + 1, dp_curr[j - 1] + 1} &amp; word1[i] = word2[j] \<br>min{dp_prev[j - 1] + 1, dp_prev[j] + 1, dp_curr[j - 1] + 1} &amp; word1[i] \neq word2[j]<br>\end{cases}<br>$$</p></li><li class="lvl-4"><p>Topological Order: Increasing $i$ and $j$</p></li><li class="lvl-4"><p>Base:</p><ul class="lvl-4"><li class="lvl-6">$dp[0][j] = j$：$word1$ 需增加 $j$ 个字符 / $word1$ 需减少 $j$ 个字符</li><li class="lvl-6">$dp[i][0] = i$：$word1$ 需减少 $i$ 个字符 / $word2$ 需增加 $i$ 个字符</li></ul><p>空间压缩后：</p><ul class="lvl-4"><li class="lvl-6"><p>当 $i = 0$ 时，$dp[j] = j$；</p></li><li class="lvl-6"><p>当 $j = 0$ 时，$dp[0] = i$；</p></li></ul><p>即，<code>dp_curr[j] = (i == 0) ? j : i</code></p></li><li class="lvl-4"><p>Original Problem: $dp[n - 1][m - 1]$ ，其中 $n = word1.size(), m = word2.size()$。</p></li><li class="lvl-4"><p>Time: $O(nm)$</p><p>空间复杂度上，压缩后可以达到 $O(m)$ 。</p></li></ul></li><li class="lvl-2"><p>10 Regular Expression Matching 正则表达式匹配 (Hard)</p></li></ul><h3 id="股票类题目">股票类题目</h3><ul class="lvl-0"><li class="lvl-2"><p>121 Best Time to Buy and Sell Stock 买卖股票的最佳时机 (Easy)</p><p>一次循环。</p></li><li class="lvl-2"><p>122 Best Time to Buy and Sell Stock II 买卖股票的最佳时机 II (Medium)</p><p>解法一：贪心</p><p>本题的最优解法，直接求出向上的区间差之和即可。</p><p>值得注意的是，题目并不允许 当天卖出后再买入，所以贪心的方式求出来的最大利润，即所有上升求区间差之和，而并非实际的交易过程。联系实例 <code>[1,2,3,4,5]</code> 来分析。</p><p>解法二：动态规划</p><p>其实用贪心的解法是最优且最简洁的，但是这道题非常适合作为 <strong>子问题扩展</strong> 的样例题。</p><p>这是一道 <b>规模可缩减</b> 的 <b>最优化问题</b> 。显然可以尝试使用 SRTBOT 模型来解决：</p><ul class="lvl-2"><li class="lvl-4"><p>Subproblem: 与 Alternating Coin Game 相似，这是一道需要进行 子问题扩展的问题。</p><p>因为每天会存在两种不同的状态：<b>持有股票</b>、<b>未持有股票</b>。所以设计子问题时不能简单的缩小规模，而是必须要升维，才能正确的满足状态转移的无后效性。</p><ul class="lvl-4"><li class="lvl-6"><p>$dp[i][0]$ ：未持有股票，第 $i$ 天时的最大收益；</p></li><li class="lvl-6"><p>$dp[i][1]$ ：持有股票，第 $i$ 天时的最大收益。</p></li></ul><div class="warning"><p><b>记录一次错误的做法</b></p><p>升维时要想清楚状态的分类，一开始的想法是分成：第 $i$ 天买进 和 第 $i$ 天卖出 两种情况。而实际的状态并未每天都一定会买进和卖出。而且这种设计方式与前 $i$ 种情况均相关，使得内层操作时间也达到线性，题目会超时。</p></div></li><li class="lvl-4"><p>Relate: 考虑当天是否有买进或者卖出：</p><p>如果当前未持有股票：</p><ol><li class="lvl-7"><p>前一天未持有股票，今天也未持有股票，状态不变；</p></li><li class="lvl-7"><p>前一天持有股票，那么说明今天卖出了股票，收益增加；</p></li></ol><p>即：<br>$$<br>dp[i][0] = max{dp[i - 1][0], dp[i - 1][1] + prices[i] }<br>$$<br>如果当前持有股票：</p><ol><li class="lvl-7"><p>前一天未持有股票，则说明今天有买入；</p></li><li class="lvl-7"><p>前一天持有股票，说明状态不变；</p></li></ol><p>即：<br>$$<br>dp[i][1] = max{dp[i - 1][0] - prices[i], dp[i - 1][1]}<br>$$</p></li><li class="lvl-4"><p>Topological Order: Increasing $i$</p></li><li class="lvl-4"><p>Base: $dp[0][0] = 0,\space dp[0][1] = - prices[0]$</p></li><li class="lvl-4"><p>Original Problem: $dp[n - 1][1]$</p></li><li class="lvl-4"><p>Time: $O(n)$</p><p>空间上，显然 $dp$ 只与前一个值相关，可以使用滚动数组优化至 $O(1)$ 。</p></li></ul></li><li class="lvl-2"><p>123 Best Time to Buy and Sell Stock III 买卖股票的最佳时机 III (Hard)</p><p>在122题的基础上增加了一条限制：最多可以完成两笔交易。因此我们尝试再次升维，增加一个维度来保存“当前完成了交易”这个状态。</p><ul class="lvl-2"><li class="lvl-4"><p>Subproblem &amp; Relate: 两种升维状态进行组合如下</p><ul class="lvl-4"><li class="lvl-6"><p>$dp[i][0][0] = 0$<br>未持有股票、卖出0次：没有任何交易发生</p></li><li class="lvl-6"><p>$dp[i][0][1] = max{dp[i - 1][0][1], dp[i - 1][1][0] + prices[i]}$<br>未持有股票、卖出1次：</p><ol><li class="lvl-9">前一天未持有股票且卖出1次</li><li class="lvl-9">前一天持有股票且卖出0次、当天卖出</li></ol></li><li class="lvl-6"><p>$dp[i][0][2] = max{dp[i - 1][0][2], dp[i - 1][1][1] + prices[i]}$<br>未持有股票、卖出2次：</p><ol><li class="lvl-9">前一天未持有股票且卖出2次</li><li class="lvl-9">前一天持有股票且卖出1次，当天卖出</li></ol></li><li class="lvl-6"><p>$dp[i][1][0] = max{dp[i - 1][1][0], dp[i - 1][0][0] - prices[i]}$<br>持有股票、卖出0次:</p><ol><li class="lvl-9">前一天持有股票且卖出0次</li><li class="lvl-9">前一天未持有股票且卖出0次，当天买进</li></ol></li><li class="lvl-6"><p>$dp[i][1][1] = max{dp[i - 1][1][1], dp[i - 1][0][1] - prices[i]}$<br>持有股票、卖出1次：</p><ol><li class="lvl-9">前一天持有股票且卖出1次</li><li class="lvl-9">前一天未持有股票且卖出1次，当天买进</li></ol></li><li class="lvl-6"><p>$dp[i][1][2] = -INF$<br>持有股票、卖出2次：不存在的情况，超出交易上限</p></li></ul><p>因为每次都只与前一天有关，所以可以使用滚动数组去掉数组的第一维，将空间优化至常数级。</p></li><li class="lvl-4"><p>Topological Order: Increasing $i$</p></li><li class="lvl-4"><p>Base:  此处写空间压缩后的初始状态。<br>$$<br>prev[0][0] = 0 \<br>prev[1][0] = -prices[0] \<br>prev[0][1] = -INF \<br>prev[1][1] = -INF \<br>prev[0][2] = -INF \<br>prev[1][2] = -INF \<br>$$</p></li><li class="lvl-4"><p>Original Problem: $max{dp[i][j][k]}$</p></li><li class="lvl-4"><p>Time: $ O(n) $</p></li></ul></li><li class="lvl-2"><p>188 Best Time to Buy and Sell Stock IV 买卖股票的最佳时机 IV (Hard)</p><p>和123一样，只是把2次交易升级到 $k$ 次交易。</p></li><li class="lvl-2"><p>309 Best Time to Buy and Sell Stock with Cooldown 最佳买卖股票时机含冷冻期 (Medium)</p><p>同样的套路，只是增加了新的限制，这里新增的冷冻期比较重要：</p><p>冷冻期并不是一个普通的状态，而是随着卖出后的一个伴随状态。所以我们不能简单的增加一个冷冻期的维度。</p><p>冷冻期关注的是前一天是否有卖出，因此为了方便判断，我们增加一个“当天是否卖出的条件”，定义三种状态，类似状态机，关注状态之间的转换。</p><ul class="lvl-2"><li class="lvl-4"><p>Subproblem &amp; Relate:</p><ol><li class="lvl-7">未持股、且当天未卖出：$dp[i][0] = max{dp[i -1][0],dp[i - 1][1]}$<ul class="lvl-6"><li class="lvl-9">前一天未持股，且未卖出；</li><li class="lvl-9">前一天未持股、且当天卖出，即当天为冷冻期；</li></ul></li><li class="lvl-7">未持股、且当天卖出：$dp[i][1]= dp[i-  1][2] + prices[i]$<ul class="lvl-6"><li class="lvl-9">前一天持股、当天卖出；</li></ul></li><li class="lvl-7">持股：$dp[i][2] = max{dp[i][2], dp[i][0] - prices[i]}$<ul class="lvl-6"><li class="lvl-9">前一天已持股；</li><li class="lvl-9">前一天未持股、且未卖出，即当天买入；</li></ul></li></ol><div class="warning"><p><b>记录一次错误的做法</b></p><p>一开始没有尝试升维，只是在状态转换时隔一天转换，仍然保持一维的 $dp$ 数组。这种方式的问题在于 <b>不满足最优子结构</b> 。</p><p>比如看例子 <code>[1,2,3,0,2]</code>，关注前三个元素部分 <code>[1,2,3]</code>，此时我们求出的最优解应该是 2 ，由 <code>3-1</code> 得到，即第一天买入，第三天卖出。因为我们的数组是一维，所以此时求出的最优解即为日后用到的最优解。但我们综合看整体结果，发现最终实际的最优结果为 <code>[买入, 卖出, 冷冻期, 买入, 卖出]</code>，即第一天买入、第二天卖出。</p><p>至此，一维的子问题无法满足最优子结构，是错误的解题逻辑。</p></div></li><li class="lvl-4"><p>Topological Order: Increasing $i$</p></li><li class="lvl-4"><p>Base: $dp[0][0] = 0, \space dp[0][2] = -prices[0]$</p></li><li class="lvl-4"><p>Original Problem: $max{dp[n - 1][0], dp[n - 1][1]}$</p></li><li class="lvl-4"><p>Time: $O(n)$</p><p>当前状态显然仅与前一天状态有关，空间压缩可至原地。</p></li></ul></li><li class="lvl-2"><p>714 Best Time to Buy and Sell Stock with Transaction Fee (Medium)</p><ul class="lvl-2"><li class="lvl-4"><p>Subproblem &amp; Relate:</p><p>$dp[i][0] = max{dp[i - 1][0], dp[i - 1][1] + prices[i] - 2}$</p><p>$dp[i][1] = max{dp[i - 1][1], dp[i - 1][0] - prices[i]}$</p></li><li class="lvl-4"><p>Topological Order: Increasing $i$</p></li><li class="lvl-5"><p>Base: $dp[0][0] = 0, \space dp[0][1] = -prices[0]$</p></li><li class="lvl-4"><p>Original Problem: $dp[n - 1][0]$</p></li><li class="lvl-4"><p>Time: $O(n)$</p><p>空间压缩后，消耗降至原地。</p></li></ul></li></ul><h2 id="Pseudopolynomial">Pseudopolynomial</h2><p>有关时间复杂度的分析，详见6.006的lecture note.</p><h2 id="其他相关题目">其他相关题目</h2><ul class="lvl-0"><li class="lvl-2"><p>338 Counting Bits 比特位计数 (Easy)</p><p>详见<a href="##%E4%BD%8D%E8%BF%90%E7%AE%97">位运算部分</a>。</p></li><li class="lvl-2"><p>256 Paint House 粉刷房子 (Medium)</p></li><li class="lvl-2"><p>2327 Number of People Aware of a Secrets 知道秘密的人数 (Medium)</p></li><li class="lvl-2"><p>873 Length of Longest Fibonacci Subsequence 最长的斐波那契子序列的长度 (Medium)</p><ul class="lvl-2"><li class="lvl-4"><p>Subproblem: $dp[i][j]$，以$arr[i],arr[j]$两个元素为结尾的斐波那契子序列的长度；</p></li><li class="lvl-4"><p>Relate:<br>$$<br>dp[i][j]= \begin{cases}<br>max(dp[k][i] + 1, \space 3), &amp; k&lt;i \space 且 \space arr[k] = arr[j] - arr[i] \<br>0, &amp; else<br>\end{cases}<br>$$<br>这里的$else$包含了两种情况：</p><ol><li class="lvl-7"><p>不存在 $k$ 能使得 $arr[k]=arr[j] - arr[i]$；</p><p>这里显然涉及到集合中的查询，使用<strong>哈希表</strong>进行优化。</p></li><li class="lvl-7"><p><em>剪枝</em>：若存在符合条件的 $k$ 但 $k &gt; i$，此时意味着 $i$ 和 $j$ 距离过远，应该停止 $j$ 继续增大搜索，从而实现剪枝。</p></li></ol></li><li class="lvl-4"><p>Topological Order: $i$ 与 $j$ 均为从小到大，两层循环。</p></li><li class="lvl-4"><p>Base: 初始状态下均为0。</p></li><li class="lvl-4"><p>Original Problem: $dp[i][j]$ 中的最大值。</p></li><li class="lvl-4"><p>Time: $O(n^2)$</p></li></ul></li><li class="lvl-2"><p><em>42 Trapping Rain Water 接雨水 (Hard)</em></p><p>首先思考朴素暴力解法：对每一个位置，寻找其左侧与右侧的最高点，取二者中的较小者减去当前位置的高度即为此处能接的雨水。如果该值小于当前高度，则此处无法接住雨水。</p><ol><li class="lvl-5"><p>动态规划</p><p>显然，从每个点往左右两侧搜索最高点时，存在大量的重复计算与搜索。显然可以通过动态规划来进行优化。重点在于要进行两次dp，其中左侧最大值使用prefix前缀子问题，右侧最大值使用suffix后缀子问题，此处以前缀为例，后缀类似：</p><ul class="lvl-4"><li class="lvl-7"><p><strong>Subproblem:</strong> $left(i)$, 表示下标从 $0 \sim i$ 中的最大值；</p></li><li class="lvl-7"><p><strong>Relate:</strong> $left(i) = max{left(i - 1), height(i)}, 0 &lt; i &lt; n$</p></li><li class="lvl-7"><p><strong>Topological Order:</strong> Increasing $i$</p></li><li class="lvl-7"><p><strong>Base:</strong> $left(0) = height(0)$</p></li><li class="lvl-7"><p><strong>Original Problem:</strong> $left(n - 1)$</p></li><li class="lvl-7"><p><strong>Time:</strong> 共$n$个子问题，每个子问题常数运算时间，共$\Theta(n)$。</p></li></ul></li><li class="lvl-5"><p>单调栈</p><p>单调栈维护的是一个局部区域的解，不像朴素解法和动态规划对一个位置进行计算。</p><p>栈中维护一个 $left$ 位置作为左侧边界，根据下标计算出区域宽度，再通过具体值得到区域高度，宽乘上高即为能够接到雨水的量。</p></li><li class="lvl-5"><p>双指针 基于动态规划的解法进行空间复杂度优化</p><p>每一个点处能接多少雨水显然由 $min{leftMax, rightMax}$ 来决定。我们使用双指针从两侧向内收入，指针的移动根据两侧维护的最大值而定：当 $leftMax$ 小于 $rightMax$ 时，说明 $left$ 指针处的雨水量由 $leftMax$ 来决定，即此位置的雨水量为 $leftMax - height[left]$。同时将 $right$ 指针向左移动（直至 $rightMax$ 小于 $leftMax$）；反之同理，即哪一侧的最大值更小，哪一侧就将指针继续移动。</p><p>双指针也是按位置进行处理，具体过程结合代码进行更深入的理解。</p><p>该解法为综合最优解法，其空间复杂度优化至 $O(1)$。</p></li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划(Dynamic Programming, DP)</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>区间信息的维护与查询</title>
    <link href="/2022/02/23/%E5%8C%BA%E9%97%B4%E4%BF%A1%E6%81%AF%E7%9A%84%E7%BB%B4%E6%8A%A4%E4%B8%8E%E6%9F%A5%E8%AF%A2/"/>
    <url>/2022/02/23/%E5%8C%BA%E9%97%B4%E4%BF%A1%E6%81%AF%E7%9A%84%E7%BB%B4%E6%8A%A4%E4%B8%8E%E6%9F%A5%E8%AF%A2/</url>
    
    <content type="html"><![CDATA[<h1>区间信息的维护与查询</h1><p>关注有关区间信息的一些列操作：</p><ul class="lvl-0"><li class="lvl-2"><p>静态操作：</p><p>单点查询、前缀和查询、区间和查询、范围最值查询（Range Minimum Query, RMQ）；</p></li><li class="lvl-2"><p>动态操作：</p><p>单点修改、区间修改，以及修改后的所有查询问题。</p></li></ul><p>以上这些问题，在不同使用场景下灵活使用以下的不同数据结构。</p><h2 id="在线与离线">在线与离线</h2><p>在区间查询、区间修改之类的问题中，描述题目输入时经常会用到“在线”、“离线”这些术语。</p><p>在线和离线的含义其实和名字很贴近，关注的是<em>对于所有的输入是否要全部读入完毕后再进行处理</em>。</p><ul class="lvl-0"><li class="lvl-2"><p><strong>在线</strong>：无需了解所有的输入操作，可以“走一步、做一步”，边读入边执行；</p><p>更多的设计类型题目都是在线算法思路更简明直接，尤其是带有“可持久化”字样的（主席树、可持久化线段树、可持久化字典树等）。</p><p><strong>强制在线</strong>：前后的输入存在耦合，无法使用离线思路来解决问题。比如当前读入的数据需要与上次的结果进行运算后使用。</p></li><li class="lvl-2"><p><strong>离线</strong>：与在线相反，需要知道所有的操作输入，即“记录所有操作，最后再进行处理”。</p><p>代码量小，思路相对复杂。</p></li></ul><p>[(21条消息) <a href="https://blog.csdn.net/jacksonhhhh/article/details/120812832">ACM] 在线 离线 强制在线_jacksonhhhh的博客-CSDN博客_强制在线</a></p><h2 id="前缀和与积分图-2">前缀和与积分图</h2><blockquote><p>适合没有值修改的<strong>静态</strong>数组使用。</p><p>前缀和针对一维的数组，积分图针对二维的数组，二者都是进行打表存储区间和，加速查询。</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>303 Range Sum Query - Immutable 区域和检索 - 数组不可变 (Easy)</p><p><strong>静态</strong>数组 + <strong>前缀和</strong>查询：简单的统计前缀和即可，只有初始化操作复杂度为 $O(n)$，每次查询都是 $O(1)$，$n$次操作的均摊时间复杂度为 $O(1)$。</p><p>一个值得注意的技巧是 <code>partial_sum</code> 函数，能够一行代码计算出数组的前缀和。</p><p>该函数详情见：<a href="https://en.cppreference.com/w/cpp/algorithm/partial_sum">std::partial_sum - cppreference.com</a></p></li><li class="lvl-2"><p>304 Range Sum Query 2D - Immutable 二维区域和检索 - 矩阵不可变 (Medium)</p><p>静态二维数组 + <strong>积分图</strong>查询：仔细注意积分图的求解逻辑即可。</p></li><li class="lvl-2"><p><em>560 Subarray Sum Equals K 和为K的子数组 (Medium)</em></p><p>首先明确一个概念，这里的subarray即substring，是<strong>连续的子序列</strong>（区分于 subsequence），全部枚举出来的复杂度为$O(n^2)$。</p><ul class="lvl-2"><li class="lvl-4"><p>解法一：枚举</p><p>即枚举两侧边界，全部枚举的复杂度为$O(n^2)$。枚举的过程中对子数组的和进行加减，这样每次枚举的耗费为$O(1)$，所以总的复杂度为 $O(n^2)$。</p></li><li class="lvl-4"><p><strong>解法二：前缀和 + 哈希表</strong>的优化。比较巧的解法，需要背一背。</p></li></ul><p>一些思路和坑：</p><ul class="lvl-2"><li class="lvl-4"><p>滑动窗口：因为数组中存在负值，所以没办法确定两侧指针谁来移动。如果全部是正值，则可以使用滑动窗口一次扫描完成；</p></li></ul></li><li class="lvl-2"><p>437 Path Sum III 路径总和 III (Medium)</p><ul class="lvl-2"><li class="lvl-4"><p>解法一：穷举，见<a href="###%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92">二叉树部分</a>。</p></li><li class="lvl-4"><p>解法二：前缀和+先序遍历+回溯</p><p>二叉树中的前缀和：树中每条自顶向下的路径也是唯一的，实际上也是一个一维的前缀和问题。</p></li></ul></li><li class="lvl-2"><p><strong>467 Unique Substrings in Wraparound String 环绕字符串中唯一的子字符串 (Medium)</strong></p><ul class="lvl-2"><li class="lvl-4">统计以每种字母为结尾的最长连续子串即可，最大值即为其对最终答案的贡献（自动去重，无需担心前后出现相同的字符串重复统计）；</li><li class="lvl-4">最终对所有字母的贡献求和即可，即前缀和的思想。</li></ul></li><li class="lvl-2"><p><em>2281 Sum of Total Strength of Wizards 巫师的总力量和 (Hard)</em></p><p>终极前缀和之——前缀和的前缀和。</p><p>详见[单调栈部分](##单调栈 Monotone Stack)</p></li></ul><h2 id="差分数组">差分数组</h2><blockquote><p><strong>差分数组</strong>与<strong>前缀和</strong>其实是一对逆运算。对差分数组求前缀和，可以得到原数组；对前缀和数组求差分，也可以得到原数组。</p><p>差分数组主要用于<strong>区间修改（$O(1)$）<strong>与</strong>单点查询（$O(n)$）</strong>。</p></blockquote><h3 id="定义-3">定义</h3><p>类似前缀和的定义，假设原数组 $num$ ，定义差分数组 $d$ ，则对于 $i \in [2, n]$ ，都有 $d[i] = num[i] - num[i - 1]$ 。</p><h3 id="用法">用法</h3><ol><li class="lvl-3"><p><strong>单点查询</strong> $O(n)$</p><p>$num[i]$即为从 $0$ 到 $i$ 的前缀和。即令 $S_n$ 为 $d[i]$ 的前缀和，则 $num[i] = S_i$ 。</p></li><li class="lvl-3"><p><strong>区间查询</strong> $O(1)$<br>$$<br>sum_x = \sum_{i = 1}^{x} num[i] = \sum_{i=1}^x S_i = \sum_{i=1}^x \sum_{j=1}^i d[i] = \sum_{i=1}^x (x-i+1) d[i]<br>$$</p></li><li class="lvl-3"><p><strong>区间修改</strong></p></li></ol><h2 id="树状数组-BIT-2">树状数组 BIT</h2><blockquote><p>又称二叉索引树（Binary Indexed Tree）、Fenwick树（发明者的命名）。</p><ul class="lvl-1"><li class="lvl-2"><p>适用场景及性能分析</p><p>适用于<strong>点更新</strong>后的<strong>前缀和查询</strong>、<strong>区间和查询</strong>：</p><ul class="lvl-3"><li class="lvl-4"><p>点更新：树状数组 $O(logn)$，普通数组 $O(1)$；</p></li><li class="lvl-4"><p>前缀和/区间和查询：树状数组 $O(logn)$，普通数组 $O(n)$。</p></li></ul><p>并<em>不</em>适用于<strong>点查询</strong> 以及 <strong>区间更新</strong>：</p><ul class="lvl-3"><li class="lvl-4"><p>点查询：普通数组只要 $O(1)$，树状数组需要 $O(logn)$；</p></li><li class="lvl-4"><p>区间更新：普通数组 $O(n)$，树状数组 $O(nlogn)$。</p></li></ul></li><li class="lvl-2"><p>常见应用：求解逆序对数（剑指offer 51）</p></li></ul></blockquote><h3 id="引入-2">引入</h3><p>通过引入树状数组维护前缀和，能够使单点修改和区间和计算都达到$O(logn)$，即树高。</p><p>树状数组巧妙地利用了下标的二进制位特性，所以这里用到了一个重要的位运算操作，定义为 $lowbit(x)$，即保留最低有效位（最低的一个1）后的值。</p><h3 id="定义-4">定义</h3><p>首先来看树状数组的特征与含义：</p><ul class="lvl-0"><li class="lvl-2"><p>含义：维护一组树状区间和数组 $bit[i]$ ，其包含的区间和范围为$[i - lowbit[i] + 1,\space i]$，即<strong>以 $i$ 为左边界，长度为 $lowbit[i]$ 的区间</strong>。即 $bit_i = \sum \limits^{i} <em>{j=i-lowbit(i)+1}A</em>{j}$。如图所示。</p></li><li class="lvl-2"><p>特征：</p><ul class="lvl-2"><li class="lvl-4">每一层节点的 $lowbit$ 值都是相同的。且 $lowbit$ 从树叶向上到根，越靠近根值越大；</li><li class="lvl-4">值得注意的是，树状数组因为借助了二进制位的性质，其下标是从1开始的。</li></ul></li></ul><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/pics-master/202204241054724.png" style="zoom: 33%;" /><ul class="lvl-0"><li class="lvl-2"><p>效率：</p><ul class="lvl-2"><li class="lvl-4"><p>单点修改：如图黄色轨迹所示，向上的下标变3换为 $i+ lowbit[i]$ ；</p></li><li class="lvl-4"><p>求区间和：如图灰色轨迹所示，向上的下标变换为 $i - lowbit[i]$ ；</p><p>时间复杂度显然均为树的高度；</p></li></ul></li></ul><p>具体实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*--</span><br><span class="hljs-comment">a[i] : 0 &lt;= i &lt; n</span><br><span class="hljs-comment">bit[i]: 0 &lt; i &lt;= n </span><br><span class="hljs-comment">--*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BIT</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; bit;<br>    <span class="hljs-type">int</span> size;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">BIT</span>(<span class="hljs-type">int</span> n) : <span class="hljs-built_in">size</span>(n), <span class="hljs-built_in">tree</span>(n + <span class="hljs-number">1</span>) &#123;&#125;<br>    <br>    <span class="hljs-type">int</span> lowbit（<span class="hljs-type">int</span> x) &#123;<span class="hljs-comment">// 求lowbit就是位运算中保留最低有效位</span><br>        <span class="hljs-keyword">return</span> x &amp; (-x);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            bit[i] = a[i - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> index = i - <span class="hljs-number">1</span> - <span class="hljs-number">1</span>; i &gt;= i - <span class="hljs-built_in">lowbit</span>(i); i--) &#123;<span class="hljs-comment">// 长度为 lowbit[i] 的区间</span><br>                bit[i] += a[index];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> val)</span> </span>&#123;<span class="hljs-comment">// 将第index个元素的值修改为x</span><br>        <span class="hljs-type">int</span> diff = val - a[index + <span class="hljs-number">1</span>];<br>        <br>        <span class="hljs-keyword">while</span>(index &lt;= n) &#123;<br>            bit[index] += diff;<br>            index += <span class="hljs-built_in">lowbit</span>(index);<br>        &#125;<br>      <br>        <span class="hljs-comment">// for(int i = index; i &lt;= n; i += lowbit(i)) &#123;</span><br>        <span class="hljs-comment">//     bit[i] += diff;</span><br>        <span class="hljs-comment">// &#125;</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">prefix_sum</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> </span>&#123;<span class="hljs-comment">// 查询前k项和</span><br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = k; i &gt; <span class="hljs-number">0</span>; i -= lowbit[i]) &#123;<br>            sum += bit[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">range_sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<span class="hljs-comment">// 查询[a, b]的区间和（左闭右闭）</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">prefix_sum</span>(b) - <span class="hljs-built_in">prefix_sum</span>(a - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="相关题目-6">相关题目</h3><ul class="lvl-0"><li class="lvl-2"><p><em>剑指Offer 51. 数组中的逆序对 (Hard)</em></p><blockquote><p>首先，按照逆序对的定义，来统计数组中的逆序对的方法有两种形式：</p><ul class="lvl-3"><li class="lvl-2">统计每一位的前面有几个更大的元素；</li><li class="lvl-2">统计每一位的后面有几个更小的元素；</li></ul><p>二者本质一样，按照具体解题方法来选择即可。</p><p>第一反应的暴力解法使用两种形式均可，两层循环达到$O(n^2)$级别复杂度（上限也就5000），题目中50000规模的输入显然会TLE。</p></blockquote><p>逆序对数有两种常见的优化解法：</p><ul class="lvl-2"><li class="lvl-4"><p><em>解法一：桶 + 树状数组 + 数组离散化</em></p><ul class="lvl-4"><li class="lvl-6"><p>基本思想是【<strong>建桶</strong>】来统计每个元素出现的次数，则该桶的<strong>前缀和</strong>即为小于该元素的元素数量。</p></li><li class="lvl-6"><p>考虑到前缀和给出的是更小的元素的数量，我们选择第二种形式统计，即统计每一位的后面有几个更小的元素：</p><p>下标就要从大到小进行循环，对每个位置的值对应的桶自增一，并统计当前桶的前缀和（即已经处理过的、后面的更小元素值的数量）。</p><p>反复计算前缀和/区间和问题显然可以使用树状数组来进行优化。</p></li><li class="lvl-6"><p>同时在空间上，因为元素的值可能非常大，因此对最大值进行建桶会导致空间利用率低，且内存可能并不足够。对于这种<strong>稀疏且只关心相对大小</strong>的桶，可以使用<strong>离散化</strong>来增加空间利用率，也避免出现 MLE。</p><p>**离散化就是将数组内元素排序，按照大小分配成从 1 到 $n$的值。**具体实现如下：</p><ol><li class="lvl-9"><p>复制一个一模一样的临时数组，并对其进行排序 — 耗费 $O(nlogn)$</p></li><li class="lvl-9"><p>从前往后对原数组每个位置进行访问，利用二分查找在临时数组中查找其排序后的位置，并利用该位置修改其值。</p></li></ol></li></ul></li><li class="lvl-4"><p>解法二：归并排序</p><p>归并排序每一次 <b>合并</b> 的时候，观察左右两个子序列 $[l_1, \space r_1], [l_2, \space r_2]$ （此时均为有序序列）。</p><p>假设当前状态如上述，指向两个子序列的指针为 $lPtr$ 与 $rPtr$ ：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">    l_1      r_1       l_2      r_2<br>     |<span class="hljs-string">        </span>|<span class="hljs-string">         </span>|<span class="hljs-string">        </span>|<br>L = [2, 3, 6, 7]   R = [0, 1, 4, 5]       Merge = []<br>     |<span class="hljs-string">                  </span>|<br>    lPtr               rPtr<br></code></pre></td></tr></table></figure><ul class="lvl-4"><li class="lvl-6"><p>$lPtr$ 指向的元素小于 $rPtr$ 指向的元素，即 $lPtr$ 应右移</p><p>此时，$rPtr$ 左侧的元素均小于 $lPtr$ 所指向的元素，且在原数组中位于其后。统计该部分长度为 $rPtr - l_2 + 1$ ，即代表 $lPtr$ 元素位所贡献的逆序对数：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">    l_1      r_1       l_2      r_2<br>     |<span class="hljs-string">        </span>|<span class="hljs-string">         </span>|<span class="hljs-string">        </span>|<br>L = [2, 3, 6, 7]   R = [0, 1, 4, 5]      Merge = [0, 1]<br>     |<span class="hljs-string">                        </span>|<br>    lPtr                     rPtr<br></code></pre></td></tr></table></figure></li><li class="lvl-6"><p>$rPtr$ 指向的元素小于 $lPtr$ 指向的元素，即 $rPtr$ 应右移</p><p>和上述同理，但关注 $L$ 中更大的元素部分。统计 $rPtr$ 元素位所贡献的逆序对数为 $r_1 - lPtr + 1$。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">    l_1      r_1       l_2      r_2<br>     |<span class="hljs-string">        </span>|<span class="hljs-string">         </span>|<span class="hljs-string">        </span>|<br>L = [2, 3, 6, 7]   R = [0, 1, 4, 5]      Merge = [0, 1, 2, 3]<br>           |<span class="hljs-string">                  </span>|<br>          lPtr               rPtr<br></code></pre></td></tr></table></figure></li></ul><p>两种方式取任意都可，第二种的代码相对简洁。</p><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/pics-master/202204261027731.png" style="zoom: 50%;" /></li></ul></li><li class="lvl-2"><p>315 计算右侧小于当前元素的个数 (Hard)</p><p>跟剑指offer51一模一样的题目，换个形式而已。</p></li></ul><h2 id="线段树-Segment-Tree-2">线段树 Segment Tree</h2><blockquote><p>线段树基于分治思想，将区间不断进行二分，可以维护区间的多种信息，如<strong>区间和</strong>、<strong>区间最值</strong>等等。</p></blockquote><h3 id="定义-5">定义</h3><p>线段树（Segment Tree）是一个基于分治思想的二叉树：</p><ul class="lvl-0"><li class="lvl-2"><p>每个非叶节点对应一个区间，并存储对应的该区间信息；</p></li><li class="lvl-2"><p>每个左右孩子节点二分父节点的区间；</p></li><li class="lvl-2"><p>对于节点区间$[l,r]$而言，所有叶节点代表所有的单个元素，及$l=r$的情况。</p></li></ul><p>树的具体结构与定义如图所示（以维护区间最值为例）：</p><p><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/pics-master/202205011625893.png" alt=""></p><h3 id="存储方式-2">存储方式</h3><p>据上可得，线段树除了最后一层，其他上层均为满二叉树，选用顺序存储方式，用数组来存放这颗树，下标从1开始。</p><p>值得注意的是，该数组开辟的大小与输入规模 $n$ 的关系应该是怎样的：</p><p><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/pics-master/202205011711572.png" alt=""></p><p>根据图上可得：</p><ul class="lvl-0"><li class="lvl-2"><p>规定数组总大小为 $N$，则 $N=n_0 + n_2 + n_{blank}$，其中：</p><ul class="lvl-2"><li class="lvl-4"><p>$n_0 = n$，即输入的 $n$ 个元素均为叶节点；</p></li><li class="lvl-4"><p>$n_2 = n_0 - 1 = n - 1$，这是根据二叉树的定义而得：</p><p>$N=n_0 + n_1 + n_2, \space N - 1 = 2 \times n_2 + n_1$，即 $n_0 + \cancel{n_1} + n_2 = 2 \times n_2 + \cancel{n_1} + 1$</p></li><li class="lvl-4"><p>$n_{blank} = 2n-4$，如图所示。</p></li></ul></li><li class="lvl-2"><p>综上可得，$N = n + (n - 1) + (2n-4) = 4n-5$，即<strong>需要给线段树数组开辟【 $4n$ 】的空间来防止溢出</strong>。</p></li></ul><h3 id="懒标记-区间修改">懒标记 - 区间修改</h3><blockquote><p>普通的线段树操作适合<strong>单点修改</strong>后的区间信息维护与查询。</p><p>而对于 <em>区间修改</em> ，需要引入**懒标记（lazy tag）**来进一步降低时间复杂度。</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>处理流程</p><p>懒标记的处理流程如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span> <span class="hljs-keyword">if</span>(目标区间完全覆盖当前区间)<span class="hljs-comment">// cover!</span><br>       更新区间信息;<br>       对当前节点打上懒标记;<br><span class="hljs-number">2.</span> <span class="hljs-keyword">if</span>(未完全覆盖 &amp;&amp; 存在懒标记)<br>       向下传递懒标记;<br><span class="hljs-number">3.</span> <span class="hljs-keyword">if</span>(左儿子有交集)<br>       向左下进入递归;<br>   <span class="hljs-keyword">if</span>(右儿子有交集)<br>       向右下进入递归；<br></code></pre></td></tr></table></figure></li><li class="lvl-2"><p>作用：对区间整体进行修改时的效率提升</p><p>不加懒标记的单点更新时，需要向下递归搜索至叶节点，并在向上返回的过程中不断完成修改。根据上面的流程可以发现，增加懒标记后，每次向下递归无需搜索至叶节点，而是对被覆盖的区间加一个懒标记后，直接对区间进行修改并增加懒标记。而该节点以下的子节点区间都先不做修改，而是等到<strong>下一次需要访问其子区间时</strong>按需<strong>向下传递懒标记</strong>再进行更改，从而实现<strong>效率的提升</strong>。</p><p>同时，由于叶节点无法继续向下传递，无需对其设置懒标记。</p></li><li class="lvl-2"><p>内容</p><p>显然，根据懒标记的作用，其存放的内容是当前节点的儿子们更新时所需要做的操作。</p></li></ul><p>向下递归的过程如图所示（不包含向上返回的过程）：</p><p><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/pics-master/202205021237853.png" alt=""></p><h3 id="动态开点-在线操作">动态开点 - 在线操作</h3><blockquote><p>默认情况下，用随机存取的数组形式来存放二叉树。数组的大小为了防止越界需要提前设置为 $4n$ 。</p><p>适用场景：</p><ul class="lvl-1"><li class="lvl-2"><p>搜索范围非常大（叶节点数量十分庞大）而实际搜索的次数并不多，只占整个值域的一小部分；</p><p>这种情况下的搜素范围过大很可能MLE。</p><p>解决空间问题可以对数据进行 <b>离散化</b>，即将分散的数据映射到连续的小空间（因为实际搜索次数并不多）。但是离散化要求必须是离线处理的题目。如果题目是强制在线则无法使用。</p></li><li class="lvl-2"><p><b>在线</b> 处理的题目。这里的在线是指的是会想线段树中不断插入新节点。</p><p>从空间上来看，提前开好 总不如 按需开点。在搜索远少于值域的情况下，空间的节省格外明显。</p><p>例如，LeetCode 729等（日程安排表系列）</p></li></ul></blockquote><div class="danger"><p><b>不需要动态开点的情况</b></p><p>值得注意的是，如果题目只存在查询与更新，而 <b>不存在插入新节点的情况</b>，则完全没有必要使用动态开点。</p><p>比如 LeetCode 307。</p></div><p>灵活运用动态开点线段树是非常重要的。很多题目要求<strong>强制在线</strong>，这意味着无法对值域 $n$ 进行离散化。通常这种情况下实际的搜索次数 $m$ 也并不会很大，而每次搜索的路径即为树高，即 $O(logn)$，所以实际所需区间约为 $O(mlogn)$。</p><p>综上显然，动态开点的线段树从最完整的 $O(4 * n)$ 降至实际需要的$O(mlogn)$的提升是非常大的。考虑到连续插入时常数的上界定为4，我们这里也可以为了安全起见增加一个常数，取4-6之间均可。</p><h3 id="效率-2">效率</h3><p>任意的查询与更新的单次操作的复杂度都是 $O(logn)$。</p><p>增加了懒标记的区间更新的渐进复杂度也为 $O(logn)$。</p><h3 id="代码实现-2">代码实现</h3><h5 id="无懒标记-携带区间范围信息-2">无懒标记 + 携带区间范围信息</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; num;<span class="hljs-comment">// 原数组，这里假设从下标为1处开始</span><br><span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// n为输入规模，即元素总个数</span><br><br><span class="hljs-comment">// 结构定义</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    <span class="hljs-type">int</span> l, r, mx;<span class="hljs-comment">// l，r为区间做右端点，也有不携带区间信息的写法</span><br>    <span class="hljs-comment">// 区间信息此处以区间最大值为例</span><br>&#125; tree[n * <span class="hljs-number">4</span>];<br><br><span class="hljs-comment">/*--</span><br><span class="hljs-comment">创建线段树：</span><br><span class="hljs-comment">按照树的定义，递归形式创建</span><br><span class="hljs-comment">--*/</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> root, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    tree[root].l = l;<br>    tree[root].r = r;<br>    <span class="hljs-comment">// recursive base</span><br>    <span class="hljs-keyword">if</span>(l == r) &#123;<br>        tree[root].mx = num[l];<br>    <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 向左右儿子进入递归</span><br>    <span class="hljs-type">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>；<br>    <span class="hljs-type">int</span> left = root &lt;&lt; <span class="hljs-number">1</span>, right = root &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">build</span>(left, l, mid);<br>    <span class="hljs-built_in">build</span>(right, mid + <span class="hljs-number">1</span>, r);<br>    <br>    <span class="hljs-comment">// 更新区间信息，此处以更新区间最大值为例</span><br>    tree[root].mx = <span class="hljs-built_in">max</span>(tree[left].mx, tree[right].mx);<br>    <span class="hljs-comment">// tree[root] = push_up(tree[left], tree[right]);</span><br>&#125;<br><br><br><span class="hljs-comment">/*--</span><br><span class="hljs-comment">点更新:</span><br><span class="hljs-comment">递归寻找目标节点，找到后更改，并向上修改</span><br><span class="hljs-comment">--*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> root, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>    <span class="hljs-comment">// recursive base</span><br>    <span class="hljs-keyword">if</span>(root.l == root.r &amp;&amp; root.l == index) &#123;<br>   <span class="hljs-comment">// 更新区间信息，此处以更新区间最大值为例</span><br>        tree[l].mx = val;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 向左右儿子进入递归</span><br>    <span class="hljs-type">int</span> mid = root.l + (root.r - root.l) / <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> left = root &lt;&lt; <span class="hljs-number">1</span>, right = root &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(index &lt;= mid) &#123;<br>        <span class="hljs-built_in">update</span>(left, index, val);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">update</span>(right, index, val);<br>    &#125;<br>    tree[root].mx = <span class="hljs-built_in">max</span>(tree[left].mx, tree[right].mx);<br>&#125;<br><br><span class="hljs-comment">/*--</span><br><span class="hljs-comment">区间信息查询:</span><br><span class="hljs-comment">1. 区间覆盖式查询</span><br><span class="hljs-comment">2. 区间相等式查询</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">--*/</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query_cover</span><span class="hljs-params">(<span class="hljs-type">int</span> root, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-comment">// recursive base</span><br><span class="hljs-keyword">if</span>(l &lt;= root.l &amp;&amp; root.r &lt;= r) &#123;<span class="hljs-comment">// 查询区间完全覆盖了当前区间</span><br>        <span class="hljs-keyword">return</span> tree[root].mx;<br>    &#125; <br>    <span class="hljs-type">int</span> mid = root.l + (root.l - root.r) / <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> lmax, rmax;<br>    <span class="hljs-keyword">if</span>(l &lt;= mid) &#123;<br>        lmax = <span class="hljs-built_in">query</span>(root &lt;&lt; <span class="hljs-number">1</span>, l, r);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(r &gt; mid) &#123;<br>        rmax = <span class="hljs-built_in">query</span>(root &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, l, r);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(lmax, rmax);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query_equal</span><span class="hljs-params">(<span class="hljs-type">int</span> root, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-comment">// recursive </span><br>    <span class="hljs-keyword">if</span>(root.l == l &amp;&amp; root.r == r) &#123;<br>        <span class="hljs-keyword">return</span> tree[root].mx;<br>    &#125;<br>    <span class="hljs-type">int</span> mid = root.l + (root.r - root.l) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(r &lt;= mid) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">query_equal</span>(root &lt;&lt; <span class="hljs-number">1</span>, l, r);<br>    &#125; <br>    <span class="hljs-keyword">if</span>(l &gt; mid) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">query_equal</span>(root &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, l, r);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">query_equal</span>(root &lt;&lt; <span class="hljs-number">1</span>, l, mid), <span class="hljs-built_in">query_equal</span>(root &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="带懒标记-携带区间范围信息-2">带懒标记 + 携带区间范围信息</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 此处指定维护的区间信息为区间和</span><br>vector&lt;<span class="hljs-type">int</span>&gt; nums;<br><span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">struct</span>&#123;<br>    <span class="hljs-type">int</span> l, r, sum, lz;<br>&#125;tree[<span class="hljs-number">4</span> * n];<br><br><span class="hljs-comment">// 维护的区间信息 并 添加懒标记</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">lazy</span><span class="hljs-params">(<span class="hljs-type">int</span> root, <span class="hljs-type">int</span> delta)</span> </span>&#123;<br>    tree[root].sum += delta * (tree[root].r - tree[root].l + <span class="hljs-number">1</span>);  <span class="hljs-comment">// 对其下区间所有元素都增加 delta, 所以该点增加 其区间长度 * delta</span><br>    tree[root].lz += delta;<span class="hljs-comment">// 设置懒标记，代表向下传递时，每个叶节点都要加delta</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> root)</span> </span>&#123;<span class="hljs-comment">// 访问到子节点，需要向下传递懒标记</span><br>    <span class="hljs-built_in">lazy</span>(root &lt;&lt; <span class="hljs-number">1</span>, tree[root].lz);<br>    <span class="hljs-built_in">lazy</span>(root &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, tree[root].lz);<br>    tree[root].lz = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">range_update</span><span class="hljs-params">(<span class="hljs-type">int</span> root, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> delta)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(l &lt;= tree[root].l &amp;&amp; tree[root].r &lt;= r) &#123;<br>        <span class="hljs-built_in">lazy</span>(root, delta);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 重要：当前区间大于查询区间，意味着要向下访问子区间，此时如果有懒标记，则要向下对子区间进行更新！</span><br>    <span class="hljs-keyword">if</span>(tree[root].lz) &#123; <span class="hljs-comment">// tree[root].lz != 0</span><br>        <span class="hljs-built_in">pushdown</span>(root);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(l &lt;= mid) &#123;<br>        <span class="hljs-built_in">range_update</span>(root &lt;&lt; <span class="hljs-number">1</span>, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> delta);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(r &gt; mid) &#123;<br>        <span class="hljs-built_in">range_update</span>(root &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> delta);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> root, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(l &lt;= tree[root].l &amp;&amp; tree[root].r &lt;= r) &#123;<br>        <span class="hljs-keyword">return</span> tree[root].sum;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(tree[root].lz) &#123;<br>        <span class="hljs-built_in">pushdown</span>(root);<br>    &#125;<br>    <span class="hljs-type">int</span> lsum，rsum;<br>    <span class="hljs-keyword">if</span>(l &lt;= mid) &#123;<br>        lsum = <span class="hljs-built_in">query</span>(root &lt;&lt; <span class="hljs-number">1</span>, l, r);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(mid &lt; r) &#123;<br>        rsum = <span class="hljs-built_in">query</span>(root &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, l, r);<br>    &#125;<br>    <span class="hljs-keyword">return</span> lsum + rsum;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="动态开点-无懒标记">动态开点 + 无懒标记</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 以记录区间求和信息为例</span><br><span class="hljs-type">int</span> n, m, cnt = <span class="hljs-number">0</span>; <span class="hljs-comment">// n为值域取对数，m为查询次数的上限, cnt为当前线段树节点个数</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    <span class="hljs-type">int</span> lc, rc;<span class="hljs-comment">// 要与区间信息区分开，这里的lc和rc是指其动态建立的左右子儿子的下标，区间信息仍然在函数参数中进行传递</span><br>&#125;tree[n * m];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; root, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> val)</span> </span>&#123;<span class="hljs-comment">// 为了实现开点，第一个参数必须引用</span><br><span class="hljs-keyword">if</span>(root == <span class="hljs-number">0</span>) &#123;<br>        root = ++cnt;<span class="hljs-comment">// 开点</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>(l == r) &#123;<br>        tree[root].val = val;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(index &lt;= mid) &#123;<br>        <span class="hljs-built_in">update</span>(tree[root].lc, l, mid, index, val);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">update</span>(tree[root].rc, mid + <span class="hljs-number">1</span>, r, index, val);<br>    &#125;<br>    tree[root].val = tree[tree[root].lc].val + tree[tree[root].rc].val;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> root, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">// 此处还未开点，说明没有数据，直接返回0</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(left &lt;= l &amp;&amp; r &lt;= right) &#123;<br>        <span class="hljs-keyword">return</span> tree[root].val;<br>    &#125;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(left &lt;= mid) &#123;<br>        sum += <span class="hljs-built_in">query</span>(tree[root].lc, l, mid, left, right);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(mid &lt; right) &#123;<br>        sum += <span class="hljs-built_in">query</span>(tree[root].rc, mid + <span class="hljs-number">1</span>, r, left, right);<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="动态开点-懒标记">动态开点 + 懒标记</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br></code></pre></td></tr></table></figure><h3 id="扩展">扩展</h3><h5 id="主席树-可持久化线段树">主席树 - 可持久化线段树</h5><h2 id="倍增、ST表、最长公共祖先-LCA、分块-2">倍增、ST表、最长公共祖先 LCA、分块</h2><p>出现次数少，按需补全。</p><p>分块：几乎可以解决所有<strong>区间更新</strong>和<strong>区间查询</strong>问题，但<strong>效率比线段树差一些</strong>。</p><h2 id="相关题目-7">相关题目</h2><ul class="lvl-0"><li class="lvl-2"><p>303 Range Sum Query - Immutable 区域和检索 - 数组不可变 (Easy)</p></li><li class="lvl-2"><p>304 Range Sum Query 2D - Immutable 二维区域和检索 - 矩阵不可变(Medium)</p></li><li class="lvl-2"><p><em>307 Range Sum Query - Mutable 区域和检索 - 数组可修改 (Medium)</em></p><p>典型的使用场景：<strong>单点修改</strong> + <strong>区间和查询</strong></p><ul class="lvl-2"><li class="lvl-4"><p>解法一：线段树</p><p>不存在区间修改，所以无需懒标记。</p></li><li class="lvl-4"><p>解法二：树状数组</p></li><li class="lvl-4"><p>解法三：分块</p><p>未完成，按需补。</p></li></ul></li><li class="lvl-2"><p>308 Range Sum Query 2D - Mutable 二维区域和检索 - 可变 (Hard)</p><p>未做，超纲，按需补</p></li><li class="lvl-2"><p><em>2286 Booking Concert Tickets in Groups 以组为单位订音乐会的门票 (Hard)</em></p><p>难点：两种操作分别需要记录两种信息的<strong>两颗线段树</strong>来加速对可否分配的判断。同时还要动态对剩余座位进行记录。</p><ul class="lvl-2"><li class="lvl-4"><p><code>gather</code>：需要找到编号最小的能够容纳的行。</p><p>引入<strong>记录最大值的线段树</strong>，其内容为区间内每一行中最多空余的座位数。</p><p>对该线段树进行二分，加速查找。</p></li><li class="lvl-4"><p><code>scatter</code>： 判断是否能够在<code>maxRow</code>前有足够的空间容纳；</p><p>显然需要计算区间和，引入<strong>记录区间和的线段树</strong>，其内容为<strong>剩余的座位总数</strong>。</p></li></ul><p>共同的操作：</p><ul class="lvl-2"><li class="lvl-4"><p><code>allocate</code>：安排好座位后，更新两颗线段树的值。</p></li></ul></li><li class="lvl-2"><p><em>699 Falling Squares 掉落的方块 (Hard)</em></p><ul class="lvl-2"><li class="lvl-4"><p>解法一：暴力枚举</p><p>每落下一块，都统计前面所有和当前下落的块有重合的块高度，计算出当前落下块的最终高度。最后在从前往后取前 $i$ 块的最大值即可获得结果。</p><p>值得注意的点：</p><ul class="lvl-4"><li class="lvl-6"><p>如何判断两个块是否重合？</p></li><li class="lvl-6"><p>题目规模显然在 $O(n^2)$ 的暴力解法下能够通过，就先使用暴力解法计算。</p></li></ul></li><li class="lvl-4"><p>解法二：使用map有序集合来加快计算高度</p><p>显然，暴力枚举的时间消耗主要在落下时，要对前面的所有块进行访问。</p><p>这里引入有序集合map来记录当前已经放置好的块的包络（外边界），这样在有序集合中寻找当前下落的块所在的范围可以使用 <code>upper_bound</code> 从而实现 $O(logn)$ 的时间内来确定当前落下块最终的高度。</p><p>要注意如何对有序集合进行更新，注意边界和细节处理。</p><p>该解法属于巧解，没有具体写过，了解加快的思路即可。</p></li><li class="lvl-4"><p>解法三：线段树 + 动态开点</p></li></ul></li><li class="lvl-2"><p>715 Range Module Range 模块 (Hard)</p><p>线段树动态开点 + 懒标记</p><p>其中线段树维护区间和，但由于每个元素的值只能为1或者0，所以实际维护值的含义为<em>当前区间内跟踪的元素个数</em>；</p><p>懒标记的含义也比较特殊：</p><ul class="lvl-2"><li class="lvl-4"><p><code>1</code> 代表跟踪区间；</p></li><li class="lvl-4"><p><code>-1</code> 代表取消区间跟踪。</p></li></ul></li><li class="lvl-2"><p>729 My Calendar I 我的日程安排表 I (Medium)</p></li><li class="lvl-2"><p>731 My Calendar II 我的日程安排表 II (Medium)</p></li><li class="lvl-2"><p>731 My Calendar III 我的日程安排表 III (Medium)</p><p>三道题都一个味，常规线段树直接秒，存储不同的值即可。</p><p>这种全部修改都是区间整体修改的显然也可以用<strong>差分数组</strong>，但是确定区间内是否有重合的时候要进行朴素遍历，所以整体时间复杂度会达到 $O(n^2)$，效率与暴力相比并无本质的提升。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前缀和</tag>
      
      <tag>差分数组</tag>
      
      <tag>树状数组(BIT)</tag>
      
      <tag>线段树(Segment Tree)</tag>
      
      <tag>分块</tag>
      
      <tag>RMQ问题(Range Maximum/Minimum Query)</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OOP</title>
    <link href="/2021/03/08/C++_OOP/"/>
    <url>/2021/03/08/C++_OOP/</url>
    
    <content type="html"><![CDATA[<h2 id="基于对象与面向对象">基于对象与面向对象</h2><ol><li class="lvl-3"><p><b>Objected Based 基于对象</b></p><p>针对<strong>单个对象</strong>，以良好的方式去构建C++ class。</p><p>在设计思路上有两种截然不同的分类：</p><ul class="lvl-2"><li class="lvl-5"><p><strong>class without pointer members</strong></p><p>本身包含了自己所存储的东西；</p></li><li class="lvl-5"><p><strong>class with pointer members</strong></p><p>本身只存储指针，指针指向其想要存储的东西；</p></li></ul><blockquote><p>二者根本上的差别决定了在 <b>内存管理</b> 上有很大的不同。</p><p>通俗的来说，就是 <b>管理动态内存的类</b> 通常不能依赖于编译器自动合成的 <b>拷贝</b>、<b>赋值</b> 与 <b>析构</b> 操作。</p></blockquote></li><li class="lvl-3"><p><b>Object Oriented 面向对象</b></p><p>关注<strong>多个classes之间的关系</strong>，主要利用三种特性：</p><ul class="lvl-2"><li class="lvl-5"><p><strong>继承（inheritance）</strong></p><p>关注基类（父类）、派生类（子类）、虚函数、虚基类、多态；</p></li><li class="lvl-5"><p><strong>复合（composition）</strong></p><p>类中的数据成员为 <b>其他类的对象</b>。</p></li><li class="lvl-5"><p><strong>委托（delegation）</strong></p><p>类中的数据成员为 <b>指向 其他类的对象 的指针</b>。</p></li></ul></li></ol><h2 id="类的基本概念">类的基本概念</h2><h3 id="类的声明-declaration">类的声明 declaration</h3><ul class="lvl-0"><li class="lvl-2"><p>class head：类名</p></li><li class="lvl-2"><p>class body：类成员的声明</p><p>类的成员函数有些在此直接定义；另一些则仅在此声明，在body之外定义。</p></li></ul><h3 id="模板-template">模板 template</h3><p><code>template&lt;typename T&gt;</code>：即T可以被替换为任意类型。设计时考虑传入不同类型的操作后果。</p><h3 id="访问级别-权限-access-level">访问级别/权限 access level</h3><p>使用访问说明符（access specifiers）来设置访问级别，从而加强类的封装性。</p><ul class="lvl-0"><li class="lvl-2"><p><b>private</b> : 只有本类中的函数能访问的成员，外界与其他类都无法访问。增强封装性。隐藏了类的实现细节。</p><p>如果本类中有声明为<strong>友元</strong>的类或者函数，则友元们可以访问本类的私有成员。友元具体见下。</p></li><li class="lvl-2"><p><b>public</b> : 顾名思义。公开的成员，在整个程序内都可以访问。public成员定义了类的对外接口。</p></li><li class="lvl-2"><p><b>protected</b>  :</p></li></ul><h3 id="友元-friend">友元 friend</h3><p>友元也是一个对访问权限的设定。<strong>被一个类标记为友元的其他类或者函数能够访问其私有成员</strong>。</p><ul class="lvl-0"><li class="lvl-2"><p>值得注意的是友元在class body中的<strong>位置</strong>：</p><p>对友元的声明只能出现在类定义的内部，但是其在类内出现的具体位置不限。</p><p>友元既不是类的成员也不受所在区域访问控制级别的约束。通常我们在类定义的开始或结束的位置集中声明友元。</p></li><li class="lvl-2"><p>友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。为了满足其能够被调用，需要在此之外专门对函数再做一次声明。</p></li><li class="lvl-2"><p>由相同类（class）的实例化的各个不同的对象（objects）互为友元。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span> &#123;<br>...<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">const</span> complex&amp; param)</span> </span>&#123;<br><span class="hljs-keyword">return</span> param.re + param.im;<span class="hljs-comment">// 此处传进来的complex对象互为友元，可以直接调用其私有成员</span><br>&#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> re, im;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h3 id="构造函数-constructor">构造函数 constructor</h3><h4 id="默认实参与初始化列表-Default-Argument-Initialization-List">默认实参与初始化列表  Default Argument &amp; Initialization List</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span> &#123;<br>...<br>   <span class="hljs-built_in">complex</span>(<span class="hljs-type">double</span> r = <span class="hljs-number">0</span>, <span class="hljs-type">double</span> i = <span class="hljs-number">0</span>): <span class="hljs-built_in">re</span>(r), <span class="hljs-built_in">im</span>(i) &#123;&#125;<span class="hljs-comment">// 默认实参 与 初始化列表</span><br>   <span class="hljs-built_in">complex</span>(): <span class="hljs-built_in">re</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">im</span>(<span class="hljs-number">0</span>) &#123;&#125;<span class="hljs-comment">// WARNING: 该构造函数与上一行的会产生冲突，因为上一行中声明了默认实参，编译器对这二种无法区分</span><br>...<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="构造函数被设置为private">构造函数被设置为private</h4><p>将构造函数放入private区意味着，不允许外界直接创建对象。这种使用方法常用于设计模式中的<em>单例模式（Singleton）</em>。</p><p>这里对设计模式只做简单介绍：单例模式即通过一个<strong>静态</strong>的成员函数来获取唯一实例，并将构造函数置于private或protected区，从而阻止外界用户对其进行实例化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> A&amp; <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>;<br>    ...<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">A</span>();<br>    ...<br>&#125;;<br><span class="hljs-function">A&amp; <span class="hljs-title">A::getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">static</span> A a;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="析构函数-deconstructor">析构函数 deconstructor</h3><h3 id="成员函数">成员函数</h3><h4 id="内联函数-inline">内联函数 inline</h4><p>本身定义很简单，可以在编译时将代码嵌入，从而减少运行时函数调用的开销。</p><p>【<strong>如果成员函数在class body内就已经定义完成，就会自动隐式声明为inline（候选人）。</strong>】</p><p>但是，无论是显式还是隐式标注的 inline 函数，都只是向编译器发出的一个<strong>建议/请求</strong>，并非强制操作。最终是否会被定义为内联函数要由编译器根据具体情况来决定。</p><h4 id="常量成员函数-const">常量成员函数 const</h4><p>若<strong>函数体内不会修改数据内容</strong>，即<strong>传入的参数值不会发生任何改变</strong>，则优先将函数设置为<code>const</code>常量函数。没加的后果：<strong>非常量成员函数</strong>在操作<strong>常量对象</strong>的数据成员时编译器会报错。函数没加<code>const</code>会让编译器认为其内部有对数据的修改。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">&#123;<br>    <span class="hljs-function"><span class="hljs-type">const</span> complex <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>)</span></span>;<br>    cout &lt;&lt; c1.<span class="hljs-built_in">real</span>() &lt;&lt; c2.<span class="hljs-built_in">imag</span>();<span class="hljs-comment">// 如果real()和imag()没有声明为常量成员函数则会报错，因为c1本身是一个静态的对象</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="参数传递">参数传递</h4><ul class="lvl-0"><li class="lvl-2"><p>pass by value</p><p>值传递的底层实现很简单，就是将<strong>数据整个压入栈</strong>。显然，当数据是个较大的对象时（比如 class with pointer members），会格外耗费资源。</p></li><li class="lvl-2"><p>pass by reference</p><p>C++的引用。浅显的来看，底层的本质还是<strong>指针</strong>。</p></li></ul><p>功能上来看：</p><ul class="lvl-0"><li class="lvl-2"><p>引用传值下<strong>原值会被修改</strong>，当有<strong>多个值要做返回值</strong>时，可以使用引用的形式；</p></li><li class="lvl-2"><p>值传递显然就是引入了实参与形参的概念，<strong>函数内的修改不会影响原值</strong>。</p></li></ul><p>速度上来看：</p><ul class="lvl-0"><li class="lvl-2"><p>不关心值修改的情况下，尽可能以引用的形式去传，毕竟固定传的是一个机器字长内的引用。大小固定，速度较快。</p></li><li class="lvl-2"><p>如果要求值不能在函数体内被修改，可以以**常量引用（const&amp;）**的形式传递，即pass by reference to const。</p></li></ul><h4 id="返回值传递">返回值传递</h4><ul class="lvl-0"><li class="lvl-2"><p>pass by value</p></li><li class="lvl-2"><p>pass by reference</p></li></ul><p>同样，引用传递在大部分情况下速度更快。但要注意<strong>返回值的作用域</strong>，是否为<strong>局部有效（local object）</strong>。在这种情况下，传递回去的是临时对象的地址，其指向的内存在函数结束之后，会被清理，从而导致结果错误。</p><p>参数传递与返回值传递的实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">ostream&amp; <span class="hljs-keyword">operator</span> &lt;&lt; (ostream&amp; os, <span class="hljs-type">const</span> complex&amp; x) &#123;<span class="hljs-comment">// 引用形式的返回值</span><br>    <span class="hljs-comment">// ostream 采用引用传参加速；而 x 不想被修改，采用常量引用传参</span><br><span class="hljs-keyword">return</span> os &lt;&lt; <span class="hljs-string">&#x27;(&#x27;</span> &lt;&lt; <span class="hljs-built_in">real</span>(x) &lt;&lt; <span class="hljs-string">&#x27;,&#x27;</span> &lt;&lt; <span class="hljs-built_in">imag</span>(x) &lt;&lt; <span class="hljs-string">&#x27;)&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="this指针">this指针</h3><p>每个成员函数都有一个隐含的指针参数，即this指针。其指向当前调用函数的对象。</p><h3 id="操作符重载-overloading">操作符重载 overloading</h3><h4 id="成员函数形式">成员函数形式</h4><p>成员函数形式的操作符重载会带有一个隐含的指针参数，即this指针。</p><p>调用该形式重载后的操作符，其左值为隐含的this指针，右值则为显式声明的参数。实例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">inline</span> complex::<span class="hljs-keyword">operator</span> += (<span class="hljs-type">const</span> complex&amp; r) &#123;<br>    <span class="hljs-keyword">return</span> __doapl(<span class="hljs-keyword">this</span>, r);<br>&#125;<br><br>&#123;<br>    ...<br>    <span class="hljs-function">complex <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-function">complex <span class="hljs-title">c2</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<br>    <br>    c2 += c1;<span class="hljs-comment">// 左值c2传入this指针，右值对象c1则为显式声明的形参 r </span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>对于上述 += 运算符重载的例子，还有一个值得关注的点是其返回值（其实是<code>__doapl</code>的返回值）。既然自增操作结束就已经完成了操作，为什么返回值还要返回其结果而不是设置为<code>void</code>呢：</p><p>因为考虑到连用的情况，例如 <code>c3 += c2 += c1;</code> 。很多运算符重载时都要考虑这一点，比如<code>&lt;&lt;</code>。</p><h4 id="非成员函数形式">非成员函数形式</h4><p>无需this指针的情况通常将运算符以非成员函数形式进行重载。例如 <code>+</code> 运算符，针对不同的用法对应编写不同的重载函数。相似的，有两个操作数的运算符大都要考虑不同的参数形式，例如<code>==</code>、 <code>!=</code>、<code>-</code>等等。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">inline</span> complex <span class="hljs-keyword">operator</span> + (<span class="hljs-type">const</span> complex&amp; x, <span class="hljs-type">const</span> complex&amp; y) &#123;&#125;<br><span class="hljs-keyword">inline</span> complex <span class="hljs-keyword">operator</span> + (<span class="hljs-type">const</span> complex&amp; x, <span class="hljs-type">double</span> y) &#123;&#125;<br><span class="hljs-keyword">inline</span> complex <span class="hljs-keyword">operator</span> + (<span class="hljs-type">double</span> x, <span class="hljs-type">const</span> complex&amp; y) &#123;&#125;<br><br>&#123;<br>    <span class="hljs-comment">// 三种不同的使用情况</span><br>    c2 = c1 + c2;<br>    c2 = c1 + <span class="hljs-number">5</span>;<br>    c2 = <span class="hljs-number">7</span> + c1;<br>&#125;<br></code></pre></td></tr></table></figure><p>还有一些左值对象不为本类对象的运算符重载，其不能以成员函数的形式重载，只能作为全局函数重载，例如 <code>&lt;&lt;</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">ostream&amp; <span class="hljs-keyword">operator</span> &lt;&lt; (ostream&amp; os, <span class="hljs-type">const</span> complex&amp; x) &#123;<br><span class="hljs-keyword">return</span> os &lt;&lt; ’(‘ &lt;&lt; <span class="hljs-built_in">real</span>(x) &lt;&lt; <span class="hljs-string">&#x27;,&#x27;</span> &lt;&lt; <span class="hljs-built_in">imag</span>(x) &lt;&lt; <span class="hljs-string">&#x27;)&#x27;</span>;<br>&#125;<br>                   <br>&#123;<br>    complex <span class="hljs-built_in">c1</span>(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>);<br>    complex <span class="hljs-built_in">c2</span>(<span class="hljs-number">2</span>, <span class="hljs-number">-1</span>);<br>    cout &lt;&lt; c1 &lt;&lt; c2;<span class="hljs-comment">// 输出 (2,1)(2,-1)</span><br>&#125;<br></code></pre></td></tr></table></figure><p>此处值得注意的是：</p><ul class="lvl-0"><li class="lvl-2"><p>操作符服务的左值对象必须为输出流，所以只能作为全局函数重载；</p></li><li class="lvl-2"><p>返回值仍然是输出流对象，也是为了连用考虑，从而不能将返回值简单的设置为 <code>void</code> 。</p></li></ul><h3 id="临时对象-temp-object">临时对象 temp object</h3><p>类名加括号的形式即为临时对象。语句结束后就会销毁。</p><h2 id="Class-without-pointer-members">Class without pointer members</h2><p>上述类的基本概念基本都适用于这种类型的类设计。</p><p>优化的思路与注意要点：</p><ol><li class="lvl-3"><p>成员函数方面：</p><ul class="lvl-2"><li class="lvl-5">参数传递，是否by reference，是否const；</li><li class="lvl-5">返回值传递，是否能够by reference，返回值是否为local object；</li><li class="lvl-5">函数是否可以设置成const：函数体内有没有数据修改。</li></ul></li><li class="lvl-3"><p>运算符重载方面：</p><ul class="lvl-2"><li class="lvl-5">成员函数形式还是全局函数形式：<ul class="lvl-4"><li class="lvl-7">操作符的左值？操作符的操作数情况？是否需要this指针？</li></ul></li><li class="lvl-5">返回值是否可以设置为 <code>void</code>？即有没有连用的需求？</li></ul></li><li class="lvl-3"><p>数据成员放置在private区，函数成员通常在public区作为对外的接口供其调用。</p></li></ol><h2 id="Class-with-pointer-members">Class with pointer members</h2><blockquote><p>通俗的来说，就是 <strong>管理动态内存的类</strong> 通常不能依赖于编译器自动合成的<strong>拷贝</strong>、<strong>赋值</strong>与<strong>析构</strong>操作。</p></blockquote><p>带有指针成员的类在设计上有着非常大的区别。这里以<code>string</code>的实现为例（非STL中的标准实现）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">string</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span>* m_data;<span class="hljs-comment">// 数据成员是一个指针</span><br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">string</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* cstr = <span class="hljs-number">0</span>);<span class="hljs-comment">// 构造函数</span><br><br><span class="hljs-built_in">string</span>(<span class="hljs-type">const</span> string&amp; str);<span class="hljs-comment">// 拷贝构造函数</span><br>string&amp; <span class="hljs-keyword">operator</span>= (<span class="hljs-type">const</span> string&amp; str);<span class="hljs-comment">// 拷贝赋值：运算符重载</span><br>~<span class="hljs-built_in">string</span>();<span class="hljs-comment">// 析构函数</span><br>...<br>&#125;;<br></code></pre></td></tr></table></figure><p>可以看到，这种类型的类的<strong>数据成员是一个指针</strong>，而其实际存放的数据在该指针指向的数据空间。</p><p>在这种情况下，很多传统操作是不可以直接适用的，比如编译器自带的拷贝构造与拷贝赋值。</p><h3 id="拷贝构造与拷贝赋值">拷贝构造与拷贝赋值</h3><p>首先要了解，编译器自带的<strong>拷贝构造函数</strong>与<strong>拷贝赋值操作</strong>。显然他们就是重新复制每一份数据成员的值给新的实例对象即可。</p><p>在这种情况下，使用编译器自带的操作会导致复制的值仅仅是<strong>指针</strong>。即新实例的对象指向的实际内存空间和原有的对象一致，这显然会导致很严重的问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">s1</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function">string <span class="hljs-title">s2</span><span class="hljs-params">(<span class="hljs-string">&quot;hello&quot;</span>)</span></span>;<span class="hljs-comment">// 默认构造</span><br><span class="hljs-function">string <span class="hljs-title">s3</span><span class="hljs-params">(s2)</span></span>;<span class="hljs-comment">// 拷贝构造</span><br>string s4 = s2;<span class="hljs-comment">// 拷贝赋值</span><br></code></pre></td></tr></table></figure><h3 id="构造函数">构造函数</h3><p>从默认的构造函数来看，最值得关注的点在于这种类使用的内存都是<strong>动态分配</strong>的。由指针指向动态获取的内存空间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">string::string</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* cstr = <span class="hljs-number">0</span>)</span> </span>&#123; <span class="hljs-comment">// 在类的外部定义函数时，必须指明该函数是哪个类的成员</span><br>    <span class="hljs-keyword">if</span>(cstr) &#123;<span class="hljs-comment">// 如果初始化时给了初值</span><br>        m_data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(cstr) + <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">strcpy</span>(m_data, cstr);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 未给初值，初始化为空字符串</span><br>        m_data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">1</span>];<br>        *m_data = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Big-Three">Big Three</h3><p>指的是设计class with pointer members时的需要关注的三个重要函数：<strong>拷贝构造函数</strong>、<strong>拷贝赋值函数</strong>与<strong>析构函数</strong>。</p><h4 id="拷贝构造">拷贝构造</h4><p>首先来看如果使用默认的拷贝构造会造成什么问题：</p><p>默认的拷贝构造会把所有数据成员复制一份新的一模一样的给新的实例对象。这就会导致新的实例对象获取的是一个和原对象一样的指针，新旧两个对象实际是<strong>指向了同一份内存空间</strong>。</p><p>这实际上也是深拷贝和浅拷贝的区别，默认的拷贝构造为浅拷贝（shallow copy），而我们希望是实现的则是深拷贝（deep copy）。</p><p>因此必须要重写拷贝构造函数，本质就是实现深拷贝，即建立一个新的指针指向一片新的地址空间，并将字符串的实际值复制过来。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">string::string</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; str)</span> </span>&#123;<br>    m_data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(str.m_data) + <span class="hljs-number">1</span>];<span class="hljs-comment">// 同一个class的object之间互为友元，所以可以直接访问其数据成员</span><br>    <span class="hljs-built_in">strcpy</span>(m_data, str.m_data);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="拷贝赋值">拷贝赋值</h4><p>首先来看使用默认的拷贝赋值会造成什么问题：</p><ul class="lvl-0"><li class="lvl-2"><p>第一是和拷贝构造一样的问题，两个对象会指向同一片地址空间，这并不是我们想要的结果。</p></li><li class="lvl-2"><p>除此之外，赋值运算右侧对象曾经指向的那片内存空间不会被释放，从而造成<strong>内存泄漏</strong>。</p></li></ul><p>因此必须要重写拷贝赋值，即对<code>=</code>运算符进行重载，重载的具体方式如下（以<code>s2 = s1</code>为例）：</p><ol><li class="lvl-3"><p>检测**自我赋值（self assignment）**的情况；</p></li><li class="lvl-3"><p>把<code>s2</code>原有的地址空间释放；</p></li><li class="lvl-3"><p>为<code>s2</code>申请一片新的地址空间，大小根据<code>s1</code>而定；、</p></li><li class="lvl-3"><p>将<code>s1</code>的值复制到<code>s2</code>。</p></li></ol><p>这里要注意的是，第一步检测自我赋值是必须要进行的操作。因为后面的过程会先释放地址空间后复制，如果此时出现了自我赋值，第四步的复制操作会去访问第二步已经释放掉的空间，从而出现不可预知的后果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">inline</span> string&amp; string::<span class="hljs-keyword">operator</span>= (<span class="hljs-type">const</span> string&amp; str) &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span> == &amp;str) &#123;<span class="hljs-comment">// selft assignment</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <span class="hljs-keyword">delete</span>[] m_data;<br>    m_data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(str.m_data) + <span class="hljs-number">1</span>];<br>    <span class="hljs-built_in">strcpy</span>(m_data, str.m_data);<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="内存管理">内存管理</h2><p>这一部分应该结合操作系统内容深入理解，此处仅作一些概念性的介绍。</p><h3 id="栈-stack">栈 stack</h3><ul class="lvl-0"><li class="lvl-2"><p>作用于某一<strong>作用域（scope）</strong>，比如某一语句段、函数体等；</p></li><li class="lvl-2"><p>内容：</p><ul class="lvl-2"><li class="lvl-4">函数调用信息：如参数、返回地址等；</li><li class="lvl-4">在函数体内声明或定义的任何（局部）变量，使用的内存块都取自系统栈中。</li></ul></li></ul><h3 id="堆-heap">堆 heap</h3><ul class="lvl-0"><li class="lvl-2"><p>操作系统<strong>动态分配</strong>的一块**全局（global）**内存空间；</p></li><li class="lvl-2"><p>内容：动态分配的内存空间，比如<code>new</code>、<code>delete</code>、<code>malloc</code>关键字；</p></li><li class="lvl-2"><p>分配单位：区块（Block）。</p></li></ul><h3 id="对象的生命周期">对象的生命周期</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">complex <span class="hljs-title">c3</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-function">complex <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<span class="hljs-comment">// local object 取自stack</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> complex <span class="hljs-title">c2</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br>    complex* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">complex</span>(<span class="hljs-number">3</span>);<span class="hljs-comment">// temp object  动态分配取自heap</span><br>&#125;<span class="hljs-comment">// 作用域结束，c1会自动释放，而p需要手动释放</span><br></code></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>c1</code>为local object，即stack object，其生命在作用域结束后（<code>&#125;</code>）自动结束，所以又称这种对象为<code>auto object</code>，因为它会在作用域结束后被自动清理掉（执行析构函数释放内存）；</p></li><li class="lvl-2"><p><code>c2</code>为静态对象（static object），其作用域更广，直到整个程序结束后才会被释放掉；</p></li><li class="lvl-2"><p><code>c3</code>为全局对象（global object），作用域跟<code>c2</code>一样，作用域也是整个程序；</p></li><li class="lvl-2"><p><code>p</code>为堆对象（heap object），其生命在它被<code>delete</code>后才会消亡，所以对于指针<code>p</code>以及<code>new</code>关键字的使用都必须要注意即使<code>delete</code>，否则会导致<strong>内存泄漏（memory leak）</strong>。</p><p>内存泄漏：当作用域结束，<code>p</code>所指的heap object内存区域依然存在，而指针<code>p</code>本身的生命却结束了，作用域之外就无法再调用<code>p</code>，也就意味着该块内存区域无法被释放。</p><p>这也能够推断出C++是<strong>不支持内存自动回收</strong>的，也就如果没有释放内存（<code>free</code>），那么内存就会一直被标记为已分配从而无法再次使用。</p></li></ul><h3 id="new">new</h3><p>编译器会将带有<code>new</code>关键字的语句分为三步执行：</p><ol><li class="lvl-3"><p>分配内存。即按照对象实际所需的大小为其申请来自heap的内存，内部实际调用的是<code>malloc()</code>函数；</p></li><li class="lvl-3"><p>类型转换。根据<code>malloc</code>函数的日常使用习惯以及其声明（<code>void *malloc(size_t size)</code>），可以发现分配的地址空间是<code>void</code>类型的，所以许需要将其转换为所需的类型；</p></li><li class="lvl-3"><p>调用构造函数。最后一步才是真正调用起该类的构造函数，并在刚才申请的地址空间内设置初值。</p></li></ol><p>所以整体来看，<code>new</code>关键字的工作顺序是：<strong>先分配内存空间，然后再调用构造函数</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">complex *pc = <span class="hljs-keyword">new</span> <span class="hljs-built_in">complex</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br><span class="hljs-comment">// 编译器转换为：</span><br><span class="hljs-type">void</span>* mem = <span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(<span class="hljs-built_in">sizeof</span>(complex));<span class="hljs-comment">// 分配内存</span><br>pc = <span class="hljs-built_in">static_cast</span>&lt;complex*&gt;(mem);<span class="hljs-comment">// 类型转换</span><br>pc-&gt;complex::<span class="hljs-built_in">complex</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<span class="hljs-comment">// 构造函数</span><br><span class="hljs-comment">// 包含隐含的this指针，即：pc-&gt;complex::complex(pc, 1, 2);</span><br><br>string* ps = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-comment">// 编译器转换为：</span><br><span class="hljs-type">void</span>* mem = <span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(<span class="hljs-built_in">sizeof</span>(string));<span class="hljs-comment">// 分配内存</span><br>ps = <span class="hljs-built_in">static_cast</span>&lt;string*&gt;(mem);<span class="hljs-comment">// 类型转换</span><br>ps-&gt;string::<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;hello&quot;</span>);<span class="hljs-comment">// 构造函数</span><br><span class="hljs-comment">// 包含隐含的this指针，即：ps-&gt;string::string(&quot;hello&quot;);</span><br></code></pre></td></tr></table></figure><h3 id="delete">delete</h3><ol><li class="lvl-3"><p>先调用析构函数会按照 编译器合成 或 用户定义 的形式执行；</p></li><li class="lvl-3"><p>再调用<code>free</code>函数，将分配给对象的空间进行释放。</p></li></ol><p><code>delete</code>关键字的工作顺序是恰好相反的：<strong>先执行析构函数，然后再释放内存</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">delete</span> pc;<br><span class="hljs-comment">// 编译器转换为：</span><br>complex::~<span class="hljs-built_in">complex</span>(pc);<span class="hljs-comment">// （1）析构函数 - 编译器合成</span><br><span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(pc)</span></span>;<span class="hljs-comment">// （2）释放内存 - 此时对象占用的内存空间才被真正释放，其内部调用free(pc)</span><br><br><span class="hljs-keyword">delete</span> ps;<br><span class="hljs-comment">// 编译器转换为：</span><br>string::~<span class="hljs-built_in">string</span>(ps);<span class="hljs-comment">// （1）析构函数 - 按照用户定义的形式，释放掉真正指向的字符数组部分的内存</span><br><span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(ps)</span></span>;<span class="hljs-comment">// （2）释放内存 - 释放对象本身占用的内存，即m_data指针占用的内存空间</span><br></code></pre></td></tr></table></figure><p><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/pics-master/202205181244587.png" alt=""></p><p><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/pics-master/202205181245883.png" alt=""></p><h3 id="内存块与array">内存块与array</h3><p>这部分结合<strong>PPT上的图</strong>比较好理解，关键字知识点如下：</p><h4 id="Release-Mode-发行模式">Release Mode 发行模式</h4><h4 id="Debug-Mode-调试模式">Debug Mode 调试模式</h4><p>Debug header 调试信息</p><h4 id="Cookie">Cookie</h4><p>记录内存块的大小，在malloc和free函数中会用到。</p><h4 id="array-new-必须搭配-array-delete">array new 必须搭配 array delete</h4><h2 id="补充">补充</h2><h3 id="static">static</h3><p>在类中的静态（static）成员：</p><ul class="lvl-0"><li class="lvl-2"><p>static data members: 脱离开类的实例，单独存在于某一内存空间。独一份，所有该类的实例共享；</p></li><li class="lvl-2"><p>static member functions：没有this指针的成员函数。仅用于存取静态数据成员（static data members），所以根本无需this指针。</p></li></ul><p>调用static函数的方式有两种：</p><ol><li class="lvl-3"><p>通过某一实例对象调用；</p><p><code>object_name.func();</code></p></li><li class="lvl-3"><p>通过类名直接调用。因为静态成员函数是没有绑定在类的实例上的，所以只要指明类名就能够调用。</p><p><code>class_name::func();</code></p></li></ol><p><em>见PPT图</em></p><p>详见<a href="https://en.cppreference.com/w/cpp/language/static">static members - cppreference.com</a></p><h3 id="cout"><code>cout</code></h3><p>为了使得<code>cout</code>能够服务于不同类型的对象，显然要对其进行很多次重载。标准库里也是这样实现的。</p><h3 id="template">template</h3><p>模板的语法都基本一直，就是在前面加上 <code>template&lt;typename T&gt;</code> / <code>template&lt;class T&gt;</code></p><h4 id="class-template">class template</h4><p>针对类模板生成不同类型的实例对象时，编译器会生成多份只有类型不同的代码，这会导致所谓的<strong>代码膨胀</strong>。但这其实也是必要的结果。</p><h4 id="function-template">function template</h4><p>调用模板函数时，编译器会对 调用函数时的实参 进行 <strong>参数推导（argument deduction）</strong>，即判断参数的类型。</p><h2 id="Object-Oriented-Programming">Object Oriented Programming</h2><h3 id="Inheritance-继承">Inheritance 继承</h3><p>表示is a (Generalization)。继承的内容比较复杂，此处仅作一些简单的概念性讨论。</p><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/pics-master/202205311746709.png" style="zoom:50%;" /><h4 id="构造和析构">构造和析构</h4><ul class="lvl-0"><li class="lvl-2"><p>顺序：</p><ul class="lvl-2"><li class="lvl-4">构造由内而外：先调用父类的，再调用自己的（先给爸爸再给儿子）</li><li class="lvl-4">析构由外而内：先执行自己的，再调用其父类的（先杀自己再杀爸爸）</li></ul></li><li class="lvl-2"><p>基类（base class）的析构函数必须是虚函数（virtual），否则会出现undefined behavior。</p></li></ul><h4 id="虚函数">虚函数</h4><ul class="lvl-0"><li class="lvl-2"><p>non-virtual : 无需也无法重写的非虚函数；</p><p><code>virtual void func() = 0;</code>  标记为 <code>=0</code> 的即为纯虚函数；</p></li><li class="lvl-2"><p>virtual : 有默认定义，希望派生类进行override。如果没有override编译器也不会报错；</p><p><code>virtual void func();</code></p></li><li class="lvl-2"><p>pure virtual : 没有默认定义，要求派生类必须要进行override。如果没有override编译器会报错。</p><p>interface</p></li></ul><h4 id="Template-Method">Template Method</h4><p>定义一个操作中算法的骨架（利用virtual特性），将一些步骤延迟到子类。</p><p>模板方法用一些抽象的操作定义一个算法（声明为virtual），而子类将重定义（override）这些操作以提供具体的行为。</p><h4 id="vptr">vptr</h4><p>见Part2</p><h3 id="Composition-复合">Composition 复合</h3><p>表示has a （Association - Aggregation - Composition），即<strong>类的数据成员 是 另一个类的对象</strong>。</p><p>如图：queue的数据成员是deque对象，即deque为实际底层实现结构。</p><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/pics-master/202205311744749.png" style="zoom:33%;" /><h4 id="Adapter-Method-适配器模式">Adapter Method 适配器模式</h4><p>一种结构型设计模式。Adapter模式将一个类的接口转换成客户希望的另外一个接口，使得原本由于<strong>接口不兼容</strong>而不能一起工作的那些类可以一起工作。</p><h4 id="构造与析构的顺序">构造与析构的顺序</h4><p>构造由内而外、析构由外而内。</p><p>见PPT图</p><h3 id="Delegation-委托">Delegation 委托</h3><p>Composition by reference. 即<strong>类的数据成员</strong> 是 <strong>指向对象的指针</strong>。</p><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/pics-master/202205311747762.png" style="zoom:50%;" /><h4 id="pImpl">pImpl</h4><p>point to implementation, Effective C++  31</p><p>通过指针指向其实际实现功能的类，分离度更好。对其内部实现按需改动，不会影响外界的接口。</p><h4 id="Copy-on-Write">Copy on Write</h4><p>写时复制技术（Copy on Write, CoW）：见PPT图。</p><h3 id="不同方式混合">不同方式混合</h3><p>见PPT图</p><h4 id="Inheritance-Composition">Inheritance + Composition</h4><h4 id="Observer-Method-观察者模式">Observer Method 观察者模式</h4><p>采用了Delegation + Inheritance。</p><p>见图</p><h4 id="Prototype">Prototype</h4><h2 id="头文件的布局-Header">头文件的布局 Header</h2><ul class="lvl-0"><li class="lvl-2"><p>guard 防卫式声明</p><p>为了防止 <b>重复定义</b> ，应该尽量写防卫式声明（guard）。即如果包裹在防卫式声明内的类之前已在其他头文件中声明过，则会被跳过。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 假设此处为 complex 负数类的定义</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __COMPLEX__<span class="hljs-comment">// if not defined</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __COMPLEX__</span><br>...  <span class="hljs-comment">// 此处为类的声明</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></li><li class="lvl-2"><p>forward declarations 前置声明</p></li><li class="lvl-2"><p>class declarations 类的声明</p></li><li class="lvl-2"><p>class definitions 类的定义</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// guard</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __COMPLEX__</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __COMPLEX__</span><br><br><span class="hljs-comment">// forward declarations 前置声明</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ostream</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span>;<br>complex&amp; __doapl (complex* ths, <span class="hljs-type">const</span> complex&amp; r);<br><br><span class="hljs-comment">// class declarations 类的声明</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span> &#123;<br>...<br>&#125;;<br><br><span class="hljs-comment">// 类的定义</span><br>complex::function ...<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Object Oriented Programming, OOP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++：变量与基本类型</title>
    <link href="/2021/01/21/C++_%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/"/>
    <url>/2021/01/21/C++_%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Terminology: Object</p><p>此处的对象（Object）均指一块能存储数据并具有某种类型的内存空间。</p></blockquote><h1>1 变量及其基本类型</h1><h2 id="1-1-原始内置类型-Primitive-Built-in-Types">1.1 原始内置类型 Primitive Built-in Types</h2><p>C++中的原始类型大致可以分为两大类：</p><ul class="lvl-0"><li class="lvl-2"><p>算数类型 arithmetic types</p></li><li class="lvl-2"><p>空类型 void</p><p>空类型没有关联的值，最常见的使用场景即 不返回值的函数返回值类型。</p><p>The <code>void</code> type has <b>no associated values</b> and can be used in only a few circumstances, most commonly as <b>the return type for functions that do not return a value</b>.</p></li></ul><h3 id="算术类型-Arithmetic-Types">算术类型 Arithmetic Types</h3><p>算术类型分为 <b>整型（integral types）</b> 和 <b>浮点型（floating-point types）</b>。</p><p>常见算术类型的大小如下：</p><table><thead><tr><th>Type</th><th>Meaning</th><th>Minimum Size</th><th>WSL - Linux 64bit</th></tr></thead><tbody><tr><td><code>bool</code></td><td>boolean</td><td>NA</td><td></td></tr><tr><td><code>char</code></td><td>character</td><td>8 bits</td><td></td></tr><tr><td><code>wchar_t</code></td><td>wide character</td><td>16 bits</td><td></td></tr><tr><td><code>char16_t</code></td><td>Unicode character</td><td>16 bits</td><td></td></tr><tr><td><code>char32_t</code></td><td>Unicode character</td><td>32 bits</td><td></td></tr><tr><td><code>short</code></td><td>short integer</td><td>16 bits</td><td>16 bits</td></tr><tr><td><code>int</code></td><td>integer</td><td>16 bits</td><td>32 bits</td></tr><tr><td><code>long</code></td><td>long integer</td><td>32 bits</td><td>64 bits</td></tr><tr><td><code>long long</code>(C++11)</td><td>long integer</td><td>64 bits</td><td>64 bits</td></tr><tr><td><code>float</code></td><td>single-precision floating-point</td><td>6 significant digits</td><td></td></tr><tr><td><code>double</code></td><td>double-precision floating-point</td><td>10 significant digits</td><td></td></tr><tr><td><code>long double</code></td><td>extended-precision floating-point</td><td>10 significant digits</td><td></td></tr></tbody></table><p>一些注意事项：</p><ul class="lvl-0"><li class="lvl-2"><p>注意字面值的默认类型：虽然 <code>long long</code> 为64位，但 <code>1 &lt;&lt; 63</code> 仍然报错，因为在表达式中，1仍然是 <code>int</code>。</p><p>因此改成 <code>(long long)1 &lt;&lt; 63</code> / <code>1LL &lt;&lt; 63</code> 便可以正常执行。</p></li><li class="lvl-2"><p>通常 <b>溢出</b> 只会报 warning ，其实际值会按位截取。</p></li><li class="lvl-2"><p>大整数优先 <code>long long</code>, 有的编译器 <code>long</code> 和 <code>int</code> 一样长。</p></li><li class="lvl-2"><p>字符型分三种: <code>char</code>, <code>signed char</code>, <code>unsigned char</code></p><p>表现形式只有两种，带符号和无符号，实际表现取决于编译器。</p></li><li class="lvl-2"><p>significant digits: 数字的有效位数。</p></li></ul><h3 id="类型转换-Type-Conversions">类型转换 Type Conversions</h3><ul class="lvl-0"><li class="lvl-2"><p>小心无符号整数和有符号整数同时出现在算数表达式中的情况，<b>有符号会被自动转换为无符号</b>。</p><p>这一点在条件判断语句（condition）中经常会引发错误。</p></li><li class="lvl-2"><p>无符号数和有符号数的二进制码其实是一致的，只是输出时编译器对其判断不同（编译器对不同类型有不同的解析方式）。对于无符号数来说，输出的都是正数。</p></li><li class="lvl-2"><p>强制转换。</p></li></ul><h3 id="字面值-Literals">字面值 Literals</h3><p>重点关注编译器如何设定字面值的默认类型。</p><h4 id="对基本类型字面值的默认操作">对基本类型字面值的默认操作</h4><ul class="lvl-0"><li class="lvl-2"><p>Integer (<code>int</code>, <code>long</code>)</p><ol><li class="lvl-5"><p>显式声明进制（System of Numeration）</p><p><code>0</code> are interpreted as <b>octal</b>;</p><p><code>0x</code> are interpreted as <b>hexadecimal</b>;</p></li><li class="lvl-5"><p>默认类型</p><p>Decimal: always be <b>signed</b> 十进制的字面值默认类型永远是有符号数</p><p>Octal and Hexadecimal: can be either <b>signed</b> or <b>unsigned</b></p><p>整型字面值类型默认为 <b>符合大小条件</b>（不会溢出）的情况下 <b>占用空间最小</b> 的类型。</p><p>特殊的，there are no literals of type <code>short</code>.</p></li></ol></li><li class="lvl-2"><p>Floating-Point</p><ul class="lvl-2"><li class="lvl-4"><p>基本形式为 <b>小数点（a decimal point）</b> 或 <b>科学计数法（an exponent specified using scientific notation）</b>。</p><p>Using scientific notation, the exponent is indicated by either <code>E</code> or <code>e</code>;</p></li><li class="lvl-4"><p>浮点数默认类型为 <code>double</code>。</p></li></ul></li><li class="lvl-2"><p>Character &amp; Character String: 编译器会在所有字符串字面量最后加上一个 <code>\0</code> 来表征字符串的结束，其实际所占空间也会相应+1。</p></li><li class="lvl-2"><p>Boolean: <code>true</code> and <code>false</code></p></li><li class="lvl-2"><p>Pointer:  <code>nullptr</code></p><p>Stop using <code>NULL</code> and change to <code>nullptr</code>.</p></li></ul><h4 id="转义字符-Escape-Sequences">转义字符 Escape Sequences</h4><p>转义序列的适用场景有两种：</p><ol><li class="lvl-3"><p><b>Nonprintable characters</b>, such as backspace or control characters;</p><p>比如：<code>\t</code>，<code>\n</code></p></li><li class="lvl-3"><p>保留字，those who have <b>special meaning</b> in the language;</p><p>比如想要输出反斜杠本身，<code>\\</code></p></li></ol><p>Generalized escape sequence: using ASCII to decide the actual content 使用转义来显式输出ASCII码指定的字符：</p><ul class="lvl-0"><li class="lvl-2"><p><code>\x</code> followed by one or more hexadecimal digits;</p></li><li class="lvl-2"><p><code>\</code> followed by up to three octal digits;</p></li></ul><h4 id="显式声明字面值的类型-Specifying-the-Type-of-a-Literal">显式声明字面值的类型 Specifying the Type of a Literal</h4><p>通过增加前缀与后缀来修改字面值的类型，例如 <code>12345u</code> 将类型从默认的整型转为无符号整型。<br>Override the default type by supplying a <strong>suffix</strong> or <strong>prefix</strong> as listed below:</p><p><b>Integer</b> Literals:</p><table><thead><tr><th style="text-align:center">Suffix</th><th style="text-align:center">Minimum Type</th></tr></thead><tbody><tr><td style="text-align:center"><code>u</code> or <code>U</code></td><td style="text-align:center">unsigned</td></tr><tr><td style="text-align:center"><code>l</code> or <code>L</code></td><td style="text-align:center">long</td></tr><tr><td style="text-align:center"><code>ll</code> or <code>LL</code></td><td style="text-align:center">long long</td></tr></tbody></table><p><b>Character</b> and <b>Character String</b> Literals:</p><table><thead><tr><th style="text-align:center">Prefix</th><th style="text-align:center">Meaning</th><th style="text-align:center">Type</th></tr></thead><tbody><tr><td style="text-align:center"><code>u</code></td><td style="text-align:center">Unicode 16 character</td><td style="text-align:center">char16_t</td></tr><tr><td style="text-align:center"><code>U</code></td><td style="text-align:center">Unicode 32 character</td><td style="text-align:center">char32_t</td></tr><tr><td style="text-align:center"><code>L</code></td><td style="text-align:center">wide character</td><td style="text-align:center">wchar_t</td></tr><tr><td style="text-align:center"><code>u8</code></td><td style="text-align:center">utf-8(string literals only)</td><td style="text-align:center">char</td></tr></tbody></table><h2 id="1-2-变量-Variables">1.2 变量 Variables</h2><blockquote><p>A variable provided us with <b>named storage</b> that our programs can manipulate. Variable’s <b>type</b> determines everything about it.</p><p>变量就相当于提供了一个有 <b>名字</b> 的 <b>存储空间</b> 以供程序操控。其 <b>类型</b> 决定了我们能对这个存储空间所作的操作。</p></blockquote><div class="tips"><p><b>Static Typing(静态类型)</b></p><p>C++ is a <b>statically typed language</b>, which means that <b>types are checked at compile time</b>. The process by which types are checked is referred to as <b>type checking</b>.</p><p>As we’ve seen, the type of an object constrains the operations that the object can perform. <b>In C++, the compiler checks whether the operations we write are supported by the types we use.</b> If we try to do things that the type does not support, the compiler generates an error message and does not produce an executable file.</p><p>As our programs get more complicated, we’ll see that static type checking can help find bugs. However, a consequence of static checking is that the type of every entity we use must be known to the compiler. As one example, we must <b>declare the type of a variable before we can use that variable.</b></p><p>区别于那些定义变量时无需添加类型说明符（type specifier）的语言，理解静态类型。静态类型即在 <b>编译阶段</b> 检查类型。</p><p>相对应的，变量在定义后不会被限制死为某一固定类型，允许其有不同的数据类型的语言即为 <b>动态类型（dynamically typing）</b>。一个典型的例子就是 <b>JavaScript</b>。</p></div><h3 id="变量的定义-Definition">变量的定义 Definition</h3><p>变量的定义分为两部分，<b>类型说明符（Type Specifier）</b> + 若干个 <b>声明符（declarator）</b> 。</p><ul class="lvl-0"><li class="lvl-2"><p>类型说明符（Type Specifier）：表征变量的 <b>基本类型（Base Type）</b></p></li><li class="lvl-2"><p>声明符（Declarator）：通常内容即 <b>变量名</b></p><p>声明符部分还会包含 <b>类型修饰符</b>，如 指针（<code>*</code>）、引用（<code>&amp;</code>）的复合修饰。</p></li></ul><h3 id="类型说明符-Type-Specifier">类型说明符 Type Specifier</h3><p>类型说明符一般就是声明类的基本类型。</p><p>有时类型说明符比较复杂，比如<code>long long</code>，我们希望将其简化，可以对其起别名。</p><h4 id="类型别名-Type-Alias">类型别名 Type Alias</h4><p>两种起别名的方式：</p><ol><li class="lvl-3"><p>typedef</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">double</span> db;       <span class="hljs-comment">// db is a synonym for double</span><br><span class="hljs-keyword">typedef</span> db w1, w2;       <span class="hljs-comment">// w1, w2 are synonyms for double</span><br><span class="hljs-keyword">typedef</span> db *d;           <span class="hljs-comment">// d is a synonym for double*</span><br>                         <span class="hljs-comment">// the declarators can include type modifiers</span><br></code></pre></td></tr></table></figure><p>typedef 定义数组：<code>typedef &lt;元素类型&gt; &lt;数组名&gt; [&lt;数组大小/常量表达式&gt;]</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 16      <span class="hljs-comment">// define 是宏定义语句，结尾无需分号；而 typedef 是类型别名定义，属于常规语句，需要加分号结尾 </span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> matrix[N][N];     <span class="hljs-comment">// 定义了一个名为 matrix 的 int 数组</span><br><br>matrix m;  <span class="hljs-comment">// 等价 int m[N][N];</span><br>m[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure></li><li class="lvl-3"><p>using</p><p>C++11 新特性：alias declaration</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> SI = Sales_item;    <span class="hljs-comment">// SI is a synonym for Sales_item</span><br></code></pre></td></tr></table></figure></li></ol><div class="warning"><p>起别名时要注意复合类型（compound types）的情况：容易出现理解错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> *pchar;    <span class="hljs-comment">// pchar is a sysnonym for char*</span><br><span class="hljs-comment">// since type modifiers are part of declarators</span><br><span class="hljs-type">const</span> pchar cstr = <span class="hljs-number">0</span>;   <span class="hljs-comment">// const modifies the given type(pchar), so cstr is a const pointer to char</span><br></code></pre></td></tr></table></figure></div><hr><p>C++11中还给了一些更灵活的类型说明符：<b>auto</b> 与 <b>decltype</b>。</p><h4 id="auto">auto</h4><p>C++11引入， <code>auto</code>是一个类型说明符（Type Specifier）。</p><p><code>auto</code> tells the compiler to deduce the type from the initializer. By implication, a variable that uses auto as its type specifier <b>must have an initializer</b>.</p><p>编译器自动根据字面值来推断变量类型，显然 <code>auto</code> 定义的变量 <b>必须有初始值</b>。</p><h4 id="decltype">decltype</h4><p>decltype的含义是 “declared type”。</p><p>获得表达式或函数返回值类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">f</span>()) sum = x;        <span class="hljs-comment">// 给出函数f的返回类型</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> ci = <span class="hljs-number">0</span>, &amp;cj = ci;<br><span class="hljs-keyword">decltype</span>(ci) x = <span class="hljs-number">0</span>;            <span class="hljs-comment">// x的类型为const int</span><br><span class="hljs-keyword">decltype</span>(cj) y = x;            <span class="hljs-comment">// y的类型为绑定const int的引用</span><br>                               <span class="hljs-comment">// 此处引用不再作为所指对象的同义词，而是获取了其引用类型</span><br></code></pre></td></tr></table></figure><h3 id="声明符-Declarator">声明符 Declarator</h3><h4 id="标识符-Identifiers">标识符 Identifiers</h4><p>声明符（Declarator）：通常内容即 <b>变量名</b>，由标识符组成。标识符不能出现的情况：</p><ul class="lvl-0"><li class="lvl-2"><p><code>__</code> two consecutive underscores;</p></li><li class="lvl-2"><p><code>_A</code> begin with an underscore followed immediately by an uppercase letter;</p></li><li class="lvl-2"><p>在函数体外定义的变量标识符最好不要用下划线作为开头，以便于下划线指明内部变量的含义。</p><p>即，下划线开头定义的变量通常用作类或函数的内部变量。</p></li></ul><p>Some generally accepted conventions for naming variables:</p><ul class="lvl-0"><li class="lvl-2"><p>标识符要体现实际含义；</p></li><li class="lvl-2"><p>驼峰式命名或者下划线分割单词；</p></li><li class="lvl-2"><p>变量名通常均为小写字母；</p></li><li class="lvl-2"><p>用户自定义的类名通常以大写字母开头，比如 <code>Sales_item</code>;</p></li><li class="lvl-2"><p>同上，下划线开头定义的变量通常用作类或函数的内部变量。</p></li></ul><h4 id="类型修饰符-Type-Modifier">类型修饰符 Type Modifier</h4><p>声明符部分还会包含 <b>类型修饰符</b>，如 指针（<code>*</code>）、引用（<code>&amp;</code>）的复合修饰。</p><p>具体内容见下一节。重点在于记住 <b>类型修饰符（指针与引用）是声明符的一部分，与类型说明符无关。</b></p><h3 id="变量的初始化-Initialization">变量的初始化 Initialization</h3><h4 id="初始化-与-赋值">初始化 与 赋值</h4><p>初始化（Initialization）与赋值（Assignment）在C++中是两种完全不同的操作：</p><ul class="lvl-0"><li class="lvl-2"><p><b>Initialization</b>: happens when a variable is given a value when it is created;</p><p>即创建时第一次赋给变量一个值；</p></li><li class="lvl-2"><p><b>Assignment</b>: obliterates an object’s current value and replaces that value with a new one.</p><p>即在已创建的情况下，除去原有的值并赋予新值。</p></li></ul><h4 id="初始化的默认值-Default-Initialization">初始化的默认值 Default Initialization</h4><ul class="lvl-0"><li class="lvl-2"><p>内置类型如果没有在初始化时显式赋值，其默认值取决于其初始化语句所在的位置：</p><ul class="lvl-2"><li class="lvl-4"><p>位于函数体外：初始化为 0 ；</p></li><li class="lvl-4"><p>位于函数体内：无初始化值，即未定义，其将会有一个未知值。</p><p>编译器并不会对这种情况报错，只会在某些使用场景下给出警告。这是一个合法但十分危险的行为！</p></li></ul></li><li class="lvl-2"><p>类的对象如果没有被显式的初始化，则其值由类本身确定。</p><p>即类中要考虑值的初始化问题，而不应该交给编译器决定。</p></li></ul><h4 id="列表初始化-Initialization-List（C-11）">列表初始化 Initialization List（C++11）</h4><p>Part of C<ins>11, use <b>curly braces</b> for initialization.<br>C</ins>11引入的一种全新的变量初始化方式，使用花括号：</p><ul class="lvl-0"><li class="lvl-2"><p>Normal Initialization</p><ul class="lvl-2"><li class="lvl-4"><code>int i = 0;</code></li><li class="lvl-4"><code>int i(0);</code></li></ul></li><li class="lvl-2"><p>List Initialization:</p><ul class="lvl-2"><li class="lvl-4"><code>int i = &#123;0&#125;;</code></li><li class="lvl-4"><code>int i&#123;0&#125;;</code></li></ul></li></ul><p>One thing we have to care about is that: the compiler will not let us list initialize variables of built-in type if the initializer might lead to <b>the loss of information</b>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">double</span> pi = <span class="hljs-number">3.1415926</span>;<br><span class="hljs-type">int</span> a&#123;pi&#125;, b = &#123;pi&#125;;              <span class="hljs-comment">// error: narrowing conversion required 会失去信息！</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">c</span><span class="hljs-params">(pi)</span>, d </span>= pi;                <span class="hljs-comment">// ok but value will be truncated</span><br></code></pre></td></tr></table></figure><h3 id="变量的声明-Declaration">变量的声明 Declaration</h3><blockquote><p>为了支持分离式编译（separate compilation），C++ 要将 声明（declarations） 与 定义（definitions） 两种操作区分开。</p><p>To use a variable in more than one file requires declarations that are separate from the variable’s definition. To use the same variable in multiple files, we must define that variable in one—and only one—file. Other files that use that variable must declare—but not define—that variable.</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>Declaration: <b>makes a name known to the program</b>, specifies the type and name of a variable;</p><p>To obtain a declaration that is not also a definition, we add the <code>extern</code> keyword and do not provide an explicit initializer.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> i;      <span class="hljs-comment">// declares but does not define i</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;  <span class="hljs-comment">// definition, the initializer overrides the extern.</span><br>                   <span class="hljs-comment">// It is an error to provide an initializer on an extern 【inside a function】.</span><br></code></pre></td></tr></table></figure></li><li class="lvl-2"><p>Definition: creates the associated entity, which allocates storage and may provide the variable with an initial value.</p></li></ul><h3 id="变量的作用域-Scope">变量的作用域 Scope</h3><p>Most scopes in C++ are delimited by curly braces <code>&#123;&#125;</code>.</p><ul class="lvl-0"><li class="lvl-2"><p>Global Scope: defined outside a function;</p></li><li class="lvl-2"><p>Block Scope: defined inside a function;</p></li><li class="lvl-2"><p>Nested Scopes: Names declared in the outer scope can also be redefined in an inner scope. Legit but NOT recommended.</p></li><li class="lvl-2"><p>Scope Operator <code>::</code></p><p>Scope operator can override the default scoping rules.</p><p>The global scope has no name. Hence, when the scope operator has an empty left-hand side, it is a request to fetch the name on the right-hand side from the global scope.</p></li></ul><h1>2 复合类型 Compound Type</h1><blockquote><p>复合类型指 <b>基于其他基本类型定义的类型</b>。</p><p>本文介绍其中两种，<strong>引用</strong>和<strong>指针</strong>。</p></blockquote><h2 id="2-1-引用-References">2.1 引用 References</h2><blockquote><p>此处的引用均指 <b>左值引用（lvalue reference）</b> 。</p><p>C++11引入了一种新的引用：<b>右值引用（rvalue reference）</b> ，不在此处讨论范围内。</p></blockquote><p>有关引用的一些基本规则：</p><ul class="lvl-0"><li class="lvl-2"><p>引用就是个 <b>别名</b>。</p><p>A reference is just an Alias.</p></li><li class="lvl-2"><p>引用必须初始化。且一经初始化 <b>无法绑定到其他变量上</b>。</p><p>一切对引用的操作实际就是对其绑定的对象操作。</p><p>When we define a reference, we do not copy the initializer’s value but bind the reference to its initializer(an object).</p><p>Once initialized, a reference remains bound to its initial object. There is NO WAY TO REBIND a reference to refer to a different object.</p><p>Since there is no way to rebind a reference, reference must be initialized.</p></li><li class="lvl-2"><p>不能定义引用的引用，引用并不占用任何实际的内存（不是一个狭义的对象）。</p><p>References are not objects, we may not define a reference to a reference.</p></li><li class="lvl-2"><p>在几乎所有情况下，引用声明类型 和 绑定数据类型 必须一致。</p><p>Generally speaking, <i>the type of a reference</i> and <i>the object to which the reference</i> refers must match exactly.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">double</span> d = <span class="hljs-number">3.14</span>;<br><span class="hljs-type">int</span> &amp;r = d;          <span class="hljs-comment">// error: initializer must be an int object</span><br></code></pre></td></tr></table></figure></li><li class="lvl-2"><p>引用必须绑定对象，不能将引用绑定到任何字面值。</p><p>A reference may be bound only to an object, not to a literal or to the result of a more general expression.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> &amp;r = <span class="hljs-number">10</span>;         <span class="hljs-comment">// error: initializer must be an object</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="2-2-指针-Pointers">2.2 指针 Pointers</h2><h3 id="指针相关的操作符-Operator">指针相关的操作符 Operator</h3><blockquote><p>在声明中使用和在表达式中使用具有不同的含义。</p></blockquote><h4 id="address-of-operator-取地址"><code>&amp;</code> address-of operator 取地址</h4><p>Take the address of an object.</p><ul class="lvl-0"><li class="lvl-2"><p>在声明中：属于 声明符/类型修饰符（Type Modifier） 的一部分（即变量名的一部分），说明其在声明一个绑定至基类类型（Base Type / Type Specifier）的引用；</p></li><li class="lvl-2"><p>在表达式中：取地址运算符，获得其后对象的地址。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Multiple meanings:</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> &amp;r = i;               <span class="hljs-comment">// part of a declaration, &amp; is a type modifier, r is a reference</span><br><span class="hljs-type">int</span> *p = &amp;i;              <span class="hljs-comment">// used in an expression as the address-of operator</span><br></code></pre></td></tr></table></figure><h4 id="dereference-operator-解引用"><code>*</code> dereference operator 解引用</h4><p>Access the object.</p><ul class="lvl-0"><li class="lvl-2"><p>在声明中：属于 声明符/类型修饰符（Type Modifier） 的一部分（即变量名的一部分），说明其在声明一个指向基类类型（Base Type / Type Specifier）的指针；</p></li><li class="lvl-2"><p>在表达式中：解引用，读取后面指针变量指向的地址空间。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Multiple meanings:</span><br><span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> *p = &amp;i;               <span class="hljs-comment">// part of a declaration, * is a type modifier, p is a pointer</span><br>*p = j;                    <span class="hljs-comment">// used in an expression as the dereference operator</span><br></code></pre></td></tr></table></figure><h3 id="空指针-Null-Pointer">空指针 Null Pointer</h3><p>Several ways to obtain a null pointer:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> *p1 = <span class="hljs-literal">nullptr</span>;         <span class="hljs-comment">// recommended, introduced by C++11</span><br><span class="hljs-type">int</span> *p2 = <span class="hljs-number">0</span>;   <span class="hljs-comment">// 显式赋 0 时得到的也是空指针</span><br><span class="hljs-type">int</span> *p3 = <span class="hljs-literal">NULL</span>;            <span class="hljs-comment">// not recommended</span><br><span class="hljs-comment">// Modern C++ programs generally should avoid using NULL and use nullptr instead.</span><br><span class="hljs-type">int</span> *p4 = <span class="hljs-literal">nullptr</span>;<br></code></pre></td></tr></table></figure><blockquote><p><code>NULL</code> is a preprocessor variable used in older programs, which the <code>cstdlib</code> header defines as 0.</p></blockquote><h3 id="指向任意类型的指针-Void-Pointer">指向任意类型的指针 Void* Pointer</h3><ul class="lvl-0"><li class="lvl-2"><p>The type <code>void*</code> is a special pointer type that can <strong>hold the address of any object</strong>.</p><p>指向任意类型的指针。</p></li><li class="lvl-2"><p>We can <strong>not</strong> use a <code>void*</code> to operate on the object it addresses—we don’t know that object’s type, and the type determines what operations we can perform on the object.</p><p>Thus, we use a <code>void*</code> pointer to deal with memory <strong>as memory</strong>, rather than using the pointer to access the object stored in that memory.</p><p>无法通过指针操作其对象，因为数据类型不确定。</p></li></ul><h3 id="一些指针的特殊操作-Pointer-Operations">一些指针的特殊操作 Pointer Operations</h3><h4 id="Wild-Pointer-野指针">Wild Pointer 野指针</h4><blockquote><p>Distinguish <b>a invalid/wild pointer</b> from <b>a null pointer</b>.</p><p>The first one means we do NOT know where it points to. The latter one means it is not bound to any object.</p></blockquote><p>避免野指针，错误无法被编译器发现，会引发完全未知的结果。因此，对所有指针都进行初始化以防止野指针出现。</p><p>It is an error to copy or otherwise try to access the value of an invalid pointer. As when we use an uninitialized variable, this error is one that <b>the compiler is unlikely to detect</b>. The result of accessing an invalid pointer is undefined.<br>Advice: Initialize all Pointers.</p><h4 id="Assign-an-int-variable-to-a-pointer-Illegal">Assign an int variable to a pointer - Illegal</h4><p>It is <b>ILLEGAL</b> to assign an int variable to a pointer, even if the variable’s value happens to be 0.<br>不能把 <code>int</code> 变量赋给指针值当作地址（即使其值恰好为 0 也不行）。指针只能接受地址（取地址符或常量）或空值（<code>nullptr</code>）。</p><h4 id="Use-a-pointer-in-a-condition">Use a pointer in a condition</h4><p>So long as the pointer has a valid value, we can use a pointer in a <strong>condition</strong>.<br>可以将指针作为条件表达式中作为判断，根据其实际值进行判断即可。</p><h2 id="2-3-复合类型的声明-Compound-Type-Declarations">2.3 复合类型的声明 Compound Type Declarations</h2><h3 id="普通声明">普通声明</h3><p>类型修饰符是声明符的一部分，即 <code>*</code> 和 <code>&amp;</code> 是修饰变量名的，而非修饰基本类型。这也意味着 <b>一句</b> 变量定义可以定义多个多种类型的变量（普通类型、指针类型、引用类型）。<br>The <b>type modifiers</b> (<code>*</code> or <code>&amp;</code>) are part of a declarator.</p><h3 id="指向指针的指针-Pointers-to-Pointers">指向指针的指针 Pointers to Pointers</h3><p>根据数量判断指针级别。<br>Indicate each pointer level by its own <code>*</code>.</p><h3 id="指针变量的引用-References-to-Pointers">指针变量的引用 References to Pointers</h3><p>A reference is not an object. Hence, we may NOT have a pointer to a reference.<br>Since a pointer is an object, we can define a reference to a pointer.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> *p = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-type">int</span> *&amp;r = p;              <span class="hljs-comment">// r is a reference to the pointer p</span><br></code></pre></td></tr></table></figure><blockquote><p>Read the definition <b>right to left</b> (backwards).</p><p>从右向左读，离变量名越近影响越直接。</p></blockquote><h1>3 常量与常量表达式 Constant</h1><h2 id="3-1-常量的基本概念">3.1 常量的基本概念</h2><h3 id="const-限定词">const 限定词</h3><p>加上 const 限定词（Qualifier）的变量即为常量变量，特点有：</p><ul class="lvl-0"><li class="lvl-2"><p>值不能被改变。任何修改其值的行为都会引发错误；</p></li><li class="lvl-2"><p>必须初始化，即定义时必须赋初值；</p></li><li class="lvl-2"><p>常量能够实现大部分其数据类型能够实现的功能，唯一的限制就是这些功能必须不改变其内容；</p></li><li class="lvl-2"><p>编译器会在编译过程中把用到常量的地方都替换成其对应的值。</p></li></ul><h3 id="const-的作用域">const 的作用域</h3><p>默认状态下，const 对象仅在当前文件内有效（defined as local to the file）。</p><p>想要在多个文件之间共享同一个 const 对象，就要给变量（无论是声明和定义）添加为 <code>extern</code> 关键字。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// file1.cc defines and intializes</span><br><span class="hljs-comment">// the extern signifies that this variable is not local to this file</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> bufSize = <span class="hljs-number">500</span>; <br><span class="hljs-comment">// file2.cc delcares</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> bufSize;<br></code></pre></td></tr></table></figure><h2 id="3-2-复合常量-compound-const">3.2 复合常量 compound const</h2><blockquote><p>复合 const 较复杂，一定要理解方法：</p><ul class="lvl-1"><li class="lvl-2"><p><code>const</code> 意味着变量的值不能修改，也意味着必须初始化；</p></li><li class="lvl-2"><p><b>常量引用</b> 意味着什么？</p><p>并不意味着引用是常量，因为引用本身不是一个对象。常量引用只是对引用可参与的操作做出了限定。</p></li><li class="lvl-2"><p><b>常量指针</b> 和 <b>指向常量的指针</b> 意味着什么？</p></li><li class="lvl-2"><p><b>从右向左 </b>分析各个限定符对变量名的影响。</p></li></ul></blockquote><h3 id="常量引用-References-to-const">常量引用 References to const</h3><div class="tips"><p>我们常把 <b>绑定到常量类型的引用</b> 简称为 <b>常量引用</b>（abbreviate the phrase <b>“reference to const”</b> as <b>“const reference”</b>）。<br>C++ programmers tend to abbreviate the phrase “reference to const” as “const reference.” This abbreviation makes sense—if you remember that it is an abbreviation.</p><p>实际并不存在所谓的“常量引用”，因为引用本身根本不是个对象，更无所谓常量与否；<br>Technically speaking, there are no const references. A reference is not an object, so we cannot make a reference itself const.</p><p>考虑到 引用在初始化后不可绑定到其他对象上 的特性，引用本身在某种意义上来说就是一个常量（只是意义上相似）；<br>Indeed, because there is no way to make a reference refer to a different object, in some sense all references are const.</p></div><h4 id="常量引用的概念与特性">常量引用的概念与特性</h4><ul class="lvl-0"><li class="lvl-2"><p><b>常量引用</b> 即绑定到常量类型的引用。</p></li><li class="lvl-2"><p>常量引用是对 <b>引用可参与的操作</b> 做出了限定，意味着 <b>无法通过该引用对其绑定的对象进行修改</b>。</p></li><li class="lvl-2"><p>常量引用 与 引用能够能够改变绑定对象 二者是完全无关的。毕竟引用本来一经初始化就不能更改绑定。</p><p>Whether a reference refers to a const or non-const type affects what we can do with that reference, not whether we can alter the binding of the reference itself.</p></li><li class="lvl-2"><p>常量引用允许绑定到非常量对象上。只会限制常量可参与的操作，即无法通过常量引用修改其绑定的非常量对象，但仍然可以通过其他方式修改。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;ci = i;<span class="hljs-comment">// 正确，但不能通过 ci 来修改 i</span><br></code></pre></td></tr></table></figure></li><li class="lvl-2"><p>只有常量引用才能绑定到一个常量对象上。即，<b>普通引用绑定到常量对象上是非法的</b>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> c = <span class="hljs-number">0</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;r1 = c;        <span class="hljs-comment">// correct</span><br><span class="hljs-type">int</span> &amp;r2 = c;              <span class="hljs-comment">// error: non-const reference can not bind to a const object</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="常量引用的初始化">常量引用的初始化</h4><p>通常情况下，引用的类型 必须和 其绑定的对象类型 一致。<br>Normally, the type of a reference must match the type of the object to which it refers.</p><p>这里有一种例外情况：常量引用的初始化语句中，允许使用 <b>任意表达式</b> 作为初始值，只要该表达式的结果能够转换为引用的类型即可。<br>One of the exception is that we can initialize a reference to <code>const</code> from <b>any expression</b> that <b>can be converted to the type of the reference</b>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">double</span> dval = <span class="hljs-number">3.14</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;cri = dval;<span class="hljs-comment">// correct 绑定至不同类型</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;crl = <span class="hljs-number">42</span>;    <span class="hljs-comment">// correct 绑定至字面值</span><br></code></pre></td></tr></table></figure><p>之所以能够实现这种例外，是因为编译器创建了一个<b>临时量</b>。<br>When we bind a <code>const</code> reference to an object of a <strong>different type</strong>, it is actually bound to a <strong>temporary object.</strong> A temporary object is an unnamed object created by the compiler when it needs a place to store a result from evaluating an expression.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 上述两种转换的内部实现</span><br><span class="hljs-comment">// const int &amp;cri = dval;</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> temp = dval;<span class="hljs-comment">// type conversion</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;cri = temp;<span class="hljs-comment">// bind to the temp object</span><br><br><span class="hljs-comment">// const int &amp;crl = 42;</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> temp = <span class="hljs-number">42</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;crl = temp;<br></code></pre></td></tr></table></figure><div class="tips"><p><b>非常量引用绑定至不同类型的对象</b></p><p>假设我们定义了一个非常量引用，并试图将其绑定至不同的类型。比如 <code>int &amp;ri = dval</code> （<code>int</code> 引用绑定至<code>double</code> 对象），我们可以分析此时的特点：</p><ul class="lvl-1"><li class="lvl-2"><p>既然是一个非常量引用，我们一定希望通过该引用来改变其绑定的对象；</p></li><li class="lvl-2"><p>因为存在类型转换，所以该引用实际上是绑定至一个 <b>临时量</b>；</p></li></ul><p>这种情况下，我们显然无法通过 <code>ri</code> 来访问 <code>dval</code> ，因为 <code>ri</code> 实际绑定至了一个临时量！这并没有任何的实际意义，所以这种行为被归为非法。</p></div><h3 id="常量与指针-const-and-pointer">常量与指针 const and pointer</h3><p>指针与引用不同。引用并非对象，没有实际存储的内容，仅仅作为一个别名存在。而指针本身也是一个对象，所以指针与常量的结合有两种情况：</p><ol><li class="lvl-3"><p><b>指向常量对象的指针</b>：类似于常量引用，限制了其能够参与的操作，即不能通过复合类型修改其指向的实际对象。</p></li><li class="lvl-3"><p><b>常量指针</b>：指针本身是一个常量。指针变量的值不能修改，即指针只能指向一块地址空间而不能改变。</p></li></ol><h4 id="指向常量对象的指针-pointer-to-const">指向常量对象的指针 pointer to const</h4><ul class="lvl-0"><li class="lvl-2"><p>普通指针不可指向常量对象；</p></li><li class="lvl-2"><p>指向常量类型的指针可以令其指向非常量对象，但不能通过该指针修改该对象。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> *p = &amp;i;<span class="hljs-comment">// error: 普通指针不可指向常量对象</span><br><span class="hljs-comment">// 从右向左读，const 是修饰基本类型 int 的，即定义一个 普通指针 指向 const int 类型对象</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *cp1 = &amp;i;<span class="hljs-comment">// correct: 常量指针指向常量对象</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *cp2 = &amp;j;<span class="hljs-comment">// correct: 指向非常量对象，但不能通过该指针修改该对象</span><br>*cp1 = <span class="hljs-number">2</span>;<span class="hljs-comment">// error: 试图通过指向常量的指针来修改其指向值是非法的，无论其指向变量是否为常量</span><br></code></pre></td></tr></table></figure><h4 id="常量指针-const-pointer">常量指针 const pointer</h4><ul class="lvl-0"><li class="lvl-2"><p>常量指针本身的值无法修改，即其指向一个固定地址；</p></li><li class="lvl-2"><p>虽然常量指针本身的值是固定的，但是可以通过该常量指针对变量的值进行修改。</p></li><li class="lvl-2"><p>常量指针的写法：<code>*const</code> ，显然与其他不同，const写在了其修饰对象的后面。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> *<span class="hljs-type">const</span> p = &amp;i;         <span class="hljs-comment">// read from right to left</span><br>                           <span class="hljs-comment">// const修饰指针，指明该指针为常量指针，并指向 int 类型</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *<span class="hljs-type">const</span> q = &amp;j;   <span class="hljs-comment">// 双层嵌套：一个常量指针，且指向常量对象。</span><br>   <span class="hljs-comment">// 既不能修改该指针的指向，也不能通过该指针修改其指向对象</span><br></code></pre></td></tr></table></figure><h4 id="顶层与底层">顶层与底层</h4><p>显然，对于指针来说，const 存在两种情况，我们将其定义为顶层与底层：</p><ul class="lvl-0"><li class="lvl-2"><p>Top-level const：</p><p>顾名思义，const 修饰指针本身。即指针本身就是个常量，而不关心其指向变量是否为常量。</p><p>扩展到普通情况，即任意对象其本身为常量。</p><p>More generally, top-level <code>const</code> indicates that an object itself is <code>const</code>.</p><p>我们可以说，任意的对象都能被声明为顶层 const，因为顶层的含义形容的就是自身。</p><p>Top-level <code>const</code> can appear in any object type.</p></li><li class="lvl-2"><p>Low-level const：</p><p>与之对应的，底层 const 只能修饰复合类型，因为底层的含义是其指向或绑定的对象为常量。</p><p>显然：</p><ul class="lvl-2"><li class="lvl-4"><p>指针：既可以是顶层又可以是底层 const，一个特殊情况。</p></li><li class="lvl-4"><p>引用：因为引用本身不是个对象，所以引用只能出现底层 const 的情况。</p><p>值得注意的是，不要误会底层 const 的引用一定会绑定一个常量对象。因为常量引用仍然可以指向普通对象，只是不能通过常量引用来修改。</p></li></ul></li><li class="lvl-2"><p>顶层与底层的影响：</p><p>对赋值时拷贝有所影响。</p><ul class="lvl-2"><li class="lvl-4"><p>顶层：对象本身是常量并不影响我们拷贝其值来进行赋值，因为拷贝操作并不会修改对象的值。</p></li><li class="lvl-4"><p>底层：底层在拷贝的时候要注意，因为底层会影响顶层复合类型对其能够进行的操作，所以其底层对象必须类型能够匹配或者能够合理转换：常量可以转为非常量，反之不可。</p><p>比如：</p><ul class="lvl-4"><li class="lvl-6"><p>非常量引用不能绑定至一个常量对象上，因为常量对象无法转换为非常量；</p></li><li class="lvl-6"><p>常量引用可以绑定到一个普通对象上，只是不能通过该常量引用对其进行修改。即拷贝赋值时普通对象转换为常量对象。</p></li></ul></li></ul></li></ul><h2 id="3-3-常量表达式-const-expression">3.3 常量表达式 const expression</h2><h3 id="基本概念">基本概念</h3><p>一个表达式满足如下两个特点即为常量表达式：</p><ol><li class="lvl-3"><p>值不会改变</p></li><li class="lvl-3"><p>编译过程就能得到计算结果</p></li></ol><p>一个对象或表达式是不是常量表达式由它的数据类型（type）和初始值（initializer）共同决定：</p><ul class="lvl-0"><li class="lvl-2"><p>字面值：a <strong>literal</strong> is a constant expression</p></li><li class="lvl-2"><p>初值由常量表达式给定的常量对象：a <strong><code>const</code> object</strong> that is initialized from a constant expression is also a constant expression</p></li><li class="lvl-2"><p>由上述两种对象进行运算组成的表达式也是常量表达式。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;                 <span class="hljs-comment">// i is a constant expression</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>;             <span class="hljs-comment">// j is a constant expression</span><br><br><span class="hljs-type">int</span> k = <span class="hljs-number">3</span>;                       <span class="hljs-comment">// k is not because of its 【type】</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> q = <span class="hljs-built_in">get_size</span>()         <span class="hljs-comment">// q is not because of its 【initializer】</span><br></code></pre></td></tr></table></figure><h3 id="constexpr-类型">constexpr 类型</h3><blockquote><p>我们希望一个定义一个常量，但有的时候初始值较为复杂，右侧表达式难以判断是否为常量表达式。如果右侧不是，编译器显然会报错。</p><p>C++增加了一个新的机制，我们可以将该变量定义为常量表达式类型，右侧值是否为常量表达式则交给编译器去判断。</p><p>Generally, it is a good idea to use <code>constexpr</code> for variables that you intend to use as constant expressions.</p></blockquote><p>C++11: ask the <strong>compiler</strong> to verify that a variable is a constant expression by declaring the variable in a <code>constexpr</code> declaration.</p><ul class="lvl-0"><li class="lvl-2"><p>Variables declared as <code>constexpr</code> are</p><ul class="lvl-2"><li class="lvl-4"><p>implicitly <code>const</code></p></li><li class="lvl-4"><p>must be initialized by constant expressions</p><p>We can not use an ordinary function as an initializer for a <code>constexpr</code> variable.</p><p>However, C++11 define certain functions as <code>constexpr</code>. We can use <code>constexpr</code> functions in the initializer of a <code>constexpr</code> variable.</p></li></ul></li><li class="lvl-2"><p>Generally, it is a good idea to use <code>constexpr</code> for variables that you intend to use as constant expressions.</p></li></ul><h3 id="Literal-type-字面类型">Literal type 字面类型</h3><blockquote><p>详见后，仅略了解</p></blockquote><p>Because a constant expression is one that can be evaluated at compile time, there are limits on the types that we can use in a <code>constexpr</code> declaration. The types we can use in a <code>constexpr</code> are known as “<strong>literal types</strong>” because they are simple enough to have literal values.</p><ul class="lvl-0"><li class="lvl-2"><p>We can initialize a <code>constexpr</code> pointer only from <strong>the <code>nullptr</code> literal$$_{[1]}$$</strong>, <strong>the literal 0$$_{[2]}$$</strong> or <strong>an object that remains at a fixed address$$_{[3]}$$</strong>.</p></li><li class="lvl-2"><p>Variables defined <strong>inside a function</strong> ordinarily are not stored at a fixed address. Hence, we cannot use a<code>constexpr</code> pointer to point to such variables.</p><p>On the other hand, the address of an object defined outside of any function is a constant expression, and so may be used to initialize a <code>constexpr</code> pointer.</p></li><li class="lvl-2"><p><code>constexpr</code> pointer is a <strong>exception</strong>. The <code>constexpr</code> imposes a top-level <code>const</code> on the subject.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> *q = <span class="hljs-literal">nullptr</span>;        <span class="hljs-comment">// q is a constexpr point</span><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>复合类型(Compound Type)</tag>
      
      <tag>引用(reference)</tag>
      
      <tag>指针(pointer)</tag>
      
      <tag>const常量限定符</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搜索</title>
    <link href="/2020/04/29/%E6%90%9C%E7%B4%A2/"/>
    <url>/2020/04/29/%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>三种写法都要熟练：</p><ol><li class="lvl-3">DFS递归</li><li class="lvl-3">DFS栈</li><li class="lvl-3">BFS队列</li></ol><p>[树](##二叉树 Binary Tree)与[图](##图 Graph)的搜索详见其各自的部分。</p></blockquote><h2 id="DFS-与-BFS-2">DFS 与 BFS</h2><h3 id="DFS-2">DFS</h3><p><strong>实现方式</strong></p><ul class="lvl-0"><li class="lvl-2"><p>递归实现</p></li><li class="lvl-2"><p>栈实现：与递归等价，但递归容易出现递归栈满情况，所以栈可能在工程中效果更好。</p></li></ul><p><strong>难点</strong></p><ul class="lvl-0"><li class="lvl-2"><p>剪枝：把可能剪枝的递归分叉放进判断语句中</p></li><li class="lvl-2"><p>存放最优方案：在递归分叉前后增加语句</p></li><li class="lvl-2"><p>递归边界的确定</p></li></ul><h3 id="BFS-2">BFS</h3><h4 id="层数记录-最短距离-2">层数记录 / 最短距离</h4><p>对节点建立结构体，并增加<strong>层数/深度</strong>成员，用以记录节点或集合之间的距离。</p><ul class="lvl-0"><li class="lvl-2"><p>934 Shortest Bridge 最短的桥 (Medium)</p><p>解法：首先使用任意搜索（这里使用DFS）来找到第一座岛，并在搜索过程中将该岛外沿的一圈海域存入队列。从这些队列中的节点开始进行BFS并记录层数。</p></li></ul><h4 id="双向BFS-2">双向BFS</h4><blockquote><img src="https://tao1st-1317129655.cos.ap-beijing.myqcloud.com/pics-master/202203211456914.png" style="zoom:15%;" /><p>从起点 BFS 直至终点，最终会形成一棵树，类似与层序遍历。<strong>对于无向图</strong>，从起点搜终点和从终点搜起点都会形成一颗树，形状可能会不一样。</p><p>**如果两个方向的BFS都是随着层数加深，当前层节点数越来越多的结构的话，**那么从起点和终点同时BFS，可以减少很多无效转移。这个方法可以带来多少提升跟两个方向的树的形状有关系。如果两个方向的树都是随着深度加深越来越宽的结构，并且深度比较深的话，可以有明显的加速。</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>126 单词接龙 II (Hard)</p></li><li class="lvl-2"><p>127 单词接龙 (Hard)</p><p>太难了，不做</p></li></ul><h3 id="题目-4">题目</h3><ul class="lvl-0"><li class="lvl-2"><p>695 Max Area of Island 岛屿的最大面积 (Medium)</p><p>基本题，每种搜索方式都写一编增加熟练度。</p></li><li class="lvl-2"><p>547 Number of Provinces 省份数量 (Medium)</p><p>基本题。</p></li><li class="lvl-2"><p><em>417 Pacific Atlantic Water Flow 太平洋大西洋水流问题 (Medium)</em></p><p>最直观的想法是对每个点进行搜索，查看是否能达到边缘，这样时间复杂度会达到$O(n^3)$。</p><p>解法：<strong>从两边向内进行搜索</strong>。从上侧边和左侧边出发搜索得到能到达太平洋的节点；从右侧边和下侧边出发搜索得到能到达大西洋的节点。最后再统计两侧都能达到的节点即为答案所求。</p></li><li class="lvl-2"><p>130 Surrounded Regions 被围绕的区域 (Medium)</p></li><li class="lvl-2"><p><strong>241 Different Ways to Add Parentheses 为运算表达式设计优先级 (Medium)</strong></p><p>DFS + Memoization 记忆化搜索</p><p>对于本题来说，自顶向下的记忆化搜索比自底向上的DP要更直观。</p></li><li class="lvl-2"><p><strong>2328 Number of Increasing Paths in a Grid 网格中递增路径的数目 (Hard)</strong></p><p>DFS + Memoization 记忆化搜索</p><p>定义数组<code>dp[i][j]</code>，代表以$(i, j)$为起点的递增路径数，实现记忆化搜索。</p></li></ul><h2 id="回溯-Backtracking-2">回溯 Backtracking</h2><p>本质是<strong>状态还原</strong>。在深搜的基础上多了这个环节：</p><ul class="lvl-0"><li class="lvl-2"><p>深搜：修改当前状态  —  进入递归</p></li><li class="lvl-2"><p>回溯：修改当前状态  —  进入递归  —  返回后还原状态（以便下一次的尝试）</p></li></ul><h3 id="排列-2">排列</h3><blockquote><ul class="lvl-1"><li class="lvl-2"><p>对于排列问题：不同顺序属于不同结果，即<code>[1,2,3]</code>与<code>[1,3,2]</code>为不同结果。</p><p>设置<strong>访问数组</strong>，回溯的内容即<strong>元素是否被使用过</strong>。</p></li><li class="lvl-2"><p><em>去重</em>：</p><p>初始序列存在重复值的情况，即<code>[2',2,3]</code>与<code>[2,2'3]</code>为相同结果，重点关注此时的去重问题。</p><p><em>排序 + 访问数组</em>：对于排列问题，如果涉及到<strong>重复元素</strong>，立马想到先<strong>排序</strong>、使得相同元素全部相邻后再进行处理。</p></li></ul></blockquote><ul class="lvl-0"><li class="lvl-2"><p><strong>46 Permutations 全排列 (Medium)</strong></p><p>排列：经典回溯试探题目。解法有几种小技巧：</p><ul class="lvl-2"><li class="lvl-4"><p>解法一：记录节点访问状态；</p><p>回溯的内容是<strong>元素是否已经被用过</strong>。</p></li><li class="lvl-4"><p>解法二：对节点进行交换；</p><p>回溯的内容是<strong>元素的交换</strong>，即<strong>将元素归位</strong>。</p></li><li class="lvl-4"><p>解法三：使用库函数<code>prev_permutation</code>与<code>next_pertation</code></p><p>无需回溯。</p><blockquote><p><strong>注意！两个库函数二者缺一不可！</strong></p><p>值得注意的是使用<code>next_permutation</code>函数的一个错误点：达到字典序的最后一个序列就会返回false。本题的初始序列并未规定为字典序最小值，所以仅使用该函数无法获得全排列。</p></blockquote></li></ul></li><li class="lvl-2"><p><strong>47 Permutation II 全排列 II (Medium)</strong></p><p>与46类似，但是会存在重复元素。</p><ul class="lvl-2"><li class="lvl-4"><p>解法一：利用哈希表记录元素个数；</p><p>回溯的内容是<strong>哈希表中的内容</strong>，即<strong>当前元素剩余未使用的个数</strong>。本质上和记录元素是否使用过是一致的。</p></li><li class="lvl-4"><p><em>解法二：排序 + 访问数组 实现去重；</em></p><blockquote><p><em>Tricks!</em></p><p>涉及<em>重复元素</em>的情况，立马想到先<em>排序</em>，使相同元素相邻再进行处理。</p></blockquote><p>在处理每一位是否放置当前元素的判断上，增加一个去重的判断：如果当前元素和上一个元素相同且上一个相同元素当前未被访问，则不放置当前元素在当前位。</p><p>每一轮处理都是从左到右，如果上一个相邻的相同元素是未访问状态，说明该位已经放置过与当前值相同的元素，且已经回溯其状态。</p></li></ul></li></ul><h3 id="组合-2">组合</h3><blockquote><p>对于组合问题：不关心顺序，不同顺序属于相同结果，即<code>[1,2,3]</code>与<code>[2,1,3]</code>为相同结果。</p><ul class="lvl-1"><li class="lvl-2"><p>两种写法：</p><ol><li class="lvl-5"><p>设置<strong>搜索起点</strong>，按顺序从左到右进行搜索：</p><p>比如在<code>[1,2,3]</code>中进行选两个数进行组合，已经处理完了<code>[1,2]</code>与<code>[1,3]</code>之后，处理2开头的序列时，通过将搜索开头设置为2，从而避免出现<code>[2,1]</code>的重复选项。</p></li><li class="lvl-5"><p>回溯的内容为<strong>是否选用当前元素</strong>。选 或者不选，两条路进行递归。</p></li></ol><ul class="lvl-3"><li class="lvl-4"><p>去重：</p><p>初始序列有重复元素，就还是必须先<strong>排序</strong>，后去重。</p></li></ul></li><li class="lvl-2"><p>需要注意<strong>剪枝</strong>，提升速度。</p></li></ul></blockquote><ul class="lvl-0"><li class="lvl-2"><p><strong>77 Combinations 组合 (Medium)</strong></p><p>组合：另一种回溯，选择当前元素或不选择当前元素，即</p><p>“修改当前状态 — 进入递归（选择当前元素） — 返回并还原状态 — 进入另一条递归（不选择当前元素）”</p><p>回溯的内容是<strong>是否选择当前元素</strong>。</p><p>类似背包问题，区别在于会枚举所有的选择（没有条件限制）。</p><p>官方题解还有个进一步优化空间复杂度的做法，有空再说吧，没啥太大必要。</p></li><li class="lvl-2"><p>39 Combination Sum 组合总和 (Medium)</p></li><li class="lvl-2"><p>40 Combination Sum II 组合总和 II (Medium)</p></li></ul><h3 id="其他-4">其他</h3><ul class="lvl-0"><li class="lvl-2"><p>79 Word Search 单词搜索 (Medium)</p><p>回溯的内容是<strong>当前字符是否已访问</strong>。如果不回溯会导致从另一条路重新到达该元素时，会以为其仍为已访问元素。</p></li><li class="lvl-2"><p>51 N-queens N皇后 (Hard)</p><p>其回溯的思想并不复杂，重点在于如何模拟棋盘，如何记录对角线的占用情况。</p><p>对角线占用的处理见图模拟，自己手写一下就能够理解并得到对应与坐标的关系：</p></li><li class="lvl-2"><p>37 Sudoku Solver 解数独 (Hard)</p><p>有一些细节上的优化以后值得注意：</p><ul class="lvl-2"><li class="lvl-4"><p>使用位运算或<code>bitset</code>来简化哈希表；</p></li><li class="lvl-4"><p>先将只有唯一待选值的空缺处填上，这些位置无需回溯，然后再对剩下的进行回溯搜索。</p></li></ul></li><li class="lvl-2"><p><em>473 Matchsticks to Square 火柴拼正方形 (Medium)</em></p><p>DFS +  回溯 + <em>剪枝</em></p><p>非常值得注意的两个剪枝技巧，详情见代码。</p><ul class="lvl-2"><li class="lvl-4"><p>将数组进行逆排序的剪枝思想值得思考。</p></li></ul></li><li class="lvl-2"><p>698 Partition to K Equal Sum Subsets 划分为 k 个相等的子集 (Medium)</p><p>和473一样类型的题。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>搜索</tag>
      
      <tag>DFS</tag>
      
      <tag>BFS</tag>
      
      <tag>回溯</tag>
      
      <tag>排列</tag>
      
      <tag>组合</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
