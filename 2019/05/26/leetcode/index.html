

<!DOCTYPE html>
<html lang="zh-CN" >



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/avatar.png">
  <link rel="icon" href="/img/avatar.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#98a5ac">
  <meta name="author" content="tao1st">
  <meta name="keywords" content="">
  
    <meta name="description" content="贪心 Greedy  局部最优解能够导向全局最优解。 贪心的重点往往在于，看出这道题是贪心问题。    455 Assign Cookies 分发饼干 (Easy) 非常典型的贪心问题，需要先进行排序（根据数据规模判断可以接受O(nlogn)的时间复杂度。   135 Candy 分发糖果 (Hard) 一个特殊的题意理解错误：当两个孩子相邻且评分一致时并不一定二者分到相同的糖果。题目只要求相邻二">
<meta property="og:type" content="article">
<meta property="og:title" content="leetcode">
<meta property="og:url" content="https://tao1st.github.io/2019/05/26/leetcode/index.html">
<meta property="og:site_name" content="tao1st.github.io">
<meta property="og:description" content="贪心 Greedy  局部最优解能够导向全局最优解。 贪心的重点往往在于，看出这道题是贪心问题。    455 Assign Cookies 分发饼干 (Easy) 非常典型的贪心问题，需要先进行排序（根据数据规模判断可以接受O(nlogn)的时间复杂度。   135 Candy 分发糖果 (Hard) 一个特殊的题意理解错误：当两个孩子相邻且评分一致时并不一定二者分到相同的糖果。题目只要求相邻二">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/TAO1st/pics@master/202205260000400.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202203151641820.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202203211456914.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202204061409369.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202204061102316.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202204061102867.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202204211941410.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205161418594.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205161501183.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202204241054724.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202204261027731.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205011625893.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205011711572.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205021237853.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202112271559574.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202112271610871.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202112271610179.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202112271610855.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202112271610897.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202112271611950.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205111123247.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205111539729.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205151303835.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205151303981.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205151304030.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205151304895.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205151305541.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205151305963.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205151305388.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205151305522.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205151305620.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205151306852.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205151306288.png">
<meta property="og:image" content="https://tao1st.github.io/assets/images/posts/algorithm-repeated-string-pattern/repeated-string-pattern-kmp-5-1.jpeg">
<meta property="og:image" content="https://tao1st.github.io/assets/images/posts/algorithm-repeated-string-pattern/repeated-string-pattern-kmp-5-2.jpeg">
<meta property="og:image" content="https://tao1st.github.io/assets/images/posts/algorithm-repeated-string-pattern/repeated-string-pattern-kmp-5-3.jpeg">
<meta property="og:image" content="https://tao1st.github.io/assets/images/posts/algorithm-repeated-string-pattern/repeated-string-pattern-kmp-5-4.jpeg">
<meta property="og:image" content="https://tao1st.github.io/assets/images/posts/algorithm-repeated-string-pattern/repeated-string-pattern-kmp-5-5.jpeg">
<meta property="og:image" content="https://tao1st.github.io/assets/images/posts/algorithm-repeated-string-pattern/repeated-string-pattern-kmp-5-6.jpeg">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205151307596.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205151307241.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205151307726.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205151307501.png">
<meta property="og:image" content="https://tao1st.github.io/assets/images/posts/algorithm-repeated-string-pattern/repeated-string-pattern-kmp-7-3.jpeg">
<meta property="og:image" content="https://tao1st.github.io/assets/images/posts/algorithm-repeated-string-pattern/repeated-string-pattern-kmp-7-4.jpeg">
<meta property="article:published_time" content="2019-05-26T10:02:57.000Z">
<meta property="article:modified_time" content="2022-08-30T14:01:07.603Z">
<meta property="article:author" content="tao1st">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://raw.githubusercontent.com/TAO1st/pics@master/202205260000400.png">
  
  
  
  <title>leetcode - tao1st.github.io</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"tao1st.github.io","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":3},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>TAO1st</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/bk7.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.5)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="leetcode"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2019-05-26 18:02" pubdate>
          2019年5月26日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          55k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          456 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">leetcode</h1>
            
            
              <div class="markdown-body">
                
                <h1>贪心 Greedy</h1>
<blockquote>
<p>局部最优解能够导向全局最优解。</p>
<p>贪心的重点往往在于，看出这道题是贪心问题。</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>455 Assign Cookies 分发饼干 (Easy)</p>
<p>非常典型的贪心问题，需要先进行排序（根据数据规模判断可以接受<code>O(nlogn)</code>的时间复杂度。</p>
</li>
<li class="lvl-2">
<p>135 Candy 分发糖果 (Hard)</p>
<p>一个特殊的题意理解错误：当两个孩子相邻且评分一致时并不一定二者分到相同的糖果。题目只要求相邻二者中多的一定要更多。</p>
<p>非常典型的贪心问题：</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>常规解法：二次扫描，从左到右一次，从右到左一次，满足两个方向上的大小关系。第二次要注意已经满足条件的情况。由于使用了辅助数组来存放糖果数，空间复杂度为<code>O(n)</code>。</p>
</li>
<li class="lvl-4">
<p>优化解法：思路比较复杂，利用统计递增和递减序列长度来实现求解，具体见代码。无需辅助数组，能够将空间复杂度降低至O(1)。</p>
</li>
</ul>
</li>
<li class="lvl-2">
<p>605 Can Place Flowers 种花问题 (Easy)</p>
<p>没什么特别的，注意一些边界条件处理就行，简单题。</p>
</li>
<li class="lvl-2">
<p><strong>406 Queue Reconstruction by Height 根据身高重建队列 (Medium)</strong></p>
<p>不论从高到低还是从低到高，本题的本质在于按照<strong>优先级</strong>对元素进行排序。而对于优先级的定义来说，<strong>元素的特征不止一个，不同特征的排序方式可能会有所不同</strong>，这是一种很常见的处理方式。</p>
<p>比如本题存在两个特征，由于题目的条件是“大于等于”，所以两个特征的排序正好相反，应该一个增序、一个降序。</p>
</li>
<li class="lvl-2">
<p>665 Non-decreasing Array 非递减数列 (Medium)</p>
<p>至多只有一个不符合非递减规则的元素，分两种情况：要么有个过大的元素，需要对其缩小；要么有个过小的元素，需要对其放大。</p>
<p>一个使用的库函数是<code>is_sorted</code>，判断容器是否有序，参数为起始和终止的迭代器。</p>
</li>
<li class="lvl-2">
<p><strong>870 Advantage Shuffle 优势洗牌 (Medium)</strong></p>
<p>在模拟的过程中能够发现是一个贪心问题：针对B的每个元素b，寻找A中最小的a使其满足 a&gt;b 。比较明显的贪心思想。类似于田忌赛马，本题具体解法如下：</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>解法一：贪心 + 哈希</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">sort</span>(nums1);			<span class="hljs-comment">// 首先对两个数组进行排序</span><br><span class="hljs-built_in">sort</span>(nums2);<br><span class="hljs-keyword">while</span>(nums1中还有元素) &#123;<br>	<span class="hljs-keyword">if</span>(nums1[ptr1] &gt; nums2[ptr2]) &#123;<br>		结果填入答案；<br>		ptr1++;  ptr2++;<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		将nums1的值送入remaining;<br>		ptr1++;<br>	&#125;<br>&#125;<br><span class="hljs-keyword">while</span>(nums2中有未被满足的元素) &#123;<br>	根据remaining中剩余元素进行填充；<br>&#125;<br></code></pre></td></tr></table></figure>
<p>值得注意的点：</p>
<ol>
<li class="lvl-9">
<p>因为两个数组都要排序后解答，所以要利用哈希表来记录答案；</p>
</li>
<li class="lvl-9">
<p>由于第二个数组中有可能出现重复元素，哈希表要记录下标到答案的映射，而非元素值到答案的映射；</p>
</li>
<li class="lvl-9">
<p>书写sort中<code>cmp</code>函数的注意要点，详见STL.md中的内容；</p>
</li>
<li class="lvl-9">
<p>题目的解法就是挺麻烦的，有时候要优先给出解法，先不要考虑代码的优雅程度；</p>
</li>
</ol>
</li>
<li class="lvl-4">
<p>解法二：贪心 + 二分，使用multiset</p>
<p>也是一个很直观的想法，对$nums1$进行排序，并对$nums2$中的每个元素在$nums1$中进行二分查找最近的下一个更大值。</p>
</li>
</ul>
</li>
</ul>
<h2 id="贪心中的区间问题">贪心中的区间问题</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>435 Non-overlapping Intervals 无重叠区间 (Medium)</p>
<p>贪心思想：按照区间右端点排序，每次选择都保证剩余空间更大，然后一次从左到右扫描判断即可。</p>
<p>时间复杂度为<code>O(nlogn)</code>，因为要先根据右端点大小进行排序。</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>另外的解法还有动态规划，但时间复杂度更差，达到平方级且会TLE。</p>
</li>
</ul>
</li>
<li class="lvl-2">
<p>452 Minimum Number of Arrows to Burst Balloons 用最少数量的箭引爆气球 (Medium)</p>
<p>和435一样，都是区间问题上的贪心。</p>
</li>
<li class="lvl-2">
<p>763 Partition Labels 划分字母区间 (Medium)</p>
<p>实质还是一个区间问题，重点关注将字母转化为区间尽可能简洁的技巧。实际本题只需要记录最右侧最远点，不需                                                       要记录区间左端点。</p>
</li>
<li class="lvl-2">
<p>122 Best Time to Buy and Sell Stock II 买卖股票的最佳时机 (Medium)</p>
<p>重点在于发现这是贪心题目，非常直白的解法。</p>
</li>
</ul>
<h1>二分查找 Binary Search</h1>
<blockquote>
<p><strong>有序</strong>的<strong>线性序列</strong>中的<strong>查找</strong>应该立马想到使用<em>二分</em>对其进行优化。</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>查找的目标并不唯一，可能查询某个特定值的位置，也可能有多个相同目标值，要查询上下界，即实现<code>upper_bound</code>和<code>lower_bound</code>。</p>
<p>同时，如果某些题目中出现需要二分查找的时候，可以<em>使用<code>lower_bound</code>函数</em>！</p>
</li>
<li class="lvl-2">
<p>二分的魔鬼在于细节。要反复重复以加强对细节和其实现的理解。</p>
</li>
</ul>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>69 Sqrt(x) x的平方根 (Easy)</strong></p>
<p>就是要找到平方小于x的最大数。</p>
<p>线性肯定弱智，想到用二分将时间优化到<code>O(logn)</code>。</p>
<p>要理解二分为什么能找到符合条件的最大数。</p>
</li>
<li class="lvl-2">
<p>34 Find First and Last Position of Element in Sorted Array 在排序数组中查找元素的第一个和最后一个位置 (Medium)</p>
<p>思路：</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>首先想到二分查找目标值，随后在命中位置向左右扩展，从而得到结果的区间；</p>
<p>这种思路好实现，问题在于所有元素都为目标值时很明显会退化为线性，即向左右扩展的过程为线性复杂度。</p>
</li>
<li class="lvl-4">
<p>第二种思路：本质上就是实现<code>upper_bound</code>和<code>lower_bound</code>函数。常规的二分查找问题，分别实现即可。</p>
</li>
</ul>
<p>要自己想一下测试用例可能的临界情况。</p>
<p>输入的几种临界情况：</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>未命中；</p>
</li>
<li class="lvl-4">
<p>目标值为最小值 / 最大值，即在数组的最左侧 / 最右侧；</p>
</li>
<li class="lvl-4">
<p>整个数组所有元素均为目标值。</p>
</li>
</ul>
</li>
<li class="lvl-2">
<p>540 Single Element in a Sorted Array 有序数组中的单一元素 (Medium)</p>
<p>有序数组要实现对数时间复杂度必然要二分：通过两侧元素的<strong>奇偶数量</strong>来确定单一元素处在哪个区间。</p>
<p>一个有趣的简化做法是只对<strong>偶数索引</strong>进行查找。</p>
</li>
<li class="lvl-2">
<p><em>4 Median of Two Sorted Arrays 寻找两个有序数组的中位数 (Hard)</em></p>
<ol>
<li class="lvl-5">
<p>思路</p>
<ul class="lvl-4">
<li class="lvl-7">首先，将两个数组归并是一定无法在要求时间复杂度$O(logn(m+n))$内的时间完成的。两个数组均有序，更直观的方法是维护两个指针，寻找到中位数的位置；</li>
<li class="lvl-7">普通扫描寻找位置会使时间复杂度达到线性，对有序序列搜索降低复杂度第一反应必然是二分，重点在于如何对两个数组同时进行二分，实质是如何一次排除掉多个元素；</li>
<li class="lvl-7">二分的一个核心思想在于每次排除掉不止一个元素。根据中位数的定义，实际上题目就是在寻找两个有序数组之间第 $k$ 小的数。其中 $k$ 为 $(m+n)/2$ 或 $(m+n)/2+1$ ；</li>
</ul>
</li>
<li class="lvl-5">
<p>实现</p>
<p>目标为找到第$k$个元素，且数组为从小到大排列，那么我们希望每次能够排除掉该第 $k$ 位元素前面的元素。比较 $A[k/2-1]$ 和 $B[k/2-1]$ ，二者之间的较小值前面至多有 $(k/2-1)+(k/2-1)\leq k-2$ 个元素比它小，其必定不是第 $k$ 小的数。</p>
<p>分三种情况来讨论：</p>
<ul class="lvl-4">
<li class="lvl-7">
<p><code>A[k/2 - 1] &lt; B[k/2 - 1]</code>：对<code>A[k/2 - 1]</code>来说，比它更小的值至多有<code>A[0] - A[k/2 - 2]</code>与<code>B[0] - B[k/2 - 2]</code>这些，共$(k/2 - 1) + (k/2 - 1) \leq k - 2$ 个，所以<code>A[k/2 - 1]</code>必定不是第$k$小的值，可以排除<code>A[0] - A[k/2 - 1]</code>；</p>
</li>
<li class="lvl-7">
<p><code>A[k/2 - 1] &gt; B[k/2 - 1]</code>：同理可以排除<code>B[0] - B[k/2 - 1]</code>；</p>
</li>
<li class="lvl-7">
<p><code>A[k/2 - 1] == B[k/2 - 1]</code>：排除A或B中元素均可，此处规定纳入第一种情况处理，即排除A中元素。</p>
</li>
</ul>
<p>如此处理，每次都能排除掉$k/2$个值。</p>
</li>
<li class="lvl-5">
<p>边界条件与特殊情况</p>
<p>某个数组下标计算后可能越界，由此要注意两点：</p>
<ul class="lvl-4">
<li class="lvl-7">
<p>首先，更新指针时要注意越界，如果越界则移到该序列最后元素处即可；</p>
</li>
<li class="lvl-7">
<p>其次，每次更新减少$k$值时要根据排除数的个数，而不是直接减去 $k/2$；</p>
</li>
<li class="lvl-7">
<p>还要注意一个边界情况，即<code>k=1</code>时，直接返回两个序列首元素中的最小值。</p>
</li>
</ul>
</li>
</ol>
</li>
<li class="lvl-2">
<p><em>287 Find the Duplicate Number 寻找重复数 (Medium)</em></p>
<p>解法一：二分查找 + 抽屉原理</p>
<p>引入了一个数组来便于求解。</p>
<p>解法二：<a href="##%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88">快慢指针</a></p>
</li>
<li class="lvl-2">
<p>240 Search in a 2D Matrix II 搜索二维矩阵 II (Medium)</p>
<p>解法一：按行二分查找，降到$O(mlogn)$。</p>
<p>解法二：一次消去一行或者一列。见[数组 - 矩阵](##数组 Array)部分。</p>
</li>
<li class="lvl-2">
<p><strong>1044 Longest Duplicate Substring 最长重复子串 (Hard)</strong></p>
<p>二分 + 滚动哈希，详见<a href="###%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D">字符串匹配</a>部分</p>
</li>
</ul>
<h2 id="旋转排序数组-Rotated-Sorted-Array">旋转排序数组 Rotated Sorted Array</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>33 Search in Rotated Sorted Array 搜索旋转排序数组 (Medium)</strong></p>
<p>对于旋转数组来说，每次二分必定有一侧有序，而另一侧可能无序可能有序（在后续的不断分割中可能有序）。分情况进行判定，注意细节即可。</p>
</li>
<li class="lvl-2">
<p><strong>81 Search in Rotated Sorted Array II 搜索旋转排序数组 II (Medium)</strong></p>
<p>跟33基本一致，只是多了一个特殊情况即<code>nums[lo] == nums[mid] == nums[hi]</code> 的情况，这种情况下无法判断哪一侧有序，处理办法是将边界缩小，即<code>i++; j--;</code>。</p>
<p>这意味着题目的最坏时间复杂度退化到了线性$$O(n)$$，所以用二分实际上等于脱裤子放屁。</p>
</li>
<li class="lvl-2">
<p>153 Find Minimum in Rotated Sorted Array 寻找旋转排序数组中的最小值 (Medium)</p>
<p>思路：排序数组肯定还是二分，但是每次二分要分两种情况：要么 <strong>左侧有序</strong>，要么 <strong>右侧有序</strong>。</p>
<p>判断是否有序可以跟<code>lo</code>比也可以跟<code>hi</code>比。与<code>hi</code>比比较简单好处理，与<code>lo</code>比较的话要处理整体有序的一个特例。</p>
</li>
<li class="lvl-2">
<p>154 Find Minimum in Rotated Sorted Array 寻找旋转排序数组中的最小值 II (Hard)</p>
<p>和153基本一致，多了一个<code>nums[mid] == nums[hi]</code>的特殊情况，无法判断最小值在哪一侧。</p>
</li>
</ul>
<h1>排序 Sort</h1>
<blockquote>
<p>代码实现见<code>leetcode\sort.cpp</code></p>
</blockquote>
<h2 id="复杂度与稳定性">复杂度与稳定性</h2>
<table>
<thead>
<tr>
<th style="text-align:center">排序方法</th>
<th style="text-align:center">平均时间复杂度</th>
<th style="text-align:center">最坏时间复杂度</th>
<th style="text-align:center">额外空间复杂度</th>
<th style="text-align:center">稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">简单选择排序</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center">冒泡排序</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">直接插入排序</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">希尔排序</td>
<td style="text-align:center">$O(n^d)$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center">基数排序</td>
<td style="text-align:center">$O(p(n+b))$</td>
<td style="text-align:center">$O(p(n+b))$</td>
<td style="text-align:center">$O(n+b)$</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center">堆排序</td>
<td style="text-align:center">$O(n log n)$</td>
<td style="text-align:center">$O(n log n)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center">快速排序</td>
<td style="text-align:center">$O(n log n)$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(log n)$</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">归并排序</td>
<td style="text-align:center">$O(n log n)$</td>
<td style="text-align:center">$O(n log n)$</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">稳定</td>
</tr>
</tbody>
</table>
<h2 id="快速排序-Quick-Sort">快速排序 Quick Sort</h2>
<blockquote>
<p>基于<strong>元素交换</strong>的排序。</p>
</blockquote>
<h4 id="基本思想">基本思想</h4>
<p>快速排序也是一个基于交换的分治算法，算法的基本思想：</p>
<ol>
<li class="lvl-3">
<p>选择主元，即每次选择一个元素作为分治基准<code>pivot</code>；</p>
<p><code>pivot</code>将所有元素分为两部分，每一轮要确定当前分治基准的最终位置，将比其小的元素移到左侧，比其大的元素移到右侧；</p>
</li>
<li class="lvl-3">
<p>子集分治（partition）：以<code>pivot</code>为基准将元素分割成了两部分，分别是<strong>更小的左半部分</strong>和<strong>更大的右半部分</strong>，分别向两边进行分治处理。</p>
</li>
</ol>
<h4 id="效率与特点">效率与特点</h4>
<p>效率的高低主要取决于分治基准的选取，通常默认采取第一个元素作为基准：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>最好情况：每次<code>pivot</code>都能正好将所有元素二分，时间复杂度为 $O(nlogn)$，空间上递归工作栈深度$O(logn)$；</p>
</li>
<li class="lvl-2">
<p>最坏情况：如果待排序列是个有序表，则每次都有一侧是个空表，时间复杂度上升至 $O(n^2)$，空间上递归工作栈深度 $O(n)$。</p>
</li>
</ul>
<p>快速排序有一些解题时用得到、值得注意的特点：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>待排序列<strong>越无序，效率越高</strong>；</p>
<p>可以对数组进行<strong>随机化打乱</strong>。根据算法导论中的证明，将数组打乱后，快排就能达到$O(n)$的期望时间复杂度！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> lo, <span class="hljs-type">int</span> hi)</span> </span>&#123;<br>    <span class="hljs-built_in">srand</span>(<span class="hljs-built_in">time</span>(<span class="hljs-number">0</span>));<br>    <span class="hljs-type">int</span> random = <span class="hljs-built_in">rand</span>() % (hi - lo + <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">swap</span>(nums[lo + random], nums[lo]);<br>    <br>    <span class="hljs-type">int</span> pivot = nums[lo];<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p><strong>每次都会有一个元素归位</strong>（215，TopK问题）</p>
<p>虽然快速排序在排序的中途不会产生任何有序子序列，但是每一次子集划分时，分治基准<code>pivot</code>都会被放在最终的正确位置。</p>
</li>
</ul>
<h4 id="相关题目-4">相关题目</h4>
<blockquote>
<p><em>TopK</em>类型题目常用于考察快速排序。</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>215 Kth Largest Element in an Array 数组中的第K个最大元素 (Medium)</strong></p>
<p>TopK问题，高频经典题目，必须熟练拿捏。啪的一下立马啊，就是一个带<strong>随机</strong>的<strong>快速排序</strong>。</p>
<p>思路：</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>数组中寻找第K个元素的话，很自然的想到使用快速排序，因为快速排序每次都能将主元放到其最终位置，所以每次分治循环时判定分治基准的索引是否为k即可（降序排序）。</p>
<p>在使用随机化进行优化后，期望时间复杂度达到线性。</p>
<p>实际上，在期望时间复杂度方面，快速排序在效率上基本是最优秀的，在没有其他特定条件下，可以优先选择使用快速排序。</p>
</li>
<li class="lvl-4">
<p>使用最大堆的思路也比较直接，但时间复杂度显然不如加入了随机优化的快速排序。</p>
</li>
</ul>
<p>解法总结：</p>
<ol>
<li class="lvl-5">
<p>最重要的<strong>快速排序</strong>，通过引入随机化达到 $O(n)$ 的平均时间复杂度。</p>
</li>
<li class="lvl-5">
<p><strong>大根堆</strong>：建堆消耗 $O(n)$，$k$次删除每次 $O(logn)$ 共 $O(klogn)$ 。总渐进复杂度为 $O(nlogn)$。</p>
</li>
</ol>
</li>
<li class="lvl-2">
<p><strong>347 Top K Frequent Element 前K个高频元素 (Medium)</strong></p>
<p>见[桶排序](####桶排序 Bucket Sort)</p>
</li>
<li class="lvl-2">
<p>75 Sort Colors 颜色分类 (Medium)</p>
<p>经典<strong>荷兰国旗问题</strong>。实质是快速排序的子集划分过程partition的改进：即通过一次扫描，把数组分为三个部分。</p>
<p>解法为双指针，详见[双指针部分](##双指针 Two pointers)。</p>
</li>
</ul>
<h2 id="堆-Heap">堆 Heap</h2>
<h4 id="STL">STL</h4>
<p>STL中的优先级队列<code>priority_queue&lt;datatype&gt;</code>即为堆的实现。</p>
<h4 id="手动实现">手动实现</h4>
<p>数据结构上采用<strong>顺序存储</strong>，用<strong>数组</strong>存放的<strong>完全二叉树</strong>，该种树具备一些特性使得其适合作为堆：数组的索引可以反映出节点之间的逻辑关系。</p>
<p>数组存放有两种不同处理方式：一是从<strong>下标1</strong>处开始存放，二是从<strong>下标0</strong>处开始存放。这样对应的节点逻辑关系有所区别。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>从1处开始存放：对于编号为 $i$ 的节点，其双亲为 $i/2$ ，其左右孩子分别为 $2i$、$2i+1$；</p>
</li>
<li class="lvl-2">
<p>从0处开始存放：对于编号为 $i$ 的节点，其双亲为 $i/2 - 1$ ，其左右孩子分别为 $2i + 1$、$2i+2$；</p>
</li>
</ul>
<p>具体代码见sort.cpp。</p>
<h4 id="相关题目-5">相关题目</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>215 Kth Largest Element in an Array 数组中的第K个最大元素 (Medium)</strong></p>
<p>见[快速排序](##快速排序 Quick Sort)。</p>
</li>
<li class="lvl-2">
<p><strong>347 Top K Frequent Element 前K个高频元素 (Medium)</strong></p>
<p>见[桶排序](####桶排序 Bucket Sort)</p>
</li>
</ul>
<h2 id="归并排序-Merge-Sort">归并排序 Merge Sort</h2>
<p><img src="https://raw.githubusercontent.com/TAO1st/pics@master/202205260000400.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h2 id="分布式排序-Distribution-Sort">分布式排序 Distribution Sort</h2>
<h3 id="桶排序-Bucket-Sort">桶排序 Bucket Sort</h3>
<p>根据元素属性的值（可能是出现次数、也可能是其他属性）来进行排序。</p>
<p>为每个可能取到的值建一个桶。用空间换时间，达到<strong>线性时间复杂度</strong>。</p>
<img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202203151641820.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>347 Top K Frequent Element 前K个高频元素 (Medium)</strong></p>
<p>题目实际上要使用<strong>哈希表</strong>统计每个元素出现的次数，然后对该次数表进行实际的排序。</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>解法一：使用哈希表加<strong>桶排序</strong>，空间换时间；</p>
<p>时间复杂度为线性，三个操作：哈希表统计出现次数、根据哈希表建桶、根据桶得到答案。三个操作时间复杂度均为线性。</p>
</li>
<li class="lvl-4">
<p>解法二：堆</p>
</li>
<li class="lvl-4">
<p>解法三：快速排序</p>
<p>使用哈希表统计时间，再把哈希表的内容放到一个数组中，再对数组进行TopK排序统计。</p>
</li>
</ul>
</li>
<li class="lvl-2">
<p>451 Sort Character By Frequency 根据字符出现频率排序 (Medium)</p>
<p>跟347换个皮，实质一样。</p>
<p>仍然可以用其他任何排序解法来做，但时间复杂度都会更高。</p>
</li>
</ul>
<h3 id="基数排序-Radix-Sort">基数排序 Radix Sort</h3>
<h2 id="Miscellaneous">Miscellaneous</h2>
<ul class="lvl-0">
<li class="lvl-2">
</li>
</ul>
<h3 id="选择排序-Selection-Sort">选择排序 Selection Sort</h3>
<h3 id="插入排序-Insertion-Sort">插入排序 Insertion Sort</h3>
<h3 id="冒泡排序-Bubble-Sort">冒泡排序 Bubble Sort</h3>
<h3 id="希尔排序-Shell-Sort">希尔排序 Shell Sort</h3>
<h3 id="STL中的排序">STL中的排序</h3>
<h1>搜索 Search</h1>
<blockquote>
<p>三种写法都要熟练：</p>
<ol>
<li class="lvl-3">DFS递归</li>
<li class="lvl-3">DFS栈</li>
<li class="lvl-3">BFS队列</li>
</ol>
</blockquote>
<h2 id="DFS-与-BFS">DFS 与 BFS</h2>
<h3 id="DFS">DFS</h3>
<p><strong>实现方式</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>递归实现</p>
</li>
<li class="lvl-2">
<p>栈实现：与递归等价，但递归容易出现递归栈满情况，所以栈可能在工程中效果更好。</p>
</li>
</ul>
<p><strong>难点</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>剪枝：把可能剪枝的递归分叉放进判断语句中</p>
</li>
<li class="lvl-2">
<p>存放最优方案：在递归分叉前后增加语句</p>
</li>
<li class="lvl-2">
<p>递归边界的确定</p>
</li>
</ul>
<h3 id="BFS">BFS</h3>
<h4 id="层数记录-最短距离">层数记录 / 最短距离</h4>
<p>对节点建立结构体，并增加<strong>层数/深度</strong>成员，用以记录节点或集合之间的距离。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>934 Shortest Bridge 最短的桥 (Medium)</p>
<p>解法：首先使用任意搜索（这里使用DFS）来找到第一座岛，并在搜索过程中将该岛外沿的一圈海域存入队列。从这些队列中的节点开始进行BFS并记录层数。</p>
</li>
</ul>
<h4 id="双向BFS">双向BFS</h4>
<blockquote>
<img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202203211456914.png" srcset="/img/loading.gif" lazyload style="zoom:15%;" />
<p>从起点 BFS 直至终点，最终会形成一棵树，类似与层序遍历。<strong>对于无向图</strong>，从起点搜终点和从终点搜起点都会形成一颗树，形状可能会不一样。</p>
<p>**如果两个方向的BFS都是随着层数加深，当前层节点数越来越多的结构的话，**那么从起点和终点同时BFS，可以减少很多无效转移。这个方法可以带来多少提升跟两个方向的树的形状有关系。如果两个方向的树都是随着深度加深越来越宽的结构，并且深度比较深的话，可以有明显的加速。</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>126 单词接龙 II (Hard)</p>
</li>
<li class="lvl-2">
<p>127 单词接龙 (Hard)</p>
<p>太难了，不做</p>
</li>
</ul>
<h3 id="题目">题目</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>695 Max Area of Island 岛屿的最大面积 (Medium)</p>
<p>基本题，每种搜索方式都写一编增加熟练度。</p>
</li>
<li class="lvl-2">
<p>547 Number of Provinces 省份数量 (Medium)</p>
<p>基本题。</p>
</li>
<li class="lvl-2">
<p><em>417 Pacific Atlantic Water Flow 太平洋大西洋水流问题 (Medium)</em></p>
<p>最直观的想法是对每个点进行搜索，查看是否能达到边缘，这样时间复杂度会达到$O(n^3)$。</p>
<p>解法：<strong>从两边向内进行搜索</strong>。从上侧边和左侧边出发搜索得到能到达太平洋的节点；从右侧边和下侧边出发搜索得到能到达大西洋的节点。最后再统计两侧都能达到的节点即为答案所求。</p>
</li>
<li class="lvl-2">
<p>130 Surrounded Regions 被围绕的区域 (Medium)</p>
</li>
</ul>
<h2 id="回溯-Backtracking">回溯 Backtracking</h2>
<p>本质是<strong>状态还原</strong>。在深搜的基础上多了这个环节：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>深搜：修改当前状态  —  进入递归</p>
</li>
<li class="lvl-2">
<p>回溯：修改当前状态  —  进入递归  —  返回后还原状态（以便下一次的尝试）</p>
</li>
</ul>
<h3 id="排列">排列</h3>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>对于排列问题：不同顺序属于不同结果，即<code>[1,2,3]</code>与<code>[1,3,2]</code>为不同结果。</p>
<p>设置<strong>访问数组</strong>，回溯的内容即<strong>元素是否被使用过</strong>。</p>
</li>
<li class="lvl-2">
<p><em>去重</em>：</p>
<p>初始序列存在重复值的情况，即<code>[2',2,3]</code>与<code>[2,2'3]</code>为相同结果，重点关注此时的去重问题。</p>
<p><em>排序 + 访问数组</em>：对于排列问题，如果涉及到<strong>重复元素</strong>，立马想到先<strong>排序</strong>、使得相同元素全部相邻后再进行处理。</p>
</li>
</ul>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>46 Permutations 全排列 (Medium)</strong></p>
<p>排列：经典回溯试探题目。解法有几种小技巧：</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>解法一：记录节点访问状态；</p>
<p>回溯的内容是<strong>元素是否已经被用过</strong>。</p>
</li>
<li class="lvl-4">
<p>解法二：对节点进行交换；</p>
<p>回溯的内容是<strong>元素的交换</strong>，即<strong>将元素归位</strong>。</p>
</li>
<li class="lvl-4">
<p>解法三：使用库函数<code>prev_permutation</code>与<code>next_pertation</code></p>
<p>无需回溯。</p>
<blockquote>
<p><strong>注意！两个库函数二者缺一不可！</strong></p>
<p>值得注意的是使用<code>next_permutation</code>函数的一个错误点：达到字典序的最后一个序列就会返回false。本题的初始序列并未规定为字典序最小值，所以仅使用该函数无法获得全排列。</p>
</blockquote>
</li>
</ul>
</li>
<li class="lvl-2">
<p><strong>47 Permutation II 全排列 II (Medium)</strong></p>
<p>与46类似，但是会存在重复元素。</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>解法一：利用哈希表记录元素个数；</p>
<p>回溯的内容是<strong>哈希表中的内容</strong>，即<strong>当前元素剩余未使用的个数</strong>。本质上和记录元素是否使用过是一致的。</p>
</li>
<li class="lvl-4">
<p><em>解法二：排序 + 访问数组 实现去重；</em></p>
<blockquote>
<p><em>Tricks!</em></p>
<p>涉及<em>重复元素</em>的情况，立马想到先<em>排序</em>，使相同元素相邻再进行处理。</p>
</blockquote>
<p>在处理每一位是否放置当前元素的判断上，增加一个去重的判断：如果当前元素和上一个元素相同且上一个相同元素当前未被访问，则不放置当前元素在当前位。</p>
<p>每一轮处理都是从左到右，如果上一个相邻的相同元素是未访问状态，说明该位已经放置过与当前值相同的元素，且已经回溯其状态。</p>
</li>
</ul>
</li>
</ul>
<h3 id="组合">组合</h3>
<blockquote>
<p>对于组合问题：不关心顺序，不同顺序属于相同结果，即<code>[1,2,3]</code>与<code>[2,1,3]</code>为相同结果。</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>两种写法：</p>
<ol>
<li class="lvl-5">
<p>设置<strong>搜索起点</strong>，按顺序从左到右进行搜索：</p>
<p>比如在<code>[1,2,3]</code>中进行选两个数进行组合，已经处理完了<code>[1,2]</code>与<code>[1,3]</code>之后，处理2开头的序列时，通过将搜索开头设置为2，从而避免出现<code>[2,1]</code>的重复选项。</p>
</li>
<li class="lvl-5">
<p>回溯的内容为<strong>是否选用当前元素</strong>。选 或者不选，两条路进行递归。</p>
</li>
</ol>
<ul class="lvl-3">
<li class="lvl-4">
<p>去重：</p>
<p>初始序列有重复元素，就还是必须先<strong>排序</strong>，后去重。</p>
</li>
</ul>
</li>
<li class="lvl-2">
<p>需要注意<strong>剪枝</strong>，提升速度。</p>
</li>
</ul>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>77 Combinations 组合 (Medium)</strong></p>
<p>组合：另一种回溯，选择当前元素或不选择当前元素，即</p>
<p>“修改当前状态 — 进入递归（选择当前元素） — 返回并还原状态 — 进入另一条递归（不选择当前元素）”</p>
<p>回溯的内容是<strong>是否选择当前元素</strong>。</p>
<p>类似背包问题，区别在于会枚举所有的选择（没有条件限制）。</p>
<p>官方题解还有个进一步优化空间复杂度的做法，有空再说吧，没啥太大必要。</p>
</li>
<li class="lvl-2">
<p>39 Combination Sum 组合总和 (Medium)</p>
</li>
<li class="lvl-2">
<p>40 Combination Sum II 组合总和 II (Medium)</p>
</li>
</ul>
<h3 id="其他">其他</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>79 Word Search 单词搜索 (Medium)</p>
<p>回溯的内容是<strong>当前字符是否已访问</strong>。如果不回溯会导致从另一条路重新到达该元素时，会以为其仍为已访问元素。</p>
</li>
<li class="lvl-2">
<p>51 N-queens N皇后 (Hard)</p>
<p>其回溯的思想并不复杂，重点在于如何模拟棋盘，如何记录对角线的占用情况。</p>
<p>对角线占用的处理见图模拟，自己手写一下就能够理解并得到对应与坐标的关系：</p>
</li>
<li class="lvl-2">
<p>37 Sudoku Solver 解数独 (Hard)</p>
<p>有一些细节上的优化以后值得注意：</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>使用位运算或<code>bitset</code>来简化哈希表；</p>
</li>
<li class="lvl-4">
<p>先将只有唯一待选值的空缺处填上，这些位置无需回溯，然后再对剩下的进行回溯搜索。</p>
</li>
</ul>
</li>
</ul>
<h1>双指针 Two Pointers</h1>
<h2 id="从两端向中间移动的双指针">从两端向中间移动的双指针</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>167 Two Sum II - Input Array Is Sorted 两数之和 II - 输入有序数组 (Medium)</p>
</li>
<li class="lvl-2">
<p><em>633 Sum of Square Numbers 平方数之和 (Medium)</em></p>
<p>一道并不难，但一开始没想出解法而且很容易写错的题目，值得注意。</p>
<p>其本质实际上就是<strong>两数之和</strong>的变式。</p>
<p>注意两个大<code>int</code>相乘很容易溢出，用<code>long</code>来存储。</p>
</li>
<li class="lvl-2">
<p>680 Valid Palindrome II 验证回文字符串 II (Easy)</p>
<p>很有趣的一道题，因为多了一个删除动作，暴力解法使用常规回文判断会使时间复杂度上升到$$O(n^2)$$。</p>
<p>巧妙地利用两端双指针来解决问题。</p>
</li>
</ul>
<h2 id="分别指向两个序列的双指针">分别指向两个序列的双指针</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>88 Merge Sorted Array 合并两个有序数组 (Easy)</p>
<p>很有意思的一道题，题目很简单，就是最弱智的双指针，但是要注意空间复杂度也能优化到常数级，即按照<strong>从后往前</strong>的顺序排序。值得注意。</p>
</li>
<li class="lvl-2">
<p>524 Longest Word in Dictionary through Deleting 通过删除字母匹配到字典里最长单词 (Medium)</p>
</li>
</ul>
<h2 id="链表相关（待修改">链表相关（待修改</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>160 Intersection of Two Linked Lists 相交链表(Easy)</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>解法一：哈希表。空间复杂度更高。</p>
</li>
<li class="lvl-4">
<p>解法二：双指针</p>
<p>使用两个指针分别指向两个链表的头节点，以相同的速度前进，若到达链表结尾，则移动到另一条链表的头节点继续前进。按照这种前进方法，两个指针会在$a+b+c$次前进后同时到达相交节点。</p>
<blockquote>
<p>正确性证明</p>
<p>考虑两种情况，第一种情况是两个链表相交，第二种情况是两个链表不相交。</p>
<p><strong>情况一：两个链表相交</strong></p>
<p>链表 $headA$ 和 $headB$ 的长度分别是 $m$ 和 $n$。假设链表 $headA$ 的不相交部分有 $a$ 个节点，链表 $headB$ 的不相交部分有 $b$ 个节点，两个链表相交的部分有 $c$ 个节点，则有 $a+c=m$，$b+c=n$。</p>
<p>如果 $a=b$，则两个指针会同时到达两个链表相交的节点，此时返回相交的节点；</p>
<p>如果 $a \ne b$ ，则指针 $pA$ 会遍历完链表 $headA$，指针 $pB$ 会遍历完链表 $headB$，两个指针不会同时到达链表的尾节点，然后指针 $pA$ 移到链表 $headB$ 的头节点，指针 $pB$ 移到链表 $headA$ 的头节点，然后两个指针继续移动，在指针 $pA$ 移动了 $a+c+b$ 次、指针 $pB$ 移动了 $b+c+a$ 次之后，两个指针会同时到达两个链表相交的节点，该节点也是两个指针第一次同时指向的节点，此时返回相交的节点。</p>
<p><strong>情况二：两个链表不相交</strong></p>
<p>链表 $headA$ 和 $headB$ 的长度分别是 $m$ 和 $n$。考虑当 $m=n$ 和 $m \ne n$ 时，两个指针分别会如何移动：</p>
<p>如果 $m=n$，则两个指针会同时到达两个链表的尾节点，然后同时变成空值 $null$，此时返回 $null$；</p>
<p>如果 $m \ne n$，则由于两个链表没有公共节点，两个指针也不会同时到达两个链表的尾节点，因此两个指针都会遍历完两个链表，在指针 $pA$ 移动了 $m+n$ 次、指针 $pB$ 移动了 $n+m$  次之后，两个指针会同时变成空值 $null$，此时返回 $null$。</p>
</blockquote>
</li>
</ul>
</li>
<li class="lvl-2">
<p>19 Remove Nth Node From End of List (Medium)</p>
<p>快慢指针/严格意义上来说是<strong>先后指针</strong>。</p>
<p>先让一个指针先移动n次，然后两个指针以相同速度前进；当位于前方的指针到达链表尾时，位于后方的指针即定位到倒数第n个节点。</p>
</li>
</ul>
<h2 id="快慢指针">快慢指针</h2>
<blockquote>
<p>快慢指针的使用场景：</p>
<ol>
<li class="lvl-3">
<p>链表中<strong>环路</strong>相关的问题。如<strong>判断链表内是否有环路（141）</strong>、<strong>找到链表内环路的入口（142）</strong></p>
</li>
<li class="lvl-3">
<p><strong>定位链表中某个特定位置</strong>。如寻找<strong>中点（234）</strong>、<strong>倒数第n个节点（19）<u>准确的说是 先后指针</u></strong>。</p>
<p>链表作为单向且无法随机存取的结构，想要在一次扫描中定位到某一特定位置往往需要借助双指针。</p>
</li>
</ol>
<p>思路（此处介绍的为常规思路，即跟<strong>环路入口</strong>相关的问题思路）：</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>快指针每次走两步，慢指针每次走一步，直至二者第一次相遇停止；</p>
</li>
<li class="lvl-2">
<p>慢指针重新移到起点；</p>
</li>
<li class="lvl-2">
<p>快慢指针都每次走一步，直至第二次相遇即为环路入口。</p>
</li>
</ul>
<p>写法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// fast = 0, slow = 0;</span><br><span class="hljs-comment">// fast和slow初始值均为0，所以使用do...while结构</span><br><span class="hljs-keyword">do</span> &#123;<br>    fast = fast-&gt;next-&gt;next;<br>    slow = slow-&gt;next;<br>&#125; <span class="hljs-keyword">while</span>(fast != slow);<br><br>slow = head;<br><br><span class="hljs-keyword">while</span>(fast != slow) &#123;<br>    fast = fast-&gt;next;<br>    slow = slow-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>141 Linked List Cycle 环形链表 (Easy)</p>
<p>判断链表内是否有环路：fast指针是否会为空</p>
</li>
<li class="lvl-2">
<p>142 Linked List Cycle II 环形链表II (Medium)</p>
<p>找出链表内环路的入口点：</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>快指针一次走两步，慢指针一次走一步；</p>
</li>
<li class="lvl-4">
<p>二者第一次相遇时，慢指针回到链表头，快指针与慢指针都一次走一步，直至第二次相遇即为所求点。</p>
</li>
</ul>
<p>数学推断不难，自己推推不行网上看一下。</p>
</li>
<li class="lvl-2">
<p><em>287 Find the Duplicate Number 寻找重复数 (Medium)</em></p>
<blockquote>
<p>套路题，思路并不明确，需要背一背。</p>
</blockquote>
<ul class="lvl-2">
<li class="lvl-4">
<p>解法一：快慢指针，重复的数字就相当于构成链表的环路</p>
<p>并非常规的快慢指针，很难看出，重点在于<strong>如何将数组转换为链表/图</strong>。转换之后其实就是常规的环形链表问题，建图的方式为：$i$ 指向 $nums[i]$，由于有一个 $nums[i]$ 的值出现了两次，所以其入度必然为2，即环形链表的入口处。此时使用快慢指针即可轻易解决。</p>
</li>
<li class="lvl-4">
<p>解法二：<a href="##%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE">二分查找 + 抽屉原理</a></p>
<p>要根据抽屉原理来构建一个新数组，并根据新数组的特性进行二分查找从而得到答案。</p>
<p>比较套路的一个题，不用过多了解该解法。</p>
</li>
</ul>
</li>
<li class="lvl-2">
<p>234 Palindrome Linked List 回文链表 (Easy)</p>
<p>使用快慢指针来<strong>寻找链表的中点（奇数情况下中间数纳入第一段且不考虑）</strong>：快指针步长为2，慢指针步长为1，即快指针速度为慢指针的两倍，则快指针到达链表尾时，慢指针（的下一个）位置即为中点。实际实现中要注意细节。</p>
</li>
</ul>
<h2 id="滑动窗口">滑动窗口</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>76 Minimum Window Substring 最小覆盖子串 (Hard)</p>
<p>思路并不复杂，比较明显的滑动窗口+哈希表，但是一定要注意实现细节，在细节上出了一些错误的时候要保持清醒，进行模拟查看错误的逻辑到底在哪个位置！</p>
</li>
<li class="lvl-2">
<p><strong>594 Longest Harmonious Subsequence 最长和谐子序列 (Easy)</strong></p>
<p>解法一：枚举 + 滑动窗口</p>
</li>
<li class="lvl-2">
<p>3 Longest Substring Without Repeating Characters 无重复字符的最长子串 (Medium)</p>
<p>显然，滑动窗口 加 哈希表。</p>
</li>
</ul>
<h2 id="Misc">Misc.</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>75 Sort Colors 颜色分类 (Medium)</p>
<p>经典<strong>荷兰国旗问题</strong>。实质是快速排序的子集划分过程partition的改进：即通过一次扫描，把数组分为三个部分。</p>
<p>解法为双指针:</p>
<ul class="lvl-2">
<li class="lvl-4">
<p><code>p0</code>为指向0的位置的指针，<code>p1</code>为指向1的位置的指针；</p>
<p>要注意的是当<code>p0 &lt; p1</code>时，意味着<code>p0</code>所处位置是一个已经排列好的1，此时使用其交换0必定会将该位置的1移到后面，所以要再重新把这个1移到<code>p1</code>的位置。</p>
</li>
<li class="lvl-4">
<p><code>p0</code>是指向0的位置的指针，<code>p2</code>为指向2的位置的指针；</p>
<p>要注意的是，每次向后交换2的时候，<code>p2</code>指向的位置可能本来也是一个2，所以要持续进行交换，直至当前指针指向的不是2为止。</p>
</li>
</ul>
</li>
</ul>
<h1>数据结构 Data Structure</h1>
<h2 id="数组-Array">数组 Array</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>448 Find All Numbers Disappeared in an Array 找到所有数组中消失的数字 (Easy)</p>
<p>见[哈希表](##哈希表 Hash)部分。</p>
</li>
<li class="lvl-2">
<p>769 Max Chunks To Make Sorted 最多能完成排序的块 (Medium)</p>
<p>见[单调栈](###单调栈 Monotone Stack)部分</p>
</li>
</ul>
<h3 id="矩阵">矩阵</h3>
<blockquote>
<p>即二维数组。</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>48 Rotate Image 旋转图像 (Medium)</p>
<p>纯矩阵坐标转换数学题。</p>
<p>解法一：</p>
<ol>
<li class="lvl-5">
<p>坐标转换公式：规律为第一行 变 倒数第一列，第二行 变 倒数第二列，依次类推。即从原坐标$(x,y)$到新坐标$(x’,y’)$的变换公式为：</p>
<p>$$<br>
x’ = y \ y’ = n - 1 -x<br>
$$<br>
每次进行四次翻转，根据上述坐标翻转公式计算新的位置坐标：</p>
<img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202204061409369.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />
$$
\left\{ \begin{array}{ll}
temp&= &matrix[y][n - 1 - x] \\
matrix[y][n-1-x] &= &matrix[x][y] \\
matrix[x][y] &= &matrix[n - 1 - y][x] \\
matrix[n - 1 - y][x] &= &matrix[n - 1 - x][n - 1 -y]\\
matrix[n - 1-x][n - 1 -y] &= &matrix[y][n - 1 - x]
\end{array}\right.
$$
四个值为一组组成一次循环，用一个中间变量来防止覆盖即可，从环路的哪一处开始结果都是一样的。
</li>
<li class="lvl-5">
<p>确定翻转的范围，分为 $n$ 为奇数和 $n$ 为偶数两种情况。</p>
<img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202204061102316.png" srcset="/img/loading.gif" lazyload style="zoom: 25%;" />
<img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202204061102867.png" srcset="/img/loading.gif" lazyload style="zoom:25%;" />
</li>
</ol>
<p>解法二：先水平翻转，再按照对角线翻转，即可得结果。</p>
</li>
<li class="lvl-2">
<p>240 Search in a Matrix II 搜索二维矩阵 II (Medium)</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>解法一：逐行搜索，对列进行二分。</p>
<p>二分可以直接使用库函数<code>lower_bound(v.begin(), v.end(), target)</code>，也可以手写二分。</p>
<p>复杂度从$O(mn)$降至$O(mlogn)$。</p>
</li>
<li class="lvl-4">
<p>解法二：利用矩阵的特性，从<strong>右上</strong>开始搜索。即当前元素的右侧以及上侧的元素均为扫描过的元素。</p>
<ul class="lvl-4">
<li class="lvl-6">
<p>如果当前元素比目标元素小，则当前行可以排除，因为当前行前面（左侧）的元素都只会更小；</p>
</li>
<li class="lvl-6">
<p>如果当前元素比目标元素大，则当前列可以排除，因为当前列下面（下侧）的元素都只会更大；</p>
</li>
</ul>
<p>根据该大小关系特性，一次可以消去一行的数据，复杂度进一步降至线性 $O(m+n)$。</p>
</li>
</ul>
</li>
<li class="lvl-2">
<p>566 Reshape the Matrix 重塑矩阵 (Easy)</p>
<p>普通的二维数组模拟题，一个可以使用的小技巧是 $flatten$ 操作，即将二维数组的坐标映射到一个一维数组上。</p>
</li>
</ul>
<h2 id="链表-Linked-List">链表 Linked List</h2>
<h3 id="基本操作">基本操作</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>83 Remove Duplicates from Sorted List 删除排序链表中的重复元素 (Easy)</p>
<p>实际场景中可能需要回收/释放内存（<code>delete</code>）</p>
</li>
<li class="lvl-2">
<p>328 Odd Even Linked List 奇偶链表 (Medium) 将原链表重新排序为奇序号在前偶序号在后</p>
<p>自己是通过模拟原地解决的，题目是将原链表分为奇偶两条链表解决的，大差不差的解法。</p>
<p>这种题的关键在于模拟，不能断链，考虑到底需要几个辅助指针来实现。</p>
</li>
</ul>
<h4 id="翻转链表">翻转链表</h4>
<blockquote>
<p>写法常分为<strong>递归/迭代</strong>与<strong>非递归</strong>两种。其中迭代写法常用三个指针来完成翻转操作（防止链表断掉）。</p>
<p>思路不清晰的时候手动模拟一下即可。</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>206 Reverse Linked List 反转链表 (Easy)</p>
<p>使用<strong>三个指针</strong><code>prev</code>，<code>head</code>， <code>next</code>进行翻转，写法分为<strong>递归</strong>与<strong>非递归</strong>两种。</p>
</li>
<li class="lvl-2">
<p>24 Swap Nodes in Pairs 两两交换链表中的节点 (Medium)</p>
<p>使用三个指针，写法分为递归与非递归两种。</p>
</li>
<li class="lvl-2">
<p>234 Palindrome Linked List 回文链表 (Easy)</p>
<p>给出一个链表，判断其内容是否回文。要求<strong>原地实现</strong>，即空间复杂度为<code>O(1)</code>。</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>解法一：第一反应一定是将链表中的内容放入一个数组（可随机存取的列表），再进行回文判断，这样必然需要<code>O(n)</code>的额外辅助空间。</p>
</li>
<li class="lvl-4">
<p>解法二：想要原地实现判断，仅依靠链表这种单向数据结构是不行的，所以必须要<strong>改变输入</strong>。</p>
<ul class="lvl-4">
<li class="lvl-6">
<p>第一步：通过<strong>快慢指针</strong>将链表等分成两段，并将第二段链表进行翻转。</p>
<p>值得注意的是，在实际使用场景中往往不希望修改我们的输入结构，所以要按需将后半段再次翻转恢复成原样。</p>
<p>同时，由于执行过程中要修改输入链表的结构，<strong>在并发场景下要对链表加锁</strong>，否则其他线程或进程对链表的访问有可能得到错误的结果。</p>
</li>
<li class="lvl-6">
<p>第二部：对两端链表的值依次进行比较，如果完全相等则为回文。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="合并有序链表">合并有序链表</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>21 Merge Two Sorted Lists 合并两个有序链表 (Easy)</p>
</li>
</ul>
<h4 id="链表排序">链表排序</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><em>148 Sort List 排序链表 (Medium)</em></p>
<p>要求在**<code>O(nlogn)</code>的时间复杂度<strong>和</strong>常数级空间复杂度**下实现。</p>
<p>后续补充，这题具体实现细节比较复杂，思路还需要理一理。</p>
</li>
</ul>
<h3 id="双指针">双指针</h3>
<p>双指针能够解决链表中的环路等一系列问题。详见[双指针部分](#双指针 Two Pointers)。</p>
<h2 id="栈-Stack">栈 Stack</h2>
<h3 id="Basic">Basic</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>232 Implement Queue Using Stacks (Easy)</p>
<p>用两个栈实现普通队列，要注意操作的均摊时间复杂度需要降至$O(1)$。</p>
</li>
<li class="lvl-2">
<p>225 用队列实现栈 Implement Stack Using Queues (Easy)</p>
<p>队列是先进先出，而栈是先进后出。二者正好相反，所以每次插入新元素时，将队列内所有元素进行<strong>倒转</strong>即可。完全可以只用一个栈来实现操作。</p>
</li>
<li class="lvl-2">
<p><strong>155 最小栈 Min Stack (Easy)</strong></p>
<ul class="lvl-2">
<li class="lvl-4">
<p>注意题意的理解，<strong>最小栈</strong>并不是<strong>最小堆</strong>。</p>
</li>
<li class="lvl-4">
<p>最小栈只要求在常数时间内返回最小元素，而栈中实际的元素排列并不变化，所以只要<strong>维护一个最小元素的值</strong>即可。</p>
</li>
<li class="lvl-4">
<p>关键在于，出栈时对最小元素的更新。解决办法是：</p>
<p>对每一个元素，都记录以其为栈顶时的栈中的最小元素值，具体实现及优化如下：</p>
<ol>
<li class="lvl-7">
<p>辅助栈，每次插入新元素时都向最小栈中输入当前栈中最小值，出栈时也同时出栈；</p>
</li>
<li class="lvl-7">
<p>辅助栈空间优化，每次仅当当前元素 小于等于 最小栈栈顶元素时才将其插入最小栈。但这样出栈时要多做一次判断，仅当当前弹出元素与最小栈栈顶元素相等时才会弹出最小栈的元素；</p>
</li>
<li class="lvl-7">
<p>使用<code>pair</code>，无需辅助栈，但其实思路与空间和辅助栈是一致的。</p>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="匹配">匹配</h3>
<blockquote>
<p>如括号匹配、逆波兰表达式等应用 Easy</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-4">
<p>20 Valid Parentheses (Easy)</p>
<p>一些小的优化点：</p>
<ol>
<li class="lvl-7">
<p>当字符数量为奇数时，必定失配；</p>
</li>
<li class="lvl-7">
<p>当需要判断是否匹配的字符较多时，可以引入<strong>哈希表</strong>来辅助判断。</p>
<p>本题中可以将左括号作为键，右括号作为值，从而简化代码量且更加清晰易懂。</p>
</li>
</ol>
</li>
</ul>
<h3 id="表达式求值">表达式求值</h3>
<blockquote>
<p>分为两种情况解决：</p>
<ul class="lvl-1">
<li class="lvl-2">当表达式中没有括号时（只有简单的加减乘除），可以直接使用中缀表达式也能计算出结果；</li>
<li class="lvl-2">当表达式中存在括号时，需要转为逆波兰表达式（后缀表达式）来进行计算。</li>
</ul>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>227 Basic Calculator II 基本计算器 II  (Medium)</strong></p>
<ul class="lvl-2">
<li class="lvl-4">
<p>简单的加减乘除，直接利用中缀表达式即可计算出结果；</p>
<p>将表达式按照<code>&lt;运算符， 操作数&gt;</code>进行分组划分处理，每个操作数根据其前的运算符来判断应该执行的运算。</p>
</li>
<li class="lvl-4">
<p>由于题目给出的表达式是字符串<code>string</code>形式，有很多细节需要注意处理：</p>
<ul class="lvl-4">
<li class="lvl-6">大于10的数的处理；</li>
<li class="lvl-6">各个位置的空格处理；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="单调栈-Monotone-Stack">单调栈 Monotone Stack</h2>
<blockquote>
<p>单调栈的定义与特点非常简单，即栈内元素呈递增/递减的趋势。以从底到顶递减为例，当元素入栈时：</p>
<ul class="lvl-1">
<li class="lvl-2">若当前插入元素小于栈顶元素，则直接入栈；</li>
<li class="lvl-2">若当前插入元素大于栈顶元素，则将栈顶元素弹出，直至 栈顶元素大于待插入元素 或 栈空 为止，然后再进行入栈操作。</li>
</ul>
<p>单调栈通常用于解决【在<strong>线性时间复杂度</strong>内寻找<strong>相邻的下一个最大/最小元素</strong>】问题。</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>739 每日温度 Daily Temperatures (Medium)</p>
<p>很直白的，寻找数组中下一个更大的元素$<sup>{[1]}$，并求解其和本身的下标差$</sup>{[2]}$。</p>
<ol>
<li class="lvl-5">
<p>寻找相邻的下一个元素：显然使用单调栈可以将整体复杂度降至线性；</p>
</li>
<li class="lvl-5">
<p>因为题目要求解是天数的差距，实际也就是下标的差距，所以这里要注意栈中存放的应该是下标即日期。这样才方便统计结果；</p>
</li>
<li class="lvl-5">
<p>单调栈中最后剩下的元素说明不存在下一个更大的元素，按照题意结果应该置0，所以在开结果数组时，默认所有值均为0。</p>
</li>
</ol>
</li>
<li class="lvl-2">
<p><em>42 Trapping Rain Water 接雨水 (Hard)</em></p>
<p>题解见 [动态规划](#动态规划 Dynamic Programming) 部分。</p>
</li>
<li class="lvl-2">
<p><em>84 Largest Rectangle in Histogram 柱状图中最大的矩形 (Hard)</em></p>
<p>首先思考朴素算法，对【高度】进行枚举。即以每个柱子的为中心向两侧探测，直至遇到比其更矮的柱子为止。此时可得到该位置上<strong>以该柱子高度为高</strong>的最大矩形面积。最后对每个位置取最大值即可。</p>
<p>仔细分析，本质是对两侧探测，直至找到相邻更矮的柱子。即<strong>寻找下一个相邻的较小元素</strong>。明显应该使用单调栈。此时需要进行【两次扫描】，每个方向扫描一次从而获得每个点的左侧边界与右侧边界。</p>
<p>优化：实际上在从左向右扫描求解右侧边界时，每次插入元素时，说明当前栈顶元素是更小的，即其实左侧边界（要先检查栈是否为空）。所以只需要【一次扫描】即可完成左右两侧的边界求解。</p>
</li>
<li class="lvl-2">
<p><em>85 Maximum Rectangle 最大矩形 (Hard)</em></p>
<p>本质和84一样，但是要记住这个解法（比较巧）。实际上就是对每一行进行一个84题的单调栈处理，如图所示。</p>
<img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202204211941410.png" srcset="/img/loading.gif" lazyload style="zoom: 25%;" />
</li>
<li class="lvl-2">
<p><em>316 Remove Duplicate Letters 去除重复字母 (Medium)</em></p>
<p>题目中的要求：去除重复字母，保证返回的字典序最小，且不能打乱字符的相对位置。</p>
<ol>
<li class="lvl-5">
<p>保证返回字典序最小</p>
<p>首先理解字典序排序的定义：从前往后比，只要有一位小，就说明该字符串更小，与后面的无关。</p>
<p>然后思考问题：从一个字符串中删除一个字符，如何保证结果字符串字典序最小。</p>
<p>因为字典序是对最靠前不同的字符作比较，所以一定是从前往后考虑。所以我们<strong>找到最靠前的下标满足$s[i] &gt; s[i + 1]$，并将$s[i]$ 删除</strong>，即可得到结果。即将最早的能替换成更小字符的位置去掉。</p>
</li>
<li class="lvl-5">
<p>去重，且保证相对位置</p>
<p>因为要保证相对位置，所以去重也要按照单向扫描（从前往后或从后往前）的方式考虑。</p>
<ul class="lvl-4">
<li class="lvl-7">
<p>为保证字典序最小，按照上面讨论过的方式进行删除，但删除的同时要确保后面还有该字符，方便检测这里需要开一个哈希表来统计每个字符出现的次数；</p>
</li>
<li class="lvl-8">
<p>同时，已经确定位置进栈的元素不用继续考虑，所以维护一个入栈集合。因为进栈的元素后面仍然可能出栈，所以当弹栈时要注意也从集合中删除该元素。</p>
</li>
</ul>
</li>
</ol>
<p>至此，问题就转换成了【从前往后考虑每个字母 $\alpha$，如果<strong>其后有比其更小的字母</strong>，且后面仍然有更多的 $\alpha$，则将 $\alpha$ 删除】。后面是否存在的问题已经通过哈希表统计得到解决，但如果对每个位置都向后探测寻找更小的字母，时间复杂度会来到$O(n^{2})$。显然针对<strong>寻找下一个更小元素</strong>的问题，应该使用<strong>单调栈</strong>对其进行优化。</p>
</li>
<li class="lvl-2">
<p>402 Remove K Digits 移掉K位数字 (Medium)</p>
<p>和316基本一致，简化版。字典序和最小整数其实是一样的策略。</p>
<p>唯一要注意的是，当所有数字是按照从小到大顺序排列时，不会有弹栈操作。所以循环结束后要检查是否已经弹出K个数字，如果没有要从尾部弹栈补齐。</p>
</li>
<li class="lvl-2">
<p>496 Next Greater Element I 下一个更大元素 I (Easy)</p>
<p>在两个不同的数组中寻找下一个更大元素。</p>
</li>
<li class="lvl-2">
<p>503 Next Greater Element II 下一个更大元素 II (Medium)</p>
<p>一个数组中寻找下一个更大元素，但是可以进行循环查找。</p>
<p>简单的处理方式是，从头到尾循环两次即可。或者直接通过模运算将循环两次的数组“拉直”。</p>
</li>
<li class="lvl-2">
<p>769 Max Chunks To Make Sorted 最多能完成排序的块 (Medium)</p>
</li>
<li class="lvl-2">
<p>768 Max Chunks To Make Sorted II 最多能完成排序的块 II (Hard)</p>
</li>
</ul>
<h2 id="队列-Queue">队列 Queue</h2>
<h3 id="基础">基础</h3>
<ul class="lvl-0">
<li class="lvl-2">
<h2 id="用队列实现栈-Easy">用队列实现栈 Easy</h2>
</li>
</ul>
<h3 id="双端队列">双端队列</h3>
<p><code>deque</code> : double-ended queue，和下面的单调队列一块看。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>239 Sliding Window Maximum 滑动窗口最大值 (Hard)</strong></p>
<p>难点：本质上题目就是一个<strong>动态集合维护最大值</strong>的问题。我们可以选用适当的数据结构来加快最大值的检索（如优先级队列/堆）。但是滑动窗口意味着有元素的弹出，<strong>如何从这些数据结构里弹出指定元素</strong>是需要解决的重难点。</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>解法一：堆</p>
<p>维护一个动态集合，并求该集合中的最大值，显然想到使用<strong>最大堆</strong>来实现。</p>
<p>我们不去关心堆的大小，每次都将滑动窗口右侧的新的值插入堆中。<strong>仅在弹出堆顶最大元素时，检查该元素是否位于当前滑动窗口内</strong>。检查的方法只有根据下标判断，所以堆中存放的不仅是元素的值（用于比较大小）、还有元素的下标（用于判断是否在滑动窗口内）。</p>
<p>时间复杂度为 $O(nlogn)$。</p>
</li>
<li class="lvl-4">
<p>解法二：单调队列</p>
<p>类似于单调栈，单调队列维持队内元素单调递增或递减。用该队列来实现滑动窗口，且队内元素单调排列，即可得每一个窗口处的最值。</p>
<p>一个比较重要的特点是，<strong>队列每一刻的大小</strong>并不需要和<strong>窗口大小</strong>完全一致，因为对于最值无意义的冗余元素无需入队，或者说已经被移出队列，以保证队列的单调性，从而实现最值的快速查找。</p>
<p>时间复杂度为 $O(n)$。</p>
</li>
</ul>
</li>
</ul>
<h3 id="单调队列">单调队列</h3>
<p>类似于单调栈，但是维持队列中元素单调需要使用<strong>双端队列（deque）</strong>。</p>
<p>以单调递减队列为例，队列内部为了保持单调递减，当队尾要插入的元素更大时，就要把队尾较小的元素出队，直至要插入的元素小于队尾后将其入队。所以队尾需要实现入队、出队两种功能。队首按具体应用场景进行分析。由此可见，实现单调队列不能用普通队列，而必须使用双端队列。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>239 Sliding Window Maximum 滑动窗口最大值 (Hard)</strong></p>
</li>
</ul>
<h2 id="优先级队列-Priority-Queue">优先级队列 Priority Queue</h2>
<blockquote>
<p>使用场景：经常<strong>插入</strong>、<strong>删除</strong>，通常都是<strong>访问最大/最小的元素</strong>。</p>
<p>两个知识点：</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>堆的手动实现（Heapify）；</p>
</li>
<li class="lvl-2">
<p>STL中<code>priority_queue</code>的使用。</p>
</li>
</ul>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p><em>23 Merge K Sorted Lists (Hard)</em></p>
<ol>
<li class="lvl-5">
<p>解法一：顺序合并。两个有序链表的合并只需要线性的时间，所以直接将K个有序链表按顺序进行两两合并即可得到答案。</p>
<p>时间复杂度上，每次合并是线性时间，$k$个链表两两组合需要$O(k<sup>2)$的时间，故总的时间复杂度为$O(k</sup>2n)$。</p>
</li>
<li class="lvl-5">
<p>解法二：分治合并。归并的分治思想，顺序合并的复杂度为$O(k^2)$，分治能够降低到 $O(klogk)$。从而总时间复杂度降低至$O(kn\times logk)$。空间复杂度为递归栈耗费空间，即$O(logk)$。</p>
</li>
<li class="lvl-5">
<p>**解法二：优先级队列/最小堆。**将合并两个有序链表的方式进行推广，我们可以每次比较每个链表头的元素大小，每次从中挑出最小的那个。</p>
<p>堆排序需要 $O(klogk)$ 的时间，所以时间复杂度为 $O(kn\times log k)$。空间复杂度为堆耗费的空间，即$O(n)$。</p>
<p>本题重点在于语法，包括<strong>STL中priority_queue的用法</strong>，以及<strong>仿函数的写法</strong>。</p>
</li>
</ol>
</li>
<li class="lvl-2">
<p><em>218 The Skyline Problem 天际线问题(Hard)</em></p>
<ul class="lvl-2">
<li class="lvl-4"><strong>扫描线</strong></li>
<li class="lvl-4">线段树</li>
<li class="lvl-4">优先级队列的<strong>延迟删除</strong></li>
</ul>
</li>
</ul>
<h3 id="延迟删除">延迟删除</h3>
<ul class="lvl-0">
<li class="lvl-2">
</li>
</ul>
<h2 id="哈希表-Hash">哈希表 Hash</h2>
<blockquote>
<p><strong>集合</strong>与<strong>映射</strong></p>
</blockquote>
<p><code>unordered_set</code> : 元素集合</p>
<p><code>unordered_map</code> : 常用于哈希表，内部实现就是基于哈希而非红黑树，操作效率跟哈希表一致</p>
<p>哈希表的<strong>基本概念</strong>要重新熟悉。见CLRS。</p>
<p>哈希表是典型的<strong>空间换时间</strong>，即额外开辟空间从而实现<code>O(1)</code>的查找复杂度。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>1 Two Sum 两数之和(Easy)</strong></p>
<p>思路：</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>首先思考暴力解：即针对每个元素 $val$，都寻找是否存在另一个元素值为 $target - val$。这个过程复杂度会达到$O(n^2)$，是因为每次寻找另一个元素值时需要遍历整个数组的线性时间；</p>
</li>
<li class="lvl-4">
<p>想要在这种情况下达到更快的效率，显然应该用空间换时间，即哈希来优化查找，从而使得查找操作变为 $O(1)$，整个效率降至 $O(n^2)$；</p>
</li>
<li class="lvl-4">
<p>注意到题中另一个点在于，最后返回的答案是下标而非值本身，所以要使用 $map$ 来存放值到下标的映射，但是这就会导致另一个问题：重复元素的下标存放。</p>
</li>
<li class="lvl-4">
<p>这里注意到题目的提示：答案只存在唯一一个，即如果有两个相同元素为答案，那么必定这两个相同元素之和即为目标值。而其他情况的重复元素无需关注，直接对其覆盖即可。</p>
</li>
<li class="lvl-4">
<p>最简单的做法是，扫描一遍，将已扫描的加入哈希表中，针对每个元素，查找之前的哈希表中是否有符合要求的元素，如果没有就将其也加入哈希表中，到下一个位置继续处理。</p>
</li>
</ul>
</li>
<li class="lvl-2">
<p>217 Contains Duplicate 存在重复元素 (Easy)</p>
</li>
<li class="lvl-2">
<p><strong>448 Find All Numbers Disappeared in an Array 找到所有数组中消失的数字 (Easy)</strong></p>
<p>题目要求：</p>
<ol>
<li class="lvl-5">
<p>不使用额外空间：第一反应是额外开哈希表，但这显然不符合原地完成的要求</p>
</li>
<li class="lvl-5">
<p>在$O(n)$时间内完成：没有说一趟扫描，且对空间使用有要求。这种情况一般要<strong>多趟扫描</strong>才能获得结果，也是一种空间换时间。</p>
</li>
</ol>
<p>观察题目发现，数组的大小正好就是可能出现的值的个数 $n$，所以利用<strong>原数组作为哈希</strong>进行标记。</p>
<p>由于数字值的范围均在 $[1, n]$ 中，我们可以利用这一范围<strong>之外</strong>的数字，来表达「是否存在」的含义。常见的解法如 $+n$ 或者取负。</p>
</li>
<li class="lvl-2">
<p><strong>128 Longest Consecutive Sequence 最长连续序列 (Medium)</strong></p>
<p>题目要在一个<strong>未排序</strong>的数组中<strong>找出数字连续的最长序列</strong>。要求是<strong>时间复杂度为 $O(n)$</strong>。</p>
<p>分析题目：</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>未排序且复杂度为线性：不能通过排序的方法进行处理；</p>
</li>
<li class="lvl-4">
<p>题目的耗时操作为无序数组中<strong>查找</strong>，既然对时间效率有要求，显然应<strong>该空间换时间</strong>，使用<strong>哈希</strong>。</p>
</li>
<li class="lvl-4">
<p>经验推测：时间复杂度只要求为线性，通常解法需要<strong>多趟扫描</strong>。（否则就写要求一趟扫描了）</p>
</li>
</ul>
<p>综上可得解法：</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>第一趟扫描：构建哈希表；</p>
</li>
<li class="lvl-4">
<p>后续的查找：可以针对每个元素向两侧搜索连续值，也可以针对没有更小值（不存在其值-1的元素）的元素进行单向搜索。</p>
</li>
</ul>
</li>
<li class="lvl-2">
<p>697 Degree of an Array 数组的度 (Easy)</p>
<p>典型的使用哈希表$map$记录映射的题目。</p>
</li>
<li class="lvl-2">
<p>*594 Longest Harmonious Subsequence 最长和谐子序列 (Easy)</p>
</li>
<li class="lvl-2">
<p><em>149 Max Points on a Line 直线上最多的点数(Hard)</em></p>
<blockquote>
<p>这道题的哈希并不是体现在用空间换时间的效率提升上，而是使用map来<strong>记录相同斜率的点的个数</strong>。</p>
<p>一个需要注意的语法问题：</p>
<p><strong><code>unordered_map</code>与<code>pair</code>同时使用存在的问题：</strong></p>
<p>有些时候，为了图省力，我们没准会这样的调用一个函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">unordered_map&lt; pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, <span class="hljs-type">int</span> &gt; mp;<br></code></pre></td></tr></table></figure>
<p>这样的写法是会报错的，因为pair还没有HASH键值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">error: call to implicitly-deleted <span class="hljs-keyword">default</span> constructor of <span class="hljs-string">&#x27;std::__1::hash&lt;std::__1::pair&lt;int, int&gt; &gt;&#x27;</span><br>: _Hash() &#123;&#125;<br></code></pre></td></tr></table></figure>
<p>会返回这样的一个报错，看到这里的hash和pair就应该知道了，我们的pair还没有hash值！</p>
<p>改良：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pairhash</span> &#123;<br>	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;</span><br><span class="hljs-function">	<span class="hljs-type">size_t</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;T, U&gt; &amp;i)</span> <span class="hljs-type">const</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">hash</span>&lt;T&gt;()(i.first) ^ <span class="hljs-built_in">hash</span>&lt;U&gt;()(i.second);<br>	&#125;<br>&#125;;<br>unordered_map&lt; pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, <span class="hljs-type">int</span> , pairhash &gt; mp;<br></code></pre></td></tr></table></figure>
<p>我们自己手动做一个hash就可以继续使用unordered_map了。</p>
</blockquote>
<p>题目要求：求最多有多少个点在同一条线上。</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>在同一条线上的判断转化到数据上就是：<strong>相同的斜率</strong>；</p>
</li>
<li class="lvl-4">
<p>整体思路上来看，就是一个简单的二重循环：在外层循环，是对每个点 $i$ <strong>建立一个从该点出发的直线的【斜率 - 直线上点的个数】的哈希表</strong>，即统计其他所有点与点 $i$ 所连直线的斜率，并记录下<strong>斜率出现的次数</strong>。每一轮循环后根据哈希表中的值更新最大值即可（要注意给斜率出现的次数加1，因为点 $i$ 自身也要被统计）；</p>
</li>
</ul>
<p>细节上有一些值得注意的点：</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>几何表示方面，<strong>斜率如何准确的表示</strong>是解题中最重要的点：</p>
<ul class="lvl-4">
<li class="lvl-6">
<p>我们用分数的形式来表示斜率更为准确，因为斜率未必是一个整数；</p>
</li>
<li class="lvl-6">
<p>那么如何保存分数呢？我们通过约分后的最简分数来表示；</p>
</li>
<li class="lvl-6">
<p>关于分子分母的保存有两个重要的点：</p>
<ol>
<li class="lvl-9">
<p><strong>正负</strong>：负号处在分子或者分母上，其实际表示的分数值虽然一致，但在 $pair$ 中的表示是不相同的。所以要将符号同一规定，放在分子或者分母上；</p>
</li>
<li class="lvl-9">
<p><strong>约分</strong>：要将分数约分成最简分数，约分的方式是找到<strong>最大公约数</strong>（通过<code>gcd</code>算法）。</p>
<blockquote>
<p>这里有一个值得注意的点，就是<strong>负数的取模运算：</strong></p>
<p><strong>如果第一个操作数为负数，则得到的模也是负数；如果第一个操作数是正数，则得到的模也是正数</strong>。与第二个操作数的正负没有关系，只跟第一个操作数有关。</p>
</blockquote>
</li>
</ol>
</li>
</ul>
</li>
<li class="lvl-4">
<p>效率方面，可以进行<strong>剪枝</strong>。当发现结果值，即以某一点为出发点的同一条线上点的个数：</p>
<ol>
<li class="lvl-7">
<p>已经超过了剩余点的数量，直接返回；</p>
</li>
<li class="lvl-7">
<p>已经超过了整体点的数量的一半，可以直接返回。</p>
</li>
</ol>
<p>剪枝的依据是：其他的点必定在另外一条线上（同一条线上的必定已经统计过了），那么即使都在一条线上，也不会比当前结果值更大了。</p>
<ol start="3">
<li class="lvl-7">
<p>当我们枚举到点 $i$ 时，我们只需要考虑编号大于 $i$ 的点到点 $i$ 的斜率，因为如果直线同时经过编号小于点 $i$ 的点 $j$，那么当我们枚举到 $j$ 时就已经考虑过该直线了；</p>
</li>
<li class="lvl-7">
<p>点的总数小于等于2，可以用一条直线将所有点串联，此时直接返回点的总数量。（两点确定一条直线）</p>
</li>
</ol>
</li>
</ul>
</li>
<li class="lvl-2">
<p>870 Advantage Shuffle 优势洗牌 (Medium)</p>
<p>主要思想为贪心，见<a href="#%E8%B4%AA%E5%BF%83">贪心算法</a>部分。</p>
</li>
</ul>
<h2 id="树-Tree">树 Tree</h2>
<h3 id="字典树-Trie-Tree">字典树 Trie Tree</h3>
<p>*（TBD）*分析前缀树的性能，以及实际使用场景</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>208 Implement Trie (Prefix Tree) 实现Trie（前缀树）(Medium)</p>
</li>
</ul>
<h2 id="二叉树-Binary-Tree">二叉树 Binary Tree</h2>
<p>对于链表结构实现的二叉树，一定要注意<em>递归</em>的运用。</p>
<h3 id="二叉树的递归">二叉树的递归</h3>
<blockquote>
<p><em>重要</em>：链表结构二叉树具有<strong>相同的子结构</strong>，所以非常适合用<em>递归</em>来解决其相关问题，该部分有很多二叉树的基本操作需要熟练掌握。同时加深对于二叉树中递归具体实现的理解！</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>104 Maximum Depth of Binary Tree 二叉树的最大深度 (Easy)</p>
</li>
<li class="lvl-2">
<p>110 Balanced Binary Tree 平衡二叉树 (Easy)</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>解法一：自顶向下的递归，类似先序遍历的顺序</p>
<p>判断平衡的逻辑是：当前节点平衡且左右子树均平衡（根左右）</p>
<p>最坏的情况下，树变为线性结构（一个链表），时间复杂度为<code>O(n^2)</code>，自顶向下的过程存在大量重复计算</p>
</li>
<li class="lvl-4">
<p>解法二：自底向上的递归，类似后续遍历的顺序</p>
<p>不存在重复计算，时间复杂度为<code>O(n)</code>。</p>
</li>
</ul>
</li>
<li class="lvl-2">
<p>543 Diameter of Binary Tree 二叉树的直径 (Easy)</p>
<p>后序遍历为顺序的深搜（自底向上的递归），要注意的点在于递归函数处理的两个值：</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>返回值：返回的仍然是<strong>节点的高度</strong>，自底向上传递其高度。</p>
<p>每个节点的<strong>左子树高度+右子树高度</strong>即为当前待比较更新的<strong>直径</strong>。</p>
</li>
<li class="lvl-4">
<p>结果/答案 ： 即<strong>直径</strong>，该值需要不断更新其最大值</p>
</li>
</ul>
</li>
<li class="lvl-2">
<p><em>437 Path Sum III 路径总和 III (Medium)</em></p>
<ul class="lvl-2">
<li class="lvl-4">解法一：遍历穷举</li>
<li class="lvl-4">解法二：<a href="###%E5%89%8D%E7%BC%80%E5%92%8C">前缀和</a></li>
</ul>
</li>
<li class="lvl-2">
<p>101 Symmetric Tree 对称二叉树 (Easy)</p>
<p>这里的对称时<strong>镜像对称</strong>，其他要求处理方法存在不同。</p>
<p>首先，判断镜像的条件，对于每两个对称位置上的节点：</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>具有相同的值；</p>
</li>
<li class="lvl-4">
<p>其左右子树均为镜像对称，即每个树的右子树与另一个树的左子树一致。</p>
</li>
</ul>
<p>具体实现：</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>左右子树均为空时，两个节点及其子树必定对称；</p>
</li>
<li class="lvl-4">
<p>左右子树有某一个不为空时，两个节点必定不对称；</p>
</li>
<li class="lvl-4">
<p>两个节点的值不相等时，必定不对称；</p>
</li>
<li class="lvl-4">
<p>如果两个节点的值相等且左右子树均不为空，则根据相等或对称要求递归向下判断子树。</p>
</li>
</ul>
<p>解法有两种，一种是递归判断；一种是利用队列将递归转化为迭代，每次判断列表中连续的两个元素是否一致。</p>
<p>空间复杂度和时间复杂度均为线性。</p>
</li>
<li class="lvl-2">
<p><strong>1110 Delete Nodes And Return Forest 删点成林 (Medium)</strong></p>
<p>后序遍历，要注意递归的细节，<strong>递归的返回值</strong>传递的是更新后的节点指针（要么保持不变，要被被删掉变为<code>nullptr</code>）。</p>
</li>
<li class="lvl-2">
<p>226 Invert Binary Tree 翻转二叉树 (Easy)</p>
<p>递归实现。有相同结构的子问题。</p>
</li>
<li class="lvl-2">
<p><em>572 Subtree of Another Tree 另一颗树的子树 (Easy???)</em></p>
<ul class="lvl-2">
<li class="lvl-4">
<p>解法一：递归</p>
<p>理清思路，一开始的想法有问题。递归整体还是最简单的解法。</p>
</li>
<li class="lvl-4">
<p>解法二：<em>KMP算法</em></p>
<p>跟匹配相关，且存在重复匹配，很显然就能想到利用KMP算法来进行优化。</p>
</li>
<li class="lvl-4">
<p>解法三：<em>树哈希</em></p>
</li>
</ul>
</li>
<li class="lvl-2">
<p>257 Binary Tree Paths 二叉树的所有路径 (Easy)</p>
<p>拷贝传值而非引用传值，从而实现无需回溯，简单的遍历即可获得所有路径。</p>
</li>
</ul>
<h3 id="二叉树的遍历-Traversal">二叉树的遍历 Traversal</h3>
<h4 id="层序遍历">层序遍历</h4>
<blockquote>
<p>Level order traversal</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>637 Average of Levels in Binary Tree 二叉树的层平均值 (Easy)</p>
<ul class="lvl-2">
<li class="lvl-4">显而易见，应该用层序遍历来处理。注意点在于如何对每一层来进行区分处理。</li>
<li class="lvl-4">深搜/广搜一样可以实现，但需要额外记录当前所在的层数（通过递归函数参数传递）。</li>
</ul>
</li>
<li class="lvl-2">
<p>513 Find Bottom Left Tree Value 找树左下角的值 (Medium)</p>
</li>
</ul>
<h4 id="前-中-后序遍历">前/中/后序遍历</h4>
<blockquote>
<p>常见题型/需要熟练掌握的操作：</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>前、中、后序遍历的</p>
<ul class="lvl-3">
<li class="lvl-4">
<p><input type="checkbox" id="checkbox4" checked="true"><label for="checkbox4"></label><strong>递归</strong>写法；</p>
</li>
<li class="lvl-4">
<p><input type="checkbox" id="checkbox5" checked="true"><label for="checkbox5"></label><strong>非递归 / 迭代</strong>写法：其中<strong>后序</strong>格外重要；</p>
</li>
<li class="lvl-4">
<p><input type="checkbox" id="checkbox6" checked="true"><label for="checkbox6">[Morris 遍历 / 线索二叉树](##Morris Traversal / 线索二叉树)；</label></p>
<p>递归和迭代写法的时间复杂度与空间复杂度均为线性 <code>O(n)</code>，而Morris遍历能够将额外的空间复杂度降到常数级<code>O(1)</code>。</p>
<p><em>即，遇到树的前中后序遍历相关的题目，要立刻想到尝试通过Morris遍历来对空间复杂度进行进一步优化。</em></p>
</li>
</ul>
</li>
<li class="lvl-2">
<p>根据中序遍历序列与另外一种序列来<strong>构造二叉树</strong>；</p>
<ul class="lvl-3">
<li class="lvl-4"><input type="checkbox" id="checkbox7" checked="true"><label for="checkbox7">递归写法</label></li>
<li class="lvl-4"><input type="checkbox" id="checkbox8"><label for="checkbox8"></label><em>迭代写法（TBD）</em></li>
</ul>
</li>
</ul>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>144 Binary Tree Preorder Traversal 二叉树的前序遍历 (Easy)</p>
</li>
<li class="lvl-2">
<p>94 Binary Tree Inorder Traversal 二叉树的中序遍历 (Easy)</p>
</li>
<li class="lvl-2">
<p>145 Binary Tree Postorder Traversal 二叉树的后序遍历 (Easy)</p>
<p>后序遍历的迭代写法格外值得注意：</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>常规的递归栈模拟迭代写法比较复杂，必须要借助<code>prev</code>指针保留上一层的记录；</p>
</li>
<li class="lvl-4">
<p>可以根据先序的思路写，把“根左右”的顺序改成“根右左”（即调整左右儿子入栈的顺序），最后将结果倒转就能轻松得到后序序列。</p>
</li>
</ul>
</li>
<li class="lvl-2">
<p>530 Minimum Absolute Difference in BST 二叉搜索树的最小绝对差 (Easy)</p>
</li>
<li class="lvl-2">
<p>404 Sum of Left Leaves 左叶子之和 (Easy)</p>
</li>
<li class="lvl-2">
<p>538 Convert BST to Greater Tree 把二叉搜索树转换为累加树 (Medium)</p>
<p>不要因为前中后序遍历而陷入思维定势，这道题就巧妙的利用了逆中序遍历实现了“右根左”的访问顺序。</p>
<p>同时这道题涉及到BST的性质：中序遍历为有序序列，显然其逆中序遍历序列仍为有序，只是递增和递减的区别。</p>
</li>
<li class="lvl-2">
<p>236 Lowest Common Ancestor of a Binary Tree 二叉树的最近公共祖先 (Medium)</p>
</li>
</ul>
<h4 id="根据遍历序列构造二叉树">根据遍历序列构造二叉树</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>105 Construct Binary Tree from Preorder and Inorder Traversal 从先序与中序遍历序列构造二叉树 (Medium)</p>
<p>算法实现过程：</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>每次根据<strong>先序遍历的第一个值</strong>来确定当前的<strong>根节点</strong>；</p>
</li>
<li class="lvl-4">
<p>在中序遍历中找到根节点的位置，并以此区分出两侧的左右子树；</p>
<p><em>TRICKS!</em> ：由于每次寻找都要花费线性的时间，所以引入了中序遍历及其对应位置的<strong>哈希表</strong>，将搜索时间简化为常数。</p>
</li>
<li class="lvl-4">
<p>区分出左右子树的范围后，向左右子树进行递归：</p>
<ul class="lvl-4">
<li class="lvl-6">参数：递归参数最重要的是先序序列和中序序列中的范围，即本次递归的子树范围；</li>
<li class="lvl-6">返回值：递归的返回值为当前子树的根节点，向上层返回该根节点指针；</li>
<li class="lvl-6">递归基：直至参数中的子树范围非法，具体理解通过模拟实际感受一下。</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-2">
<p>106 Construct Binary Tree from Inorder and Postorder Traversal 从中序与后序遍历序列构造二叉树 (Medium)</p>
<p>跟105一样。</p>
</li>
<li class="lvl-2">
<p>889 Construct Binary Tree from Preorder and Postorder Traversal 根据前序和后序遍历构造二叉树 (Medium)</p>
<p>只有通过中序序列才能构建出唯一的树，只用前序和后序序列会得到不唯一的解，题目中要求是返回任意一个合理答案即可。</p>
<p>本质上写法其实是一致的，只不过没有中序序列的情况下答案不唯一。</p>
<p>通过<strong>递归</strong>的思路来实现：</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>每次可以确定先序的第一个元素与后序的最后一个元素相等且为当前子树的根节点；</p>
</li>
<li class="lvl-4">
<p>先序序列的第二个元素为左子树根节点，在后序序列中找到这个左子树根节点即可获得左子树的序列，向下递归；右子树序列同理。</p>
</li>
</ul>
</li>
</ul>
<h3 id="二叉搜索树-BST-2">二叉搜索树 BST</h3>
<h4 id="基本操作-CRUD-2">基本操作 CRUD</h4>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>查找：递归实现</p>
</li>
<li class="lvl-2">
<p>插入：查找失败的位置就是插入的位置</p>
</li>
<li class="lvl-2">
<p><em>删除</em>：递归，分情况处理</p>
<ul class="lvl-3">
<li class="lvl-4">当前节点值大于待删值，递归向左进入左子树进行删除；</li>
<li class="lvl-4">当前节点值小于待删值，递归向右进入右子树进行删除；</li>
<li class="lvl-4">当前节点即为待删节点：
<ul class="lvl-5">
<li class="lvl-6">被删除节点为叶节点：直接删除，返回<code>nullptr</code>;</li>
<li class="lvl-6">被删除节点仅有一个儿子：直接将其儿子拉上来代替即可；</li>
<li class="lvl-6">被删除节点有两个儿子：取中序前驱或中序后继来代替，转化为删除这两个节点，退化为前两种情况处理。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>删除操作比较重要，BST的基本操作都没有考虑树的结构（一般都在AVL中考虑），实际使用也可以增加对树高平衡的控制。</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-3">
<p><strong>450 Delete Node in a BST 删除二叉搜索树中的节点 (Medium)</strong></p>
</li>
</ul>
<h4 id="特性-中序序列有序-2">特性 - 中序序列有序</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>99 Recover Binary Search Tree 恢复二叉搜索树 (Medium)</p>
<p>利用二叉搜索树中序遍历有序的特性来进行恢复</p>
</li>
<li class="lvl-2">
<p>669 Trim a Binary Search Tree 修剪二叉搜索树 (Easy)</p>
<p>利用递归实现</p>
</li>
<li class="lvl-2">
<p>235 Lowest Common Ancestor of a Binary Search Tree 二叉搜索树的最近公共祖先 (Medium)</p>
<p>重点在于理解其从根节点向下到第一个分叉节点即为两个节点的公共祖先。</p>
<p>对于BST来说，从根节点开始第一个值大小在二者之间的即为其分叉点。</p>
<p>鉴于树的相同子结构，递归和非递归算法均可实现。</p>
</li>
<li class="lvl-2">
<p>538 Convert BST to Greater Tree 把二叉搜索树转换为累加树 (Medium)</p>
<p>不要因为前中后序遍历而陷入思维定势，这道题就巧妙的利用了逆中序遍历实现了“右根左”的访问顺序。</p>
<p>同时这道题涉及到BST的性质：中序遍历为有序序列，显然其逆中序遍历序列仍为有序，只是递增和递减的区别。</p>
</li>
<li class="lvl-2">
<p>108 Convert Sorted Array to Binary Search Tree 将有序数组转换为二叉搜索树 (Easy)</p>
</li>
<li class="lvl-2">
<p>109 Convert Sorted List to Binary Search Tree 有序链表转换为二叉搜索树 (Medium)</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>解法一：将链表转换为有序数组，退化为108</p>
</li>
<li class="lvl-4">
<p>解法二：题目的重点在于二分，链表的特性则难以随机寻找重点，这里用快慢指针进行查找</p>
<p>时间复杂度必然提升（搜索中点），空间复杂度得以下降</p>
</li>
<li class="lvl-4">
<p>解法三：利用BST中序遍历有序的特性，有序序列必定对应一颗二叉搜索树的中序，所以我们先按照元素个数对树进行一个保持平衡的构建，并按照中序顺序有序的填入值。</p>
<blockquote>
<p><em>重点</em>：注意递归参数中的指针</p>
<p>如果在递归体中某一个指针参数变量本身的值会被改变，务必使用<em>引用</em>！</p>
<p>这才能确保其值是能够正确的向下传递并向上返回！</p>
<p>理解指针的实质，也是一个变量，如果只修改指针指向的内容而非指针本身，则无需使用引用。</p>
</blockquote>
</li>
</ul>
</li>
<li class="lvl-2">
<p>897 Increasing Order Search Tree 递增顺序搜索树 (Easy)</p>
</li>
<li class="lvl-2">
<p>653 Two Sum IV - Input is a BST 两数之和 IV - 输入BST (Easy)</p>
</li>
</ul>
<h3 id="平衡二叉树-AVL">平衡二叉树 AVL</h3>
<h3 id="红黑树-RB-Tree">红黑树 RB Tree</h3>
<h3 id="堆-Heap-2">堆 Heap</h3>
<h3 id="哈夫曼树-Huffman-Tree">哈夫曼树 Huffman Tree</h3>
<h3 id="扫描线">扫描线</h3>
<h2 id="图-Graph">图 Graph</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>无论是邻接表还是邻接矩阵实现，点都是通过序号来表示的。如果题目中给出的节点通过其他形式（如字符串）表示，要通过map转换成整型序号（似乎leetcode并不存在这种问题…）</p>
</li>
</ul>
<h3 id="图的遍历-Traversal">图的遍历 Traversal</h3>
<h3 id="最短路径-Shortest-Path">最短路径 Shortest Path</h3>
<h3 id="最小生成树-Minimum-Spanning-Tree">最小生成树 Minimum Spanning Tree</h3>
<h3 id="拓扑排序-Topological-Sort">拓扑排序 Topological Sort</h3>
<p>拓扑排序就是对有向无环图（Directed Acyclic Graph, DAG）进行排序，其本质还是一个<strong>广度优先搜索</strong>。</p>
<p>常用于处理有向图中的依赖性问题，并能够判断图中是否存在环路。</p>
<p>而对于无向图的连通性问题，更多考虑使用 [并查集](##并查集 Union-find Set)。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>210 Course Schedule II 课程表 II (Medium)</p>
</li>
</ul>
<h3 id="二分图-Bipartite-Graph">二分图 Bipartite Graph</h3>
<blockquote>
<p>二分图的定义：图中所有顶点可以分割为两个子集合，图中所有边的两个顶点来自于不同的集合，即同一集合中的任意两点之间没有边。</p>
<p>二分图是图论中一个比较经典的问题，对于其判定除了常见的染色法还有其他的做法待补充（对面试作用不大）。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_26822029/article/details/90382581">(17条消息) 二部图（二分图）总结_哆啦A瑶的博客-CSDN博客_二分图</a></p>
</blockquote>
<p>通常使用<strong>染色法</strong>解决二分图问题：</p>
<p>用深搜或广搜从任意一个节点开始，对其相邻节点上与当前节点不同的颜色，如果其任一相邻节点已经染过色且与当前节点颜色相同，那么该图无法被二分。</p>
<p>节点的颜色状态数组同时也起到了访问数组的作用，能够提供当前节点是否被访问过的信息。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>785 Is Graph Bipartite? 判断二分图 (Medium)</p>
<p>染色法，通过 深度优先遍历 或 广度优先遍历 均可实现。</p>
</li>
</ul>
<h3 id="欧拉通路-回路">欧拉通路/回路</h3>
<p>简单的来讲，就是<strong>图的遍历</strong> + <strong>栈</strong>，要注意的点是</p>
<ol>
<li class="lvl-3">
<p>删去边：每次访问都要删去当前访问的边；</p>
</li>
<li class="lvl-3">
<p>何时入栈：通常选择出度已经为0（边已经删干净的）；</p>
</li>
<li class="lvl-3">
<p>栈存放结果：最终的实际结果往往要把栈倒转过来。</p>
</li>
</ol>
<blockquote>
<p>即给定一个起点的<strong>一笔画</strong>问题。</p>
<h4 id="1-定义">1 定义</h4>
<ul class="lvl-1">
<li class="lvl-2">
<p>通过图中所有边恰好一次且行遍所有顶点的通路称为欧拉通路。</p>
</li>
<li class="lvl-2">
<p>通过图中所有边恰好一次且行遍所有顶点的回路称为欧拉回路。</p>
</li>
<li class="lvl-2">
<p>具有欧拉回路的无向图称为欧拉图。</p>
</li>
<li class="lvl-2">
<p>具有欧拉通路但不具有欧拉回路的无向图称为半欧拉图。</p>
</li>
</ul>
<h4 id="2-判断">2 判断</h4>
<p>如果没有保证至少存在一种合理的路径，我们需要判别这张图是否是欧拉图或者半欧拉图，具体地：</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>对于无向图 G：</p>
<ul class="lvl-3">
<li class="lvl-4">
<p>G 是欧拉图当且仅当 G 是连通的且没有奇度顶点。</p>
</li>
<li class="lvl-4">
<p>G 是半欧拉图当且仅当 G 是连通的且 G 中恰有 2 个奇度顶点。</p>
</li>
</ul>
</li>
<li class="lvl-2">
<p>对于有向图 G</p>
<ul class="lvl-3">
<li class="lvl-4">
<p>G 是欧拉图当且仅当 G 的所有顶点属于同一个强连通分量且每个顶点的入度和出度相同。</p>
</li>
<li class="lvl-4">
<p>G 是半欧拉图当且仅当 G 的所有顶点属于同一个强连通分量且：</p>
<ul class="lvl-5">
<li class="lvl-6">恰有一个顶点的出度与入度差为 1；</li>
<li class="lvl-6">恰有一个顶点的入度与出度差为 1；</li>
<li class="lvl-6">所有其他顶点的入度和出度相同。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>判断及证明放到离散数学/算法导论中具体了解。</p>
<h4 id="3-求解">3 求解</h4>
<p><strong>Heirholzer算法</strong>：</p>
<ol>
<li class="lvl-3">
<p>从起点出发，进行深度优先搜索；</p>
</li>
<li class="lvl-3">
<p>每次沿着某条边从某个顶点移动到另外一个顶点的时候，都需要删除这条边；</p>
</li>
<li class="lvl-3">
<p>如果没有可移动的路径，则将所在节点加入到栈中，并返回。</p>
</li>
</ol>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p><em>332 Reconstruct Itinerary 重新安排行程 (Hard)</em></p>
<ul class="lvl-2">
<li class="lvl-4"><strong>多重</strong>映射 来记录多个可能的终点，本质其实是一个<em>图</em>的遍历/搜索</li>
<li class="lvl-4">欧拉回路/通路问题 (DFS)</li>
</ul>
</li>
<li class="lvl-2">
<p>753 Cracking the Safe 破解保险箱 (Hard)</p>
</li>
</ul>
<h2 id="字符串-String">字符串 String</h2>
<blockquote>
<p>字符串部分套路多一些，需要背一背。</p>
</blockquote>
<h3 id="基础-2">基础</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>242 Valid Anagram 有效的字母异位词 (Easy)</p>
<ul class="lvl-2">
<li class="lvl-4">其实是个<strong>哈希表</strong>的题目</li>
</ul>
</li>
<li class="lvl-2">
<p>205 Isomorphic Strings 同构字符串 (Easy)</p>
<ul class="lvl-2">
<li class="lvl-4">其实还是个<strong>哈希表</strong>的题目。</li>
<li class="lvl-4">有点小坑，要同时利用两个哈希表。</li>
</ul>
</li>
<li class="lvl-2">
<p>696 Count Binary Substrings 计数二进制子串 (Easy)</p>
<p>思路题：重点在于子串中的0和1是成组连续的，所以每当子串中的字符发生变换时，就可以对子串数进行统计。</p>
</li>
<li class="lvl-2">
<p>409 Longest Palindrome 最长回文串 (Easy)</p>
<ul class="lvl-2">
<li class="lvl-4">其实又是一个<strong>哈希表</strong>的题目。</li>
</ul>
</li>
</ul>
<h3 id="回文-Palindrome">回文 Palindrome</h3>
<ul class="lvl-0">
<li class="lvl-2">
</li>
</ul>
<p>回文子序列/子串的题型有多种变式，常见的解法（除暴力求解外）有以下三种（上面两道题都可以用以下算法解答）。</p>
<h4 id="中心拓展">中心拓展</h4>
<p>本质上还是暴力枚举，只不过<strong>枚举回文中心</strong>比<strong>枚举出所有子串</strong>方便的多。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>要区分两种情况：奇数回文串和偶数回文串。</p>
</li>
<li class="lvl-2">
<p>时间复杂度：$O(n^{2})$</p>
</li>
</ul>
<h4 id="Manacher">Manacher</h4>
<p>详见<a href="##Manacher%E7%AE%97%E6%B3%95">Manacher算法</a></p>
<h4 id="动态规划">动态规划</h4>
<p>题目：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>647 Palindromic Substrings 回文子串 (Medium)</p>
</li>
<li class="lvl-2">
<p>5 Longest Palindromic Substring 最长回文子串 (Medium)</p>
</li>
<li class="lvl-2">
<p>214 Shortest Palindrome 最短回文串 (Hard)</p>
<p>本题的解法实际上是字符串匹配，所以详见字符串匹配部分。</p>
</li>
</ul>
<h3 id="字符串匹配">字符串匹配</h3>
<p>跟字符串匹配相关的解法如下：</p>
<ol>
<li class="lvl-3">
<p>朴素匹配</p>
</li>
<li class="lvl-3">
<p><a href="##KMP%E7%AE%97%E6%B3%95">KMP算法</a></p>
</li>
<li class="lvl-3">
<p><strong>Robin-Karp算法</strong>，即<strong>滚动哈希</strong>。</p>
<p>本质上就是字符串哈希，即将字符串转换为一个整数从而方便比较。该算法有几个值得注意的点，在此指明：</p>
<ul class="lvl-2">
<li class="lvl-5">
<p>因为直接按照进制转换求值有可能会导致哈希值过大，无法在机器字长内表示，所以通常会模上一个大质数；</p>
</li>
<li class="lvl-5">
<p>对于转换的进制 $base$ 和模数 $mod$ 的选取：</p>
<p>一般来说，我们选取一个<strong>大于字符集大小</strong>（即字符串中可能出现的字符种类的数目）<strong>的质数</strong>作为 $base$，再选取一个在<strong>字符串长度平方级别左右的质数</strong>作为 $mod$，产生哈希碰撞的概率就会很低。</p>
<p>对于leetcode中的题目，大都以<strong>全小写字母形式</strong>的字符串出现，这种情况下常用如下设置：</p>
<ul class="lvl-4">
<li class="lvl-7">
<p>$base$：略大于字符集大小的质数，选定<strong>29</strong>或<strong>31</strong>（有大写的话就增加就行）；</p>
</li>
<li class="lvl-7">
<p>$mod$：所有跟哈希计算相关的值都设置为<code>unsigned long long</code>类型，则运算时相当于自动取模，而不会产生任何上下溢出，编译器会自动截断。</p>
</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-3">
<p>有限状态机</p>
</li>
</ol>
<p>基本上掌握 <strong>KMP</strong>和<strong>滚动哈希</strong>即可解决相关的大部分问题，且面试出现频率不高，相关题目如下：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>28 实现 strStr() Implement strStr() (Easy)</p>
</li>
<li class="lvl-2">
<p>796 Rotate String 旋转字符串 (Easy)</p>
<p>解法一：模拟</p>
<p>按照题目要求，进行旋转操作，并对比旋转后的结果；</p>
<p>主要的开销在于旋转操作，每次的旋转要去掉第一个字符，需要 $O(n)$ 的时间。</p>
<p>解法二：<strong>字符串匹配</strong></p>
<p>文本串 <strong>$s + s$</strong> 包含了所有 $s$ 可以通过旋转操作得到的字符串，只需要检查 $goal$ 是否为 $s + s$ 的子字符串即可。</p>
</li>
<li class="lvl-2">
<p><strong>214 Shortest Palindrome 最短回文串 (Hard)</strong></p>
<blockquote>
<p>首先思考如何找到该最短回文串，如下图所示：</p>
<p>我们要在 $s$ 前添加一个字符串，要求得到最短的回文串。实际的字符串构成如图所示，即将 $s$ 的一部分后缀 $s_2$ 反转得到 $\hat{s_2}$，并拼接在 $s$ 的前面。这里为了保证整体是回文串，就要求前缀 $s_1$ 部分必须也是回文的。</p>
<p>最简单的例子就是将整个字符串倒转后添加在前面，一定能得到一个回文串。而为了满足最短的要求，实际就是找到最短的 $\hat{s_2}$，同理就是【<strong>找到最长的 $s_1$ 满足其为回文串</strong>】。</p>
<p>由此可得，暴力解法即<strong>从后往前枚举每个元素，查看当前的前缀 $s_1$ 是否为回文串</strong>。该方法的时间复杂度显然为 $O(|s|^2)$ 。</p>
<p>优化的解法也是在这个思路的基础上进行优化。</p>
</blockquote>
<img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205161418594.png" srcset="/img/loading.gif" lazyload style="zoom: 50%;" />
<p>解法一：KMP算法</p>
<p>为了找到最长的 $s_1$，我们将 $s$ 作为pattern，将 $\hat{s}$ 作为text，进行模式匹配。如图所示，最后匹配的位置就能帮助我们获取到答案。</p>
<p><img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205161501183.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>解法二：Robin-Karp字符串哈希算法</p>
</li>
<li class="lvl-2">
<p><strong>1044 Longest Duplicate Substring 最长重复子串 (Hard)</strong></p>
<ul class="lvl-2">
<li class="lvl-4">
<p>首先，题目要求找到具有最长长度的子串，所以要对长度进行枚举 - $O(n)$</p>
<p>优化方法是采用二分，时间复杂度可以降至 $O(logn)$。</p>
</li>
<li class="lvl-4">
<p>在每一个长度下，要两两遍历子串来查询其是否有出现过 - $O(n^2)$</p>
<p>采用Robin-Karp算法，判断同一长度下是否有两个相同字符串只需要一趟扫描，即 $O(n)$。</p>
</li>
</ul>
</li>
<li class="lvl-2">
<p><strong>459 Repeated Substring Pattern 重复的子字符串 (Easy)</strong></p>
<p>解法一：暴力枚举</p>
<p>对子串长度进行枚举，检查子串符合要求的有两种思路：</p>
<ol>
<li class="lvl-5">
<p>拼接 $n$ 个字串（假设需要 $n$ 个），拼接后检查是否与原字符串相等。非常慢。</p>
</li>
<li class="lvl-5">
<p>假设当前子段长度为 $n$，从第二个字串开始到最后为止，检查 $s[i] == s[i - n]$ 。有任意一次不满足相等就可以直接剪枝。</p>
</li>
</ol>
<p>时间复杂度为 $O(n^2)$。</p>
<p>解法二：<strong>字符串匹配</strong></p>
<p>详见<a href="##%E5%91%A8%E6%9C%9F%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%A4%E5%88%AB%E9%97%AE%E9%A2%98">周期字符串判别问题</a>。</p>
</li>
</ul>
<h3 id="其他-2">其他</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><em>316 Remove Duplicate Letters 去除重复字母 (Medium)</em></p>
<p>题目中的要求：去除重复字母，保证返回的字典序最小，且不能打乱字符的相对位置。</p>
<p>关于字符串的知识点在于：<strong>针对一个字符串，在其中删除哪个元素能保证结果字符串的字典序最小/大？</strong></p>
<p>详见[单调栈部分](###单调栈 Monotone Stack)。</p>
</li>
<li class="lvl-2">
<p><strong>227 Basic Calculator II 基本计算器 II  (Medium)</strong></p>
<p>详见<a href="###%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC">表达式求值</a>部分。</p>
</li>
</ul>
<h2 id="并查集-Union-find-Set">并查集 Union-find Set</h2>
<p>从最直观的角度来看，并查集最典型的使用场景就是<strong>判断元素处于哪个 集合 中</strong>，也就是<strong>元素分组</strong>的问题。并查集管理一系列<strong>不相交</strong>的集合，并支持两种主要操作：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>Union 合并：把两个不相交的 <strong>集合</strong> 合并为一个集合；</p>
</li>
<li class="lvl-2">
<p>Find 查询：查询两个元素是否在同一个集合中。</p>
</li>
</ul>
<h3 id="使用场景">使用场景</h3>
<p>并查集的优势在于：同一集合中存在大量元素，且元素之间具有较为复杂的关系组织时，判断元素的归属问题需要过多的资源，而并查集能够在更少的资源下完成这种类型的操作。比如经典的亲戚问题：</p>
<blockquote>
<p>若某个家族人员过于庞大，要判断两个人是否为亲戚是一个比较复杂的过程，现在给出某个亲戚关系图，求任意给出的两个人是否具有亲戚关系。</p>
</blockquote>
<p>上述类型问题显然非常适合并查集，尤其是经过<strong>路径压缩</strong>的并查集。</p>
<p>整体来说：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>对于判断<strong>集合归属</strong>、<strong>无向图连通性</strong>这类问题时，常考虑<strong>并查集</strong>。</p>
</li>
<li class="lvl-2">
<p>与之相反的，关于<strong>有向图之间的（对前驱节点的）依赖性</strong>，仍然采用<strong>搜索</strong>以及 [拓扑排序](###拓扑排序 Topological Sort)（常用于判断是否存在环路）这类方法来解决。</p>
</li>
<li class="lvl-2">
<p>除此之外，并查集一个常用的使用场景是 <strong>Kruskal’s Algorithm</strong> 实现<strong>最小生成树</strong>算法。</p>
</li>
</ul>
<h3 id="基本操作-2">基本操作</h3>
<p>在实现了其基本操作之后，并查集还有两种改进的方式，分别是<strong>路径压缩</strong>和<strong>按秩合并</strong>。</p>
<h3 id="路径压缩-Path-Compression">路径压缩 Path Compression</h3>
<h3 id="按秩合并">按秩合并</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>684 Redundant Connection (Medium)</p>
</li>
</ul>
<h1>动态规划 Dynamic Programming</h1>
<h2 id="Background">Background</h2>
<p>6.006认为算法的核心在于 “constant-sized program to solve arbitrary input”。所以整门课程的各种算法都与<strong>递归</strong>或<strong>循环</strong>有关。</p>
<p>如果是一些已知的问题，我们可以 reduce to a problem we already know 。比如使用搜索算法、排序算法以及图算法等来解决相应的问题。而这部分重点关注的是<strong>如何设计递归算法</strong>，并给出一个设计范式（SRTBOT）。根据子问题图的形状不同，我们也能够将这类问题进行细分，包括<strong>减治</strong>、<strong>分治</strong>、<strong>动态规划</strong>等。</p>
<p>这一部分的精髓就在于这个SRTBOT设计范式，其中的每一步重难点会放在后面详细讲解。时刻关注：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>常见的DP题类型：如LCS、LIS等；</p>
</li>
<li class="lvl-2">
<p>如何去针对使用场景使用SRTBOT来设计DP算法；</p>
</li>
<li class="lvl-2">
<p>把握需要使用DP类型的题目的特征：<em>最优子结构（optimal substructure）</em> 与 <em>子问题重叠（overlapping subproblem）</em>。</p>
<p>与此相对的，子问题不重叠的一个常见情况就是<strong>分治（Divide &amp; Conquer）</strong>。</p>
</li>
</ul>
<h2 id="Basic-2">Basic</h2>
<p>与分治相似，都是通过<strong>组合子问题的解</strong>来求解原问题。区别在于分治是将问题划分为互不相交的子问题，而动态规划与之相反，应用于子问题重叠的情况。</p>
<h3 id="使用前提">使用前提</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><em>子问题重叠（overlapping subproblem）</em>：即不同的子问题具有公共的子子问题。</p>
<p>我们知道，子问题是不断递归求解，将其划分为更小的子问题。对于没有子问题重叠的情况，我们使用分治就能够在合理的时间内解决，但是如果子问题之间有公共子问题就不一样了。此时分治算法会<strong>反复多次求解公共子问题</strong>。</p>
<p>动态规划则对每个子问题只求解一次，具体的方法则有自顶向下和自底向上两种，后面会详细讲解。</p>
</li>
<li class="lvl-2">
<p><em>最优子结构（optimal substructure）</em>：问题的最优解由相关子问题的最优解组合而成，而这些子问题可以独立求解。</p>
<p>如何判断问题具有最优子结构：<strong>子问题无关（independent）</strong>。即同一个原问题的其中一个子问题的解不会影响另一个子问题的解。</p>
<p>最优子结构是一个很值得关注的点，但并不是使用动态规划的充分条件。最优子结构常常意味着应该使用<strong>贪心算法</strong>。</p>
</li>
</ul>
<p>这两个概念都比较抽象，结合后面的例子来进行更深刻的理解。</p>
<h3 id="使用场景-2">使用场景</h3>
<p>最优化问题（optimization problem）</p>
<h2 id="SRT-BOT">SRT BOT</h2>
<p>设计属于自己的递归算法的一套范式。并不一定只能写</p>
<p>How to solve a problem recursively？</p>
<ol>
<li class="lvl-3">
<p>Subproblem: 定义子问题。是整个范式中最难的部分，有多种方法来辅助定义，后面会详细说明。</p>
</li>
<li class="lvl-3">
<p>Relate: 写出子问题之间的关系，就是写出<strong>状态转移方程</strong>；</p>
</li>
<li class="lvl-3">
<p>Topological Order: 子问题求解的顺序</p>
</li>
<li class="lvl-3">
<p>Base: 边界情况</p>
</li>
<li class="lvl-3">
<p>Original: 通过子问题最终求解出来的原问题</p>
<p>Reconstruct: possibly use parent pointers to recover actual solution, that is,  store parent pointers to reconstruct subsequence.</p>
</li>
<li class="lvl-3">
<p>Time: 算法的时间效率</p>
</li>
</ol>
<p>一个值得注意的常识：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>substring 指的是连续的子序列，如 $(1, 2, 3)$；</p>
<p>遍历一个序列的所有substring的时间复杂度为 $O(n^2)$。显而易见。</p>
</li>
<li class="lvl-2">
<p>subsequence 指的是可以不连续的子序列，任意子元素按照其相对顺序排列即可，如 $(1, 3, 5)$；</p>
<p>遍历一个序列的所有subsequence的时间复杂度为 $O(2^n)$。即对每个元素都要决定其选或者不选。</p>
</li>
</ul>
<h2 id="Subproblem">Subproblem</h2>
<p>A general tool for subproblem design. Good subproblems are:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>prefixes: $x[0\ldots i], \space \Theta(n)$ ；</p>
</li>
<li class="lvl-2">
<p>suffixes: $x[i\ldots n], \space \Theta(n)$；</p>
</li>
<li class="lvl-2">
<p>substring: $x[i\ldots j], \space \Theta(n^2)$。</p>
</li>
</ul>
<p>Subproblems for <strong>multiple inputs</strong> (多个输入，比如LCS有两个字符串作为输入): multiply subproblem spaces - get the product. (二维DP)</p>
<h3 id="Subproblem-Expansion-Constraints">Subproblem Expansion &amp; Constraints</h3>
<h2 id="Relate">Relate</h2>
<blockquote>
<p>How to relate subproblem solutions ?</p>
</blockquote>
<h2 id="Examples">Examples</h2>
<h3 id="Bowling">Bowling</h3>
<h3 id=""></h3>
<h2 id="分类">分类</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>338 Counting Bits 比特位计数 (Easy)</p>
<p>详见<a href="##%E4%BD%8D%E8%BF%90%E7%AE%97">位运算部分</a>。</p>
</li>
<li class="lvl-2">
<p><em>42 Trapping Rain Water 接雨水 (Hard)</em></p>
<p>首先思考朴素暴力解法：对每一个位置，寻找其左侧与右侧的最高点，取二者中的较小者减去当前位置的高度即为此处能接的雨水。如果该值小于当前高度，则此处无法接住雨水。</p>
<ol>
<li class="lvl-5">
<p>动态规划</p>
<p>显然，从每个点往左右两侧搜索最高点时，存在大量的重复计算与搜索。显然可以通过动态规划来进行优化。重点在于要进行两次dp，其中左侧最大值使用prefix前缀子问题，右侧最大值使用suffix后缀子问题，此处以前缀为例，后缀类似：</p>
<ul class="lvl-4">
<li class="lvl-7">
<p><strong>Subproblem:</strong> $left(i)$, 表示下标从 $0 \sim i$ 中的最大值；</p>
</li>
<li class="lvl-7">
<p><strong>Relate:</strong> $left(i) = max{left(i - 1), height(i)}, 0 &lt; i &lt; n$</p>
</li>
<li class="lvl-7">
<p><strong>Topological Order:</strong> Increasing $i$</p>
</li>
<li class="lvl-7">
<p><strong>Base:</strong> $left(0) = height(0)$</p>
</li>
<li class="lvl-7">
<p><strong>Original Problem:</strong> $left(n - 1)$</p>
</li>
<li class="lvl-7">
<p><strong>Time:</strong> 共$n$个子问题，每个子问题常数运算时间，共$\Theta(n)$。</p>
</li>
</ul>
</li>
<li class="lvl-5">
<p>单调栈</p>
<p>单调栈维护的是一个局部区域的解，不像朴素解法和动态规划对一个位置进行计算。</p>
<p>栈中维护一个 $left$ 位置作为左侧边界，根据下标计算出区域宽度，再通过具体值得到区域高度，宽乘上高即为能够接到雨水的量。</p>
<p>具体实现较复杂，结合代码理解，整体效率与动态规划一致，但思路明显不如动态规划解法清晰。</p>
</li>
<li class="lvl-5">
<p>双指针 基于动态规划的解法进行空间复杂度优化</p>
<p>每一个点处能接多少雨水显然由 $min{leftMax, rightMax}$ 来决定。我们使用双指针从两侧向内收入，指针的移动根据两侧维护的最大值而定：当 $leftMax$ 小于 $rightMax$ 时，说明 $left$ 指针处的雨水量由 $leftMax$ 来决定，即此位置的雨水量为 $leftMax - height[left]$。同时将 $right$ 指针向左移动（直至 $rightMax$ 小于 $leftMax$）；反之同理，即哪一侧的最大值更小，哪一侧就将指针继续移动。</p>
<p>双指针也是按位置进行处理，具体过程结合代码进行更深入的理解。</p>
<p>该解法为综合最优解法，其空间复杂度优化至 $O(1)$。</p>
</li>
</ol>
</li>
</ul>
<h4 id="LCS">LCS</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>1143 Longest Common Subsequence 最长公共子序列 (Medium)</p>
</li>
</ul>
<h4 id="LIS">LIS</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>300 Longest Increasing Subsequence 最长递增子序列 (Medium)</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>解法一：DP</p>
<ul class="lvl-4">
<li class="lvl-6">
<p>Subproblems: 采取prefixes，$dp[i]$ 代表以 <code>s[i]</code>字符为结尾（包括该字符）的前缀的LIS最大长度；</p>
</li>
<li class="lvl-6">
<p>Relate: $dp[i]=1 + max{dp[j]\space | \space 0\leq j &lt; i, s[j] &lt; s[i]} \cup {0}$</p>
<p>其中0代表没有比 $s[i]$ 更小的字符。</p>
</li>
<li class="lvl-6">
<p>Topological order: Increasing $i$</p>
</li>
<li class="lvl-6">
<p>Base Case: $dp[0] = 1$</p>
</li>
<li class="lvl-6">
<p>Original Problem: $ans = max{dp[i], \space 0\leq i \leq n - 1}$</p>
</li>
<li class="lvl-6">
<p>Time:</p>
<ol>
<li class="lvl-9">$O(n)$ - subproblems 子问题个数</li>
<li class="lvl-9">$O(n)$ - 每个子问题的运算时长</li>
</ol>
<p>二者嵌套，总时间复杂度为 $O(n^2)$，再加上最终遍历状态数组时的线性时间，复杂度仍为平方级。</p>
</li>
</ul>
</li>
<li class="lvl-4">
<p>解法二：贪心 + 二分查找</p>
<p>比较明显的贪心思路，易于模拟：如果我们要使上升子序列尽可能的长，则我们需要让序列上升得尽可能慢，因此我们希望每次在上升子序列最后加上的那个数尽可能的小。</p>
</li>
</ul>
</li>
</ul>
<h2 id="空间压缩">空间压缩</h2>
<p><code>dp[i]</code>仅与<code>dp[i - 1]</code>和<code>dp[i - 2]</code>相关</p>
<p>重叠子问题</p>
<p>子问题状态记录 避免重复计算</p>
<p>最优子结构</p>
<p>状态转移方程  边界  从边界出发，自底向上</p>
<p>无后效性</p>
<hr>
<h2 id="最长不下降子序列-Longest-Increasing-Subsequence">最长不下降子序列 Longest Increasing Subsequence</h2>
<h2 id="最长递增子序列">最长递增子序列</h2>
<p>对于子序列问题，第二种动态规划方法是，定义一个 dp 数组，其中 dp[i] 表示到位置 i 为止的子序列的性质，并不必须以 i 结尾。这样 dp 数组的最后一位结果即为题目所求，不需要再对每 个位置进行统计。</p>
<h2 id="Misc-2">Misc.</h2>
<p>题目：</p>
<p>斐波那契/上楼梯</p>
<p>树塔</p>
<h1>位运算</h1>
<blockquote>
<p>比较吃技巧，最好临面试前重新熟悉一遍，代码量小，吃思路。</p>
</blockquote>
<p>常用位运算技巧：</p>
<ol>
<li class="lvl-3">
<p><code>n &amp; (n - 1)</code> : 去除n的位级表示中最低的那一位，即<em>去除掉最低的那一个1</em>；该算法常称为Brain Kernighan算法。</p>
</li>
<li class="lvl-3">
<p><code>n &amp; (-n)</code> : 得到n的位级表示中最低的哪一位，即<em>保留最后一个1</em>；</p>
</li>
<li class="lvl-3">
<p><code>x &amp; 1</code> / <code>x % 2</code> : <em>获取x的最低位</em>（掩码操作）。</p>
</li>
<li class="lvl-3">
<p>异或全1：<em>翻转二进制位</em>；</p>
</li>
</ol>
<p>常用的位运算符号有：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>^</code> : 按位异或</p>
<ul class="lvl-2">
<li class="lvl-4"><em>异或全1：翻转二进制位；</em></li>
<li class="lvl-4">异或全0：不变；</li>
<li class="lvl-4">异或本身：全部置0；</li>
</ul>
</li>
<li class="lvl-2">
<p><code>&amp;</code> : 按位与</p>
<ul class="lvl-2">
<li class="lvl-4">与全1：不变；</li>
<li class="lvl-4">与全0：全部置0；</li>
<li class="lvl-4">与本身：不变；</li>
</ul>
</li>
<li class="lvl-2">
<p><code>|</code> : 按位或</p>
<ul class="lvl-2">
<li class="lvl-4">或全1：全部置1；</li>
<li class="lvl-4">或全0：不变；</li>
<li class="lvl-4">或本身：不变；</li>
</ul>
<p>以上三个为二元操作符，与全0、全1、本身的操作结果要熟记（掩码操作）。</p>
</li>
<li class="lvl-2">
<p><code>~</code> : 按位取反</p>
</li>
<li class="lvl-2">
<p><code>&lt;&lt;</code> / <code>&gt;&gt;</code> : 左移与右移，逻辑移位还是算术移位要根据操作数类型来判断。</p>
</li>
<li class="lvl-2">
</li>
</ul>
<h2 id="位运算分治">位运算分治</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>190 Reverse Bits 颠倒二进制位 (Easy)</p>
</li>
<li class="lvl-2">
<p>231 Power of Two 2的幂 (Easy)</p>
</li>
<li class="lvl-2">
<p>342 Power of Four 4的幂 (Easy)</p>
</li>
</ul>
<h2 id="位哈希">位哈希</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>318 Maximum Product of Word Lengths 最大单词长度乘积 (Medium)</strong></p>
<ol>
<li class="lvl-5">第一个重点在于：对每个单词使用<strong>位哈希</strong>，即一个整数的26个二进制位分别对应是否存在该字母，则两个不具有公共字母的位哈希相与结果必为0，反之结果不为0；</li>
</ol>
<ul class="lvl-2">
<li class="lvl-4">
<p>第二个重点在于：引入<strong>哈希表</strong>。第一反应是从字符串<code>string</code>到位掩码<code>int</code>的哈希，但是这样还要对字符串数组进行一个$O(n^2)$的循环查询，还可以进一步优化；</p>
</li>
<li class="lvl-4">
<p>第三个重点就是最后一步的优化，直接<strong>构造从位掩码到字符串最大长度的掩码</strong>。这里统计最大长度是因为有可能有相同的字符构成，但是长度不一样的情况，即出现重复字符的情况。</p>
</li>
</ul>
</li>
</ul>
<h2 id="其他-3">其他</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>461 Hamming Distance 汉明距离 (Easy)</p>
<p>可以使用内置函数，直接计算二进制表达中1的数量。C++中为<code>__builtin_popcount(x)</code>。</p>
</li>
<li class="lvl-2">
<p><strong>338 Counting Bits 比特数计位 (Easy)</strong></p>
<ul class="lvl-2">
<li class="lvl-4">
<p>解法一：利用位运算统计；</p>
<p>使用<code>n &amp; (n - 1)</code>的技巧来统计1的个数，该操作复杂度为$O(logn)$，故总体的时间复杂度为<code>O(nlogn)</code>。</p>
</li>
<li class="lvl-4">
<p>解法二：使用内置函数<code>__builtin_popcount(x)</code>；</p>
</li>
<li class="lvl-4">
<p>解法三：使用<strong>动态规划</strong>；</p>
<p>在使用位运算技巧解题的时候就发现，从小到大1的数量和位置是有一定规律的，联想到使用一维状态转移方程来求解。时间复杂度优化至$O(n)$。</p>
</li>
</ul>
</li>
<li class="lvl-2">
<p>268 Missing Number 丢失的数字 (Easy)</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>解法一：给定了$n$，可以通过$\frac{n*(n+1)}{2}$来得到总和，减去数组内的加和即可得到结果；</p>
</li>
<li class="lvl-4">
<p>解法二：要求线性复杂度（没要求一次扫描，该方法需要两次扫描）+原地，使用位运算技巧来求和；</p>
<p>第一轮对数组内所有值进行异或，第二轮对$0-n$之间所有值异或，除了缺失的数之外，其他值都出现了两次。</p>
</li>
</ul>
</li>
<li class="lvl-2">
<p>693 Binary Number with Alternating Bits 交替位二进制数 (Easy)</p>
<p>交替位二进制数右移一位后异或其本身能够得到低位的全1，再加1后整个二进制表示只有一个1。</p>
<p>判断此时二进制位表示是否只有一个1即可。</p>
</li>
<li class="lvl-2">
<p><strong>476 Number Complement 数字的补数 (Easy)</strong></p>
<p>按照题目中补数的定义，即将二进制位翻转，根据位运算常见技巧，立马反应构造全1的掩码进行异或。从而题目转变为如何构造出不带前导零的指定位数的全1掩码。</p>
</li>
<li class="lvl-2">
<p>136 Single Number 只出现一次的数字 (Easy)</p>
</li>
<li class="lvl-2">
<p><strong>137 Single Number II 只出现一次的数字 (Medium)</strong></p>
<p>题目中每个数字都出现了三次，只有一个例外只出现了一次。</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>解法一：挨个位处理，统计每个位上数组中所有元素为1的个数，将个数模3即可得到该位答案。</p>
<p>时间复杂度达到 $O(nlogC)$，其中$C$是位数，即32。</p>
</li>
<li class="lvl-4">
<p>解法二：利用<strong>数字电路</strong>中的<strong>状态机</strong>，书写真值表来实现并行处理32个位。具体见题解，不是很复杂的解法。</p>
</li>
</ul>
</li>
<li class="lvl-2">
<p><strong>260 Single Number III 只出现一次的数字 III (Medium)</strong></p>
<p>题目中每个数字都出现了两次，只有两个例外只出现了一次。</p>
<ol>
<li class="lvl-5">
<p>首先，根据线性时间复杂度和原地处理的条件可得，使用位运算技巧解题；</p>
</li>
<li class="lvl-5">
<p>将整个数组异或之后得到的是两个目标值的异或之和，重点考虑如何该结果分开得到两个结果值；</p>
</li>
<li class="lvl-5">
<p>考虑到136题中的技巧，试图通过<strong>分组</strong>来将题目退化成136题的情况，重点在于如何分组；</p>
</li>
<li class="lvl-5">
<p>分组的方式为，取异或结果中的<strong>最后一个1</strong>（通过）来区分，那么两个不一样的值必定会分到两个不同的组中，对两组分别进行异或求和即可。</p>
</li>
</ol>
</li>
</ul>
<h1>数据结构设计</h1>
<blockquote>
<p>考察更加多元化，对于实际需求进行设计，锻炼思维，重要部分。</p>
</blockquote>
<h2 id="LRU-Cache">LRU Cache</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><em>146 LRU Cache LRU 缓存 (Medium)</em></p>
<p>重点在于存取操作要实现O(1)的时间复杂度，所以引入<strong>哈希表</strong>。</p>
<p>题目的另一特色在于自己实现一个<strong>双链表</strong>。</p>
</li>
</ul>
<h2 id="LFU-Cache">LFU Cache</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><em>460 LFU Cache LFU缓存 (Hard)</em></p>
</li>
</ul>
<h2 id="Misc-3">Misc.</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>225 用队列实现栈 Implement Stack Using Queues (Easy)</p>
</li>
<li class="lvl-2">
<p><strong>380 Insert Delete GetRandom O(1) O(1)时间插入、删除和获取随机元素 (Medium)</strong></p>
<p>题目要求：三种操作，插入、删除和获取随机元素都要在常数级时间内完成，获取随机元素要保证每个元素被取到的概率相同。</p>
<p>设计思路：</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>对于插入和删除的O(1)实现，显然会想到哈希表（<code>unordered_set</code>），但是哈希表没有随机存取的能力（没有索引，迭代器是线性移动的），无法在常数时间内获取随机元素；</p>
</li>
<li class="lvl-4">
<p>分析【获取随机元素】这一操作的本质，实际上就是要对元素增加索引。实质上是对索引进行随机选取，所以只能引入**列表（<code>vector</code>）**才能满足有索引的随机存取；</p>
<p>另一个想法是使用带映射的哈希表<code>unordered_map</code>，但key单向指向value的映射会导致无法实现常数级增删，所以没有意义。</p>
</li>
<li class="lvl-4">
<p>使用<code>vector</code>还想要进行常数级增删是需要一些设计的：</p>
<p>首先无论是插入还是删除，都要先搜索容器内是否存在当前待操作元素，搜索操作意味着仅通过列表是无法常数时间实现的。想要在常数时间内定位到特定元素可以引入<strong>字典</strong>，就是一个value指向key的哈希表，从而在O(1)时间内获取待查元素的索引。</p>
<ul class="lvl-4">
<li class="lvl-6">
<p>插入：只要有了字典，很轻松就能在常数时间内实现；</p>
</li>
<li class="lvl-6">
<p>删除：如果直接删除，必定涉及到字典内容的修改，从而退化为线性时间复杂度。为了避免对字典内容的修改，我们每次删除都对<strong>末尾元素</strong>进行删除，从而避免对前面元素的字典修改。</p>
<p>所以实际操作为：</p>
<ul class="lvl-6">
<li class="lvl-8">
<p>首先将当前待删元素的值与列表最后一个元素的值相交换；</p>
</li>
<li class="lvl-8">
<p>删除列表中最后一个元素；</p>
</li>
<li class="lvl-8">
<p>修改字典内容。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-2">
<p>432 All O`one Data Structure 全O(1)的数据结构 (Hard)</p>
<p>思路见题解，属于比较复杂的题目，了解即可。理解其设计过程中的重点，捋清楚思路。</p>
</li>
</ul>
<h1>数学问题</h1>
<h2 id="几何问题">几何问题</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><em>149 Max Points on a Line 直线上最多的点数(Hard)</em></p>
<p>详见[哈希表部分](##哈希表 Hash)。</p>
</li>
</ul>
<h2 id="GCD">GCD</h2>
<p>使用欧几里得法（辗转相除法）求最大公约数（Greatest Common Divisor）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> b ? <span class="hljs-built_in">gcd</span>(b, a % b) : a;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="丑数-Ugly-Number">丑数 Ugly Number</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>263 Ugly Number 丑数 (Easy)</p>
<p>根据其数学定义解题：只要能整除2、3、5之一，就不断三个挨个整除，直至最后三者都不能整除。</p>
<p>如果最后剩下的值不是1，则剩下的值即为2、3、5之外的质数，说明不是丑数。即最终返回值为1时就是丑数。</p>
</li>
<li class="lvl-2">
<p>264 Ugly Number II 丑数 II (Medium)</p>
<p>如果 $k$ 是丑数, 那么 $k * 2$，$k * 3$， $k * 5$ 都是丑数.<br>
因此我们只需要维护一个最小堆，每次将 $k * 2$，$k * 3$， $k * 5$ 送入堆中，然后出堆的第一个元素，统计count数，直到<code>count=n</code>。</p>
</li>
</ul>
<h1>实用数据结构与算法</h1>
<h2 id="区间信息的维护与查询">区间信息的维护与查询</h2>
<p>关注有关区间信息的一些列操作：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>静态操作：</p>
<p>单点查询、前缀和查询、区间和查询、范围最值查询（Range Minimum Query, RMQ）；</p>
</li>
<li class="lvl-2">
<p>动态操作：</p>
<p>单点修改、区间修改，以及修改后的所有查询问题。</p>
</li>
</ul>
<p>以上这些问题，在不同使用场景下灵活使用以下的不同数据结构。</p>
<h3 id="前缀和与积分图-2">前缀和与积分图</h3>
<blockquote>
<p>适合没有值修改的<strong>静态</strong>数组使用。</p>
<p>前缀和针对一维的数组，积分图针对二维的数组，二者都是进行打表存储区间和，加速查询。</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>303 Range Sum Query - Immutable 区域和检索 - 数组不可变 (Easy)</p>
<p><strong>静态</strong>数组 + <strong>前缀和</strong>查询：简单的统计前缀和即可，只有初始化操作复杂度为 $O(n)$，每次查询都是 $O(1)$，$n$次操作的均摊时间复杂度为 $O(1)$。</p>
<p>一个值得注意的技巧是 <code>partial_sum</code> 函数，能够一行代码计算出数组的前缀和。</p>
<p>该函数详情见：<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/algorithm/partial_sum">std::partial_sum - cppreference.com</a></p>
</li>
<li class="lvl-2">
<p>304 Range Sum Query 2D - Immutable 二维区域和检索 - 矩阵不可变 (Medium)</p>
<p>静态二维数组 + <strong>积分图</strong>查询：仔细注意积分图的求解逻辑即可。</p>
</li>
<li class="lvl-2">
<p><em>560 Subarray Sum Equals K 和为K的子数组 (Medium)</em></p>
<p>首先明确一个概念，这里的subarray即substring，是<strong>连续的子序列</strong>（区分于 subsequence），全部枚举出来的复杂度为$O(n^2)$。</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>解法一：枚举</p>
<p>即枚举两侧边界，全部枚举的复杂度为$O(n^2)$。枚举的过程中对子数组的和进行加减，这样每次枚举的耗费为$O(1)$，所以总的复杂度为 $O(n^2)$。</p>
</li>
<li class="lvl-4">
<p><strong>解法二：前缀和 + 哈希表</strong>的优化。比较巧的解法，需要背一背。</p>
</li>
</ul>
<p>一些思路和坑：</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>滑动窗口：因为数组中存在负值，所以没办法确定两侧指针谁来移动。如果全部是正值，则可以使用滑动窗口一次扫描完成；</p>
</li>
</ul>
</li>
<li class="lvl-2">
<p>437 Path Sum III 路径总和 III (Medium)</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>解法一：穷举，见<a href="###%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92">二叉树部分</a>。</p>
</li>
<li class="lvl-4">
<p>解法二：前缀和+先序遍历+回溯</p>
<p>二叉树中的前缀和：树中每条自顶向下的路径也是唯一的，实际上也是一个一维的前缀和问题。</p>
</li>
</ul>
</li>
<li class="lvl-2">
<p><strong>467 Unique Substrings in Wraparound String 环绕字符串中唯一的子字符串 (Medium)</strong></p>
<ul class="lvl-2">
<li class="lvl-4">统计以每种字母为结尾的最长连续子串即可，最大值即为其对最终答案的贡献（自动去重）；</li>
<li class="lvl-4">最终对所有字母的贡献求和即可，即前缀和的思想。</li>
</ul>
</li>
</ul>
<h3 id="树状数组-BIT-2">树状数组 BIT</h3>
<blockquote>
<p>又称二叉索引树（Binary Indexed Tree）、Fenwick树（发明者的命名）。</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>适用场景及性能分析</p>
<p>适用于<strong>点更新</strong>后的<strong>前缀和查询</strong>、<strong>区间和查询</strong>：</p>
<ul class="lvl-3">
<li class="lvl-4">
<p>点更新：树状数组 $O(logn)$，普通数组 $O(1)$；</p>
</li>
<li class="lvl-4">
<p>前缀和/区间和查询：树状数组 $O(logn)$，普通数组 $O(n)$。</p>
</li>
</ul>
<p>并<em>不</em>适用于<strong>点查询</strong> 以及 <strong>区间更新</strong>：</p>
<ul class="lvl-3">
<li class="lvl-4">
<p>点查询：普通数组只要 $O(1)$，树状数组需要 $O(logn)$；</p>
</li>
<li class="lvl-4">
<p>区间更新：普通数组 $O(n)$，树状数组 $O(nlogn)$。</p>
</li>
</ul>
</li>
<li class="lvl-2">
<p>常见应用：求解逆序对数（剑指offer 51）</p>
</li>
</ul>
</blockquote>
<h4 id="引入-2">引入</h4>
<p>通过引入树状数组维护前缀和，能够使单点修改和区间和计算都达到$O(logn)$，即树高。</p>
<p>树状数组巧妙地利用了下标的二进制位特性，所以这里用到了一个重要的位运算操作，定义为 $lowbit(x)$，即保留最低有效位（最低的一个1）后的值。</p>
<h4 id="定义-5">定义</h4>
<p>首先来看树状数组的特征与含义：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>含义：维护一组树状区间和数组 $bit[i]$ ，其包含的区间和范围为$[i - lowbit[i] + 1,\space i]$，即<strong>以 $i$ 为左边界，长度为 $lowbit[i]$ 的区间</strong>。即 $bit_i = \sum \limits^{i} <em>{j=i-lowbit(i)+1}A</em>{j}$。如图所示。</p>
</li>
<li class="lvl-2">
<p>特征：</p>
<ul class="lvl-2">
<li class="lvl-4">每一层节点的 $lowbit$ 值都是相同的。且 $lowbit$ 从树叶向上到根，越靠近根值越大；</li>
<li class="lvl-4">值得注意的是，树状数组因为借助了二进制位的性质，其下标是从1开始的。</li>
</ul>
</li>
</ul>
<img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202204241054724.png" srcset="/img/loading.gif" lazyload style="zoom: 33%;" />
<ul class="lvl-0">
<li class="lvl-2">
<p>效率：</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>单点修改：如图黄色轨迹所示，向上的下标变3换为 $i+ lowbit[i]$ ；</p>
</li>
<li class="lvl-4">
<p>求区间和：如图灰色轨迹所示，向上的下标变换为 $i - lowbit[i]$ ；</p>
<p>时间复杂度显然均为树的高度；</p>
</li>
</ul>
</li>
</ul>
<p>具体实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*--</span><br><span class="hljs-comment">	a[i] 	: 0 &lt;= i &lt; n</span><br><span class="hljs-comment">	bit[i]	: 0 &lt; i &lt;= n </span><br><span class="hljs-comment">--*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BIT</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; bit;<br>    <span class="hljs-type">int</span> size;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">BIT</span>(<span class="hljs-type">int</span> n) : <span class="hljs-built_in">size</span>(n), <span class="hljs-built_in">tree</span>(n + <span class="hljs-number">1</span>) &#123;&#125;<br>    <br>    <span class="hljs-type">int</span> lowbit（<span class="hljs-type">int</span> x) &#123;							<span class="hljs-comment">// 求lowbit就是位运算中保留最低有效位</span><br>        <span class="hljs-keyword">return</span> x &amp; (-x);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            bit[i] = a[i - <span class="hljs-number">1</span>];		<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> index = i - <span class="hljs-number">1</span> - <span class="hljs-number">1</span>; i &gt;= i - <span class="hljs-built_in">lowbit</span>(i); i--) &#123;	<span class="hljs-comment">// 长度为 lowbit[i] 的区间</span><br>                bit[i] += a[index];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> val)</span> </span>&#123;				<span class="hljs-comment">// 将第index个元素的值修改为x</span><br>        <span class="hljs-type">int</span> diff = val - a[index + <span class="hljs-number">1</span>];<br>        <br>        <span class="hljs-keyword">while</span>(index &lt;= n) &#123;<br>            bit[index] += diff;<br>            index += <span class="hljs-built_in">lowbit</span>(index);<br>        &#125;<br>      <br>        <span class="hljs-comment">// for(int i = index; i &lt;= n; i += lowbit(i)) &#123;</span><br>        <span class="hljs-comment">//     bit[i] += diff;</span><br>        <span class="hljs-comment">// &#125;</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">prefix_sum</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> </span>&#123;							<span class="hljs-comment">// 查询前k项和</span><br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = k; i &gt; <span class="hljs-number">0</span>; i -= lowbit[i]) &#123;<br>            sum += bit[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">range_sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;					<span class="hljs-comment">// 查询[a, b]的区间和（左闭右闭）</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">prefix_sum</span>(b) - <span class="hljs-built_in">prefix_sum</span>(a - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h4 id="相关题目-6">相关题目</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><em>剑指Offer 51. 数组中的逆序对 (Hard)</em></p>
<blockquote>
<p>首先，按照逆序对的定义，来统计数组中的逆序对的方法有两种形式：</p>
<ul class="lvl-3">
<li class="lvl-2">统计每一位的前面有几个更大的元素；</li>
<li class="lvl-2">统计每一位的后面有几个更小的元素；</li>
</ul>
<p>二者本质一样，按照具体解题方法来选择即可。</p>
<p>第一反应的暴力解法使用两种形式均可，两层循环达到$O(n^2)$级别复杂度（上限也就5000），题目中50000规模的输入显然会TLE。</p>
</blockquote>
<p>逆序对数有两种常见的优化解法：</p>
<ul class="lvl-2">
<li class="lvl-4">
<p><em>解法一：桶 + 树状数组 + 数组离散化</em></p>
<ul class="lvl-4">
<li class="lvl-6">
<p>基本思想是【<strong>建桶</strong>】来统计每个元素出现的次数，则该桶的<strong>前缀和</strong>即为小于该元素的元素数量。</p>
</li>
<li class="lvl-6">
<p>考虑到前缀和给出的是更小的元素的数量，我们选择第二种形式统计，即统计每一位的后面有几个更小的元素：</p>
<p>下标就要从大到小进行循环，对每个位置的值对应的桶自增一，并统计当前桶的前缀和（即已经处理过的、后面的更小元素值的数量）。</p>
<p>反复计算前缀和/区间和问题显然可以使用树状数组来进行优化。</p>
</li>
<li class="lvl-6">
<p>同时在空间上，因为元素的值可能非常大，因此对最大值进行建桶会导致空间利用率低，且内存可能并不足够。对于这种<strong>稀疏且只关心相对大小</strong>的桶，可以使用<strong>离散化</strong>来增加空间利用率。</p>
<p>离散化就是将数组内元素排序，按照大小分配成从 1 到 $n$的值。具体实现如下：</p>
<ol>
<li class="lvl-9">
<p>复制一个一模一样的临时数组，并对其进行排序 — 耗费 $O(nlogn)$</p>
</li>
<li class="lvl-9">
<p>从前往后对原数组每个位置进行访问，利用二分查找在临时数组中查找其排序后的位置，并利用该位置修改其值。</p>
</li>
</ol>
</li>
</ul>
</li>
<li class="lvl-4">
<p>解法二：归并排序</p>
<p>归并排序每一次合并的时候，观察左右两个子序列 $[l_1, \space r_1], [l_2, \space r_2]$：</p>
<p>每次 $lPtr$ 右移的时候，统计一次 $rPtr - l_2 + 1$ ，即当前已经合并过的右侧元素均为比当前 $lPtr$ 元素小的值，但它们在原始序列中为右侧部分，即在该位后面的更小元素，所以就能得到当前位贡献的逆序对数。</p>
<p>同理，每次在 $rPtr$ 右移的时候，$[lPtr, mid]$ 这部分元素是比 $nums[rPtr]$ 更大，但在其左侧的元素，即在该位前面的更大元素，也可获得当前位贡献的逆序对数。</p>
<p>两种方式取任意都可，第二种的代码相对简洁。</p>
<img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202204261027731.png" srcset="/img/loading.gif" lazyload style="zoom: 50%;" />
</li>
</ul>
</li>
<li class="lvl-2">
<p>315 计算右侧小于当前元素的个数 (Hard)</p>
<p>跟剑指offer51一模一样的题目，换个形式而已。</p>
</li>
</ul>
<h3 id="线段树-Segment-Tree-2">线段树 Segment Tree</h3>
<blockquote>
<p>线段树基于分治思想，将区间不断进行二分，可以维护区间的多种信息，如<strong>区间和</strong>、<strong>区间最值</strong>等等</p>
</blockquote>
<h4 id="定义-6">定义</h4>
<p>线段树（Segment Tree）是一个基于分治思想的二叉树：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>每个非叶节点对应一个区间，并存储对应的该区间信息；</p>
</li>
<li class="lvl-2">
<p>每个左右孩子节点二分父节点的区间；</p>
</li>
<li class="lvl-2">
<p>对于节点区间$[l,r]$而言，所有叶节点代表所有的单个元素，及$l=r$的情况。</p>
</li>
</ul>
<p>树的具体结构与定义如图所示（以维护区间最值为例）：</p>
<p><img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205011625893.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h4 id="存储方式-2">存储方式</h4>
<p>据上可得，线段树除了最后一层，其他上层均为满二叉树，选用顺序存储方式，用数组来存放这颗树，下标从1开始。</p>
<p>值得注意的是，该数组开辟的大小与输入规模 $n$ 的关系应该是怎样的：</p>
<img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205011711572.png" srcset="/img/loading.gif" lazyload style="zoom:33%;" />
<p>根据图上可得：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>规定数组总大小为 $N$，则 $N=n_0 + n_2 + n_{blank}$，其中</p>
<p>$n_0 = n$，即输入的 $n$ 个元素均为叶节点；</p>
<p>$n_2 = n_0 - 1 = n - 1$，这是根据二叉树的定义而得；</p>
<p>$n_{blank} = 2n-4$，如图所示。</p>
</li>
<li class="lvl-4">
<p>综上可得，$N = n + (n - 1) + (2n-4) = 4n-5$，即<strong>需要给线段树数组开辟【 $4n$ 】的空间来防止溢出</strong>。</p>
</li>
</ul>
<h4 id="懒标记">懒标记</h4>
<blockquote>
<p>普通的线段树操作适合<strong>单点修改</strong>后的区间信息维护与查询。</p>
<p>而对于 <em>区间修改</em> ，需要引入**懒标记（lazy tag）**来进一步降低时间复杂度。</p>
</blockquote>
<p>首先，懒标记的处理流程如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span> <span class="hljs-keyword">if</span>(目标区间完全覆盖当前区间)			<span class="hljs-comment">// cover!</span><br>       更新区间信息;<br>       对当前节点打上懒标记;<br><span class="hljs-number">2.</span> <span class="hljs-keyword">if</span>(未完全覆盖 &amp;&amp; 存在懒标记)<br>       向下传递懒标记;<br><span class="hljs-number">3.</span> <span class="hljs-keyword">if</span>(左儿子有交集)<br>       向左下进入递归;<br>   <span class="hljs-keyword">if</span>(右儿子有交集)<br>       向右下进入递归；<br></code></pre></td></tr></table></figure>
<p>不加懒标记的单点更新时，需要向下递归搜索至叶节点，并在向上返回的过程中不断完成修改。根据上面的流程可以发现，增加懒标记后，每次向下递归无需搜索至叶节点，而是对被覆盖的区间加一个懒标记后，直接对区间进行修改并增加懒标记。而该节点以下的子节点区间都先不做修改，而是等到<strong>下一次需要访问其子区间时</strong>按需<strong>向下传递懒标记</strong>再进行更改，从而实现效率的提升。同时，由于叶节点无法继续向下传递，可以不对其设置懒标记。</p>
<p>向下递归的过程如图所示（不包含向上返回的过程）：</p>
<p><img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205021237853.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h4 id="效率-2">效率</h4>
<p>任意的查询与更新的单次操作的复杂度都是 $O(logn)$。</p>
<p>增加了懒标记的区间更新的渐进复杂度也为 $O(logn)$。</p>
<h4 id="实现-2">实现</h4>
<h5 id="无懒标记-携带区间范围信息-2">无懒标记 + 携带区间范围信息</h5>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; num;			<span class="hljs-comment">// 原数组，这里假设从下标为1处开始</span><br><span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>(); 					<span class="hljs-comment">// n为输入规模，即元素总个数</span><br><br><span class="hljs-comment">// 结构定义</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    <span class="hljs-type">int</span> l, r, mx;		<span class="hljs-comment">// l，r为区间做右端点，也有不携带区间信息的写法</span><br>    					<span class="hljs-comment">// 区间信息此处以区间最大值为例</span><br>&#125; tree[n * <span class="hljs-number">4</span>];<br><br><span class="hljs-comment">/*--</span><br><span class="hljs-comment">创建线段树：</span><br><span class="hljs-comment">	按照树的定义，递归形式创建</span><br><span class="hljs-comment">--*/</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> root, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    tree[root].l = l;<br>    tree[root].r = r;<br>    <span class="hljs-comment">// recursive base</span><br>    <span class="hljs-keyword">if</span>(l == r) &#123;<br>        tree[root].mx = num[l];<br>    	<span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 向左右儿子进入递归</span><br>    <span class="hljs-type">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>；<br>    <span class="hljs-type">int</span> left = root &lt;&lt; <span class="hljs-number">1</span>, right = root &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">build</span>(left, l, mid);<br>    <span class="hljs-built_in">build</span>(right, mid + <span class="hljs-number">1</span>, r);<br>    <br>    <span class="hljs-comment">// 更新区间信息，此处以更新区间最大值为例</span><br>    tree[root].mx = <span class="hljs-built_in">max</span>(tree[left].mx, tree[right].mx);<br>    <span class="hljs-comment">// tree[root] = push_up(tree[left], tree[right]);</span><br>&#125;<br><br><br><span class="hljs-comment">/*--</span><br><span class="hljs-comment">点更新:</span><br><span class="hljs-comment">	递归寻找目标节点，找到后更改，并向上修改	</span><br><span class="hljs-comment">--*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> root, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>    <span class="hljs-comment">// recursive base</span><br>    <span class="hljs-keyword">if</span>(root.l == root.r &amp;&amp; root.l == index) &#123;<br>   		<span class="hljs-comment">// 更新区间信息，此处以更新区间最大值为例</span><br>        tree[l].mx = val;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 向左右儿子进入递归</span><br>    <span class="hljs-type">int</span> mid = root.l + (root.r - root.l) / <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> left = root &lt;&lt; <span class="hljs-number">1</span>, right = root &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(index &lt;= mid) &#123;<br>        <span class="hljs-built_in">update</span>(left, index, val);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">update</span>(right, index, val);<br>    &#125;<br>    tree[root].mx = <span class="hljs-built_in">max</span>(tree[left].mx, tree[right].mx);<br>&#125;<br><br><span class="hljs-comment">/*--</span><br><span class="hljs-comment">区间信息查询:</span><br><span class="hljs-comment">	1. 区间覆盖式查询</span><br><span class="hljs-comment">	2. 区间相等式查询</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">--*/</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query_cover</span><span class="hljs-params">(<span class="hljs-type">int</span> root, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-comment">// recursive base</span><br>	<span class="hljs-keyword">if</span>(l &lt;= root.l &amp;&amp; root.r &lt;= r) &#123;	<span class="hljs-comment">// 查询区间完全覆盖了当前区间</span><br>        <span class="hljs-keyword">return</span> tree[root].mx;<br>    &#125; <br>    <span class="hljs-type">int</span> mid = root.l + (root.l - root.r) / <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> lmax, rmax;<br>    <span class="hljs-keyword">if</span>(l &lt;= mid) &#123;<br>        lmax = <span class="hljs-built_in">query</span>(root &lt;&lt; <span class="hljs-number">1</span>, l, r);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(r &gt; mid) &#123;<br>        rmax = <span class="hljs-built_in">query</span>(root &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, l, r);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(lmax, rmax);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query_equal</span><span class="hljs-params">(<span class="hljs-type">int</span> root, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-comment">// recursive </span><br>    <span class="hljs-keyword">if</span>(root.l == l &amp;&amp; root.r == r) &#123;<br>        <span class="hljs-keyword">return</span> tree[root].mx;<br>    &#125;<br>    <span class="hljs-type">int</span> mid = root.l + (root.r - root.l) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(r &lt;= mid) &#123;<br>    	<span class="hljs-keyword">return</span> <span class="hljs-built_in">query_equal</span>(root &lt;&lt; <span class="hljs-number">1</span>, l, r);<br>    &#125; <br>    <span class="hljs-keyword">if</span>(l &gt; mid) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">query_equal</span>(root &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, l, r);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">query_equal</span>(root &lt;&lt; <span class="hljs-number">1</span>, l, mid), <span class="hljs-built_in">query_equal</span>(root &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r);<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="带懒标记-携带区间范围信息-2">带懒标记 + 携带区间范围信息</h5>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 此处指定维护的区间信息为区间和</span><br>vector&lt;<span class="hljs-type">int</span>&gt; nums;<br><span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">struct</span>&#123;<br>    <span class="hljs-type">int</span> l, r, sum, lz;<br>&#125;tree[<span class="hljs-number">4</span> * n];<br><span class="hljs-comment">// 维护的区间信息 并 添加懒标记</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">lazy</span><span class="hljs-params">(<span class="hljs-type">int</span> root, <span class="hljs-type">int</span> delta)</span> </span>&#123;<br>    tree[root].sum += val * (tree[root].r - tree[root].l + <span class="hljs-number">1</span>);<br>    tree[root].lz += delta;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> root)</span> </span>&#123;<br>    <span class="hljs-built_in">lazy</span>(root &lt;&lt; <span class="hljs-number">1</span>, tree[root].lz);<br>    <span class="hljs-built_in">lazy</span>(root &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, tree[root].lz);<br>    tree[root].lz = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">range_update</span><span class="hljs-params">(<span class="hljs-type">int</span> root, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> delta)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(l &lt;= tree[root].l &amp;&amp; tree[root].r &lt;= r) &#123;<br>        <span class="hljs-built_in">lazy</span>(root, delta);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 重要：当前区间大于查询区间，意味着要向下访问子区间，此时如果有懒标记，则要向下对子区间进行更新！</span><br>    <span class="hljs-keyword">if</span>(!tree[root].lz) &#123; 		<span class="hljs-comment">// tree[root].lz != 0</span><br>        <span class="hljs-built_in">pushdown</span>(root);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(l &lt;= mid) &#123;<br>        <span class="hljs-built_in">range_update</span>(root &lt;&lt; <span class="hljs-number">1</span>, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> delta);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(r &gt; mid) &#123;<br>        <span class="hljs-built_in">range_update</span>(root &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> delta);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> root, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(l &lt;= tree[root].l &amp;&amp; tree[root].r &lt;= r) &#123;<br>        <span class="hljs-keyword">return</span> tree[root].sum;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!tree[root].lz) &#123;<br>        <span class="hljs-built_in">pushdown</span>(root);<br>    &#125;<br>    <span class="hljs-type">int</span> lsum，rsum;<br>    <span class="hljs-keyword">if</span>(l &lt;= mid) &#123;<br>        lsum = <span class="hljs-built_in">query</span>(root &lt;&lt; <span class="hljs-number">1</span>, l, r);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(mid &lt; r) &#123;<br>        rsum = <span class="hljs-built_in">query</span>(root &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, l, r);<br>    &#125;<br>    <span class="hljs-keyword">return</span> lsum + rsum;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="倍增、ST表、最长公共祖先-LCA、分块-2">倍增、ST表、最长公共祖先 LCA、分块</h3>
<p>出现次数少，按需补全。</p>
<p>分块：几乎可以解决所有<strong>区间更新</strong>和<strong>区间查询</strong>问题，但<strong>效率比线段树差一些</strong>。</p>
<h3 id="相关题目-7">相关题目</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>303 Range Sum Query - Immutable 区域和检索 - 数组不可变 (Easy)</p>
</li>
<li class="lvl-2">
<p>304 Range Sum Query 2D - Immutable 二维区域和检索 - 矩阵不可变(Medium)</p>
</li>
<li class="lvl-2">
<p><em>307 Range Sum Query - Mutable 区域和检索 - 数组可修改 (Medium)</em></p>
<p>典型的使用场景：<strong>单点修改</strong> + <strong>区间和查询</strong></p>
<ul class="lvl-2">
<li class="lvl-4">
<p>解法一：线段树</p>
<p>不存在区间修改，所以无需懒标记。</p>
</li>
<li class="lvl-4">
<p>解法二：树状数组</p>
</li>
<li class="lvl-4">
<p>解法三：分块</p>
<p>未完成，按需补。</p>
</li>
</ul>
</li>
<li class="lvl-2">
<p>308 Range Sum Query 2D - Mutable 二维区域和检索 - 可变 (Hard)</p>
<p>未做，超纲，按需补</p>
</li>
</ul>
<h2 id="网络流">网络流</h2>
<h1>算法合辑</h1>
<blockquote>
<p>一些经典算法的具体实现讲解，对应前面解题用到的。</p>
</blockquote>
<h2 id="Manacher算法">Manacher算法</h2>
<p>比较特殊的算法，要背一下其实现，具体写不写的出其实问题不大。</p>
<blockquote>
<p>给定一个字符串，<strong>求其最长回文子串的长度</strong>。例如：</p>
<ol>
<li class="lvl-3"><code>s=&quot;abcd&quot;</code>，最长回文长度为 1；</li>
<li class="lvl-3"><code>s=&quot;ababa&quot;</code>，最长回文长度为 5；</li>
<li class="lvl-3"><code>s=&quot;abccb&quot;</code>，最长回文长度为 4，即 <code>bccb</code>。</li>
</ol>
<p>以上问题的传统思路大概是，遍历每一个字符，以该字符为中心向两边查找。其时间复杂度为 O(n2)，效率很差。</p>
<p>1975 年，一个叫 Manacher 的人发明了一个算法，<em>Manacher 算法</em>（中文名：<em>马拉车算法</em>），该算法可以把时间复杂度提升到 O(n)。</p>
<p>Manacher 算法依旧需要枚举字符串的每一个位置并先假设它是回文中心，但是它会<strong>利用已经计算出来的状态来更新 <code>p(i)</code></strong>，<strong>而不是向「中心拓展」一样盲目地拓展</strong>。</p>
</blockquote>
<p>算法分为三个重点处理部分：</p>
<h3 id="1-字符串预处理">1 字符串预处理</h3>
<blockquote>
<p>解决奇偶回文分类问题</p>
</blockquote>
<p>由于回文分为偶回文（比如 <code>bccb</code>）和奇回文（比如 <code>bcacb</code>），而在处理奇偶问题上会比较繁琐，所以这里我们使用一个技巧，具体做法是：</p>
<ol>
<li class="lvl-3">
<p>在字符串首尾及每个字符间都插入一个 “#”，这样可以使得原先的奇偶回文都变为奇回文；</p>
</li>
<li class="lvl-3">
<p>接着再在首尾两端各插入 “$” 和 “^”，这样中心扩展寻找回文的时候会自动退出循环，不需每次判断是否越界，可参见下面代码。</p>
</li>
<li class="lvl-3">
<p>上述新插入的三个字符，即 “#”、 “$” 和 “^”，必须各异，且不可以与原字符串中的字符相同。</p>
</li>
</ol>
<p>举个例子：<code>s=&quot;abbahopxpo&quot;</code>，转换为 <code>s_new=&quot;$#a#b#b#a#h#o#p#x#p#o#^&quot;</code>。如此，s 里起初有一个偶回文 <code>abba</code> 和一个奇回文 <code>opxpo</code>，被转换为 <code>#a#b#b#a#</code> 和 <code>#o#p#x#p#o#</code>，长度都转换成了奇数。</p>
<h3 id="2-引入辅助数组">2 引入辅助数组</h3>
<blockquote>
<p>记录每个字符为中心的最长回文半径</p>
</blockquote>
<p>定义一个辅助数组 <code>int p[]</code>，其中 <code>p[i]</code> 表示以 i 为中心的<strong>最长回文的半径</strong>，例如：</p>
<table>
<thead>
<tr>
<th>i</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
<th>12</th>
<th>13</th>
<th>14</th>
<th>15</th>
<th>16</th>
<th>17</th>
<th>18</th>
<th>19</th>
<th>20</th>
<th>21</th>
<th>22</th>
</tr>
</thead>
<tbody>
<tr>
<td>s_new[i]</td>
<td>$</td>
<td>#</td>
<td>a</td>
<td>#</td>
<td>b</td>
<td>#</td>
<td>b</td>
<td>#</td>
<td>a</td>
<td>#</td>
<td>h</td>
<td>#</td>
<td>o</td>
<td>#</td>
<td>p</td>
<td>#</td>
<td>x</td>
<td>#</td>
<td>p</td>
<td>#</td>
<td>o</td>
<td>#</td>
<td>^</td>
</tr>
<tr>
<td>p[i]</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>1</td>
<td>2</td>
<td>5</td>
<td>2</td>
<td>1</td>
<td>2</td>
<td>1</td>
<td>2</td>
<td>1</td>
<td>2</td>
<td>1</td>
<td>2</td>
<td>1</td>
<td>6</td>
<td>1</td>
<td>2</td>
<td>1</td>
<td>2</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>可以看出， <code>p[i] - 1</code> 正好是<strong>原字符串中最长回文串的长度</strong>，因为此时的半径是添加过预处理符号的半径 。</p>
<h3 id="3-求解辅助数组">3 求解辅助数组</h3>
<blockquote>
<p>实现线性复杂度的关键</p>
</blockquote>
<p>接下来的重点就是求解 p 数组，如下图：</p>
<p><img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202112271559574.png" srcset="/img/loading.gif" lazyload alt=""><br>
设置两个变量，mx 和 id 。mx 代表以 id 为中心的最长回文的右边界，也就是 <code>mx = id + p[id]</code>。</p>
<p>假设我们现在求 <code>p[i]</code>，也就是以 i 为中心的最长回文半径，如果 <code>i &lt; mx</code>，如上图，那么：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 求解辅助数组的核心</span><br><span class="hljs-keyword">if</span> (i &lt; mx)  <br>    p[i] = <span class="hljs-built_in">min</span>(p[<span class="hljs-number">2</span> * id - i], mx - i);<br></code></pre></td></tr></table></figure>
<p><code>2 * id - i</code> 为 i 关于 id 的对称点，即上图的 j 点，而 <strong><code>p[j]</code>表示以 j 为中心的最长回文半径</strong>，因此我们可以利用 <code>p[j]</code> 来加快查找。</p>
<p>根据回文的性质，<code>p[i]</code> 的值基于以下三种情况得出：</p>
<p>（1）<strong>j 的回文串有一部分在 id 的之外</strong>，如下图：<img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202112271610871.png" srcset="/img/loading.gif" lazyload alt=""><br>
上图中，黑线为 id 的回文，i 与 j 关于 id 对称，红线为 j 的回文。那么根据代码此时 <code>p[i] = mx - i</code>，即紫线。那么 <code>p[i]</code> 还可以更大么？答案是不可能！见下图：<img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202112271610179.png" srcset="/img/loading.gif" lazyload alt=""><br>
假设右侧新增的紫色部分是 <code>p[i]</code> 可以增加的部分，那么根据回文的性质，a 等于 d ，也就是说 id 的回文不仅仅是黑线，而是黑线+两条紫线，矛盾，所以假设不成立，故 <code>p[i] = mx - i</code>，不可以再增加一分。</p>
<p>（2）<strong>j 回文串全部在 id 的内部</strong>，如下图：<img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202112271610855.png" srcset="/img/loading.gif" lazyload alt=""><br>
根据代码，此时 <code>p[i] = p[j]</code>，那么 <code>p[i]</code> 还可以更大么？答案亦是不可能！见下图：<img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202112271610897.png" srcset="/img/loading.gif" lazyload alt=""><br>
假设右侧新增的红色部分是 <code>p[i]</code> 可以增加的部分，那么根据回文的性质，a 等于 b ，也就是说 j 的回文应该再加上 a 和 b ，矛盾，所以假设不成立。故 <code>p[i] = p[j]</code>，也不可以再增加一分。</p>
<p>（3）<strong>j 回文串左端正好与 id 的回文串左端重合</strong>，见下图：<img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202112271611950.png" srcset="/img/loading.gif" lazyload alt=""><br>
根据代码，此时 <code>p[i] = p[j]</code> 或 <code>p[i] = mx - i</code>，并且 <code>p[i]</code> 还可以继续增加，所以需要</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span> (s_new[i - p[i]] == s_new[i + p[i]]) <br>    p[i]++;<br></code></pre></td></tr></table></figure>
<h4 id="代码">代码</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">char</span> s[<span class="hljs-number">1000</span>];<br><span class="hljs-type">char</span> s_new[<span class="hljs-number">2000</span>];<br><span class="hljs-type">int</span> p[<span class="hljs-number">2000</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> len = <span class="hljs-built_in">strlen</span>(s);<br>    s_new[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;$&#x27;</span>;<br>    s_new[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;#&#x27;</span>;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>        s_new[j++] = s[i];<br>        s_new[j++] = <span class="hljs-string">&#x27;#&#x27;</span>;<br>    &#125;<br>    s_new[j++] = <span class="hljs-string">&#x27;^&#x27;</span>;  <span class="hljs-comment">// 别忘了哦</span><br>    s_new[j] = <span class="hljs-string">&#x27;\0&#x27;</span>;   <span class="hljs-comment">// 这是一个好习惯</span><br>    <span class="hljs-keyword">return</span> j;  <span class="hljs-comment">// 返回 s_new 的长度</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Manacher</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> len = <span class="hljs-built_in">Init</span>();  <span class="hljs-comment">// 取得新字符串长度并完成向 s_new 的转换</span><br>    <span class="hljs-type">int</span> max_len = <span class="hljs-number">-1</span>;  <span class="hljs-comment">// 最长回文长度</span><br>    <span class="hljs-type">int</span> id;<br>    <span class="hljs-type">int</span> mx = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; mx)<br>            p[i] = <span class="hljs-built_in">min</span>(p[<span class="hljs-number">2</span> * id - i], mx - i);  <br>        	<span class="hljs-comment">// 需搞清楚上面那张图含义，mx 和 2*id-i 的含义</span><br>        <span class="hljs-keyword">else</span><br>            p[i] = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span> (s_new[i - p[i]] == s_new[i + p[i]])  <span class="hljs-comment">// 不需边界判断，因为左有 $，右有 ^</span><br>            p[i]++;<br>        <span class="hljs-comment">// 我们每走一步 i，都要和 mx 比较，我们希望 mx 尽可能的远，</span><br>        <span class="hljs-comment">// 这样才能更有机会执行 if (i &lt; mx)这句代码，从而提高效率</span><br>        <span class="hljs-comment">// 更新 mx</span><br>        <span class="hljs-keyword">if</span> (mx &lt; i + p[i]) &#123;<br>            id = i;<br>            mx = i + p[i];<br>        &#125;<br>        max_len = <span class="hljs-built_in">max</span>(max_len, p[i] - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> max_len;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入字符串：&quot;</span>)) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, s);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;最长回文长度为 %d\n\n&quot;</span>, <span class="hljs-built_in">Manacher</span>());<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="算法复杂度分析">算法复杂度分析</h3>
<p>根据（1）（2）（3），很容易推出 Manacher 算法的最坏情况，即为字符串内全是相同字符的时候。在这里我们重点研究 <code>Manacher()</code> 中的 for 语句，推算发现 for 语句内平均访问每个字符 5 次，即时间复杂度为：$T_{worst}(n)=O(n)$</p>
<p>同理，我们也很容易知道最佳情况下的时间复杂度，即字符串内字符各不相同的时候。推算得平均访问每个字符 4 次，即时间复杂度为：$T_{best}(n)=O(n)$。</p>
<p>综上，<strong>Manacher 算法的时间复杂度为 O(n)</strong>。</p>
<h2 id="KMP算法">KMP算法</h2>
<p>解决字符串匹配问题，包括几个重点：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>求解next数组</p>
</li>
<li class="lvl-2">
<p>根据next数组来进行模式匹配</p>
</li>
</ul>
<h3 id="求解next数组">求解next数组</h3>
<p>next数组的<strong>定义</strong>：针对pattern模式串<code>s</code>，<em><code>next[i]</code> 表示子串<code>s[0...i]</code>的【最长相等前后缀】中【前缀的最后一位】的下标。</em></p>
<h5 id="手动模拟">手动模拟</h5>
<p>根据定义进行手动模拟即可，无对应相等前后缀的值赋 -1。</p>
<h5 id="递推求解-代码实现">递推求解 / 代码实现</h5>
<p>两个指针的含义：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>i</code>： 从1 ~ len - 1之间遍历，表示当前处理的字符；</p>
</li>
<li class="lvl-2">
<p><code>j</code>： 表示【当前的相等前后缀】中 【前缀】的最后一位 的下标；</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>判断 <code>s[i] == s[j + 1] </code>， 即判断当前相等前后缀是否能扩展到下一位；</p>
</li>
<li class="lvl-4">
<p>如果不能就要向前回溯，为了<strong>减少回溯次数</strong>（使找到的相等前后缀尽可能长，<code>j</code>尽可能大），每次回退使<code>j = next[j]</code> 直至其回退为 -1；</p>
<p>为什么回退时使 <code>j = next[j]</code> 能够最小化回溯次数？我们根据后面讲解的“实际求解过程”进行手动模拟，并结合下图的例子来实际理解（用图中的字符串做求解next数组的实例练习）：</p>
<img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205111123247.png" srcset="/img/loading.gif" lazyload style="zoom:33%;" />
<p>此时，最长的相等前后缀为 $aabaa$，并且在 $i$ 处失配。为了使回溯次数尽可能少，就要使得 $j$ 尽可能地大，方法就是寻找 $aabaa$ 中的最长相等前后缀的位置。根据next数组的含义，自然应该将 $j$ 移动到 $next[j]$ 的位置。</p>
</li>
</ul>
</li>
</ul>
<p>实际求解过程：</p>
<ol>
<li class="lvl-4">
<p>初始化 next 数组，令 <code>j = next[0] = -1</code>；</p>
</li>
<li class="lvl-4">
<p>让 <code>i</code> 在 1 ~ len - 1 范围之间遍历，对每个 <code>i</code> 执行第三步与第四步，以求解 <code>next[i]</code>；</p>
</li>
<li class="lvl-3">
<p>不断令 <code>j = next[j]</code>， 直到 <code>j</code> 回退为 -1，或是 <code>s[i] == s[j + 1]</code> 成立。</p>
</li>
<li class="lvl-3">
<p>如果 <code>s[i] == s[j + 1]</code> ， 则 <code>j</code> 自增 1 后 <code>next[i] = j</code>， 否则直接令 <code>next[i] = j</code>。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">getNext</span><span class="hljs-params">(string s)</span> </span>&#123;<br>	<span class="hljs-type">int</span> j = <span class="hljs-number">-1</span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">next</span><span class="hljs-params">(s.size())</span></span>;<br>    next[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-keyword">while</span>(j != <span class="hljs-number">-1</span> &amp;&amp; s[i] != s[j + <span class="hljs-number">1</span>]) &#123;<br>            j = next[j];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(s[i] == s[j + <span class="hljs-number">1</span>]) &#123;<br>        	j++;<br>        &#125;<br>        next[i] = j;<br>    &#125;<br>    <span class="hljs-keyword">return</span> next;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="模式匹配">模式匹配</h3>
<p>KMP的原则在于：<em>文本串的指针 <code>i</code> 绝对不回溯，而模式串的指针 <code>j</code>  也在回溯的过程中保持其尽可能大。</em></p>
<p>在模式匹配中，next数组的<strong>含义</strong>：<strong>当 j + 1 位失配时，j 应该回退到的位置</strong>。</p>
<p>模式匹配的求解过程与求解next数组非常相似，实际上求解next数组的过程就是模式串pattern进行自我匹配（并计算得到数组的值）的过程，而KMP算法是将pattern与目标串text进行匹配。</p>
<p>KMP算法进行模式匹配的作用不唯一，可以用于求解<strong>匹配是否成功</strong>，也可以用于求解<strong>模式串出现的次数</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 匹配是否成功</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">kmp</span><span class="hljs-params">(string text, string pattern)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = text.<span class="hljs-built_in">size</span>(), m = pattern.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">-1</span>;<br>    vector&lt;<span class="hljs-type">int</span>&gt; next = <span class="hljs-built_in">getNext</span>(pattern);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">while</span>(j != <span class="hljs-number">-1</span> &amp;&amp; text[i] != pattern[j + <span class="hljs-number">1</span>]) &#123;<br>            j = next[j];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(text[i] == pattern[j + <span class="hljs-number">1</span>]) &#123;<br>            j++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(j == m - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 统计模式串出现的次数</span><br><span class="hljs-comment">// 重点要注意模式串在文本串中多次的出现可能会【重叠】</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kmp</span><span class="hljs-params">(string text, string pattern)</span> </span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> n = text.<span class="hljs-built_in">size</span>()， m = pattern.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">-1</span>;<br>    vector&lt;<span class="hljs-type">int</span>&gt; next = <span class="hljs-built_in">getNext</span>(string pattern);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">while</span>(j != <span class="hljs-number">-1</span> &amp;&amp; text[i] != pattern[j + <span class="hljs-number">1</span>]) &#123;<br>            j = next[j];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(text[i] == pattern[j + <span class="hljs-number">1</span>]) &#123;<br>            j++;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 统计次数的代码唯一的区别如下</span><br>        <span class="hljs-keyword">if</span>(j == m - <span class="hljs-number">1</span>) &#123;<br>            ans++;<br>            j = next[j];		<span class="hljs-comment">// 因为模式串的出现可能会重叠，所以不能从头开始匹配，否则会少统计重叠的部分</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="优化-nextval数组">优化 - nextval数组</h3>
<p>next数组对应的模式匹配在失配的情况下，<code>j</code> 指针有可能产生多次无用的回溯（一直失配，直至 <code>j</code> 为-1）。具体情况如下，结合图示例子来理解：</p>
<img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205111539729.png" srcset="/img/loading.gif" lazyload style="zoom:33%;" />
<p>图中黑色的指针 $i, j$ 代表生成 $nextval$ 数组时的指针，红色的指针 $i, j$ 代表进行模式匹配时的指针。此处失配后，根据 $next$ 数组可以看到，会不断进行回退：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>第一次失配：此时 $j + 1 = 5$ 处为 $b$，先回退到 $j = next[4] = 2$， 显然此时仍然失配；</p>
</li>
<li class="lvl-2">
<p>第二次失配：此时 $j + 1 = 3$ 处仍然为 $b$，再回退到 $j = next[2] = 0$，显然此时再次失配；</p>
</li>
<li class="lvl-2">
<p>第三次失配：此时 $j + 1 = 1$ 处又一次为 $b$，继续回退到 $j = next[1] = -1$ 处，回退停止。</p>
</li>
</ul>
<p>综上三次失配与回退可以发现：每次回退之后的 $j + 1$ 处的字符都相等为 $b$ ，失配是显而易见的，白白进行了多次比较。</p>
<p>$nextval$ 数组就是避免了这种 <em>$patter[j + 1] == patter[next[j] + 1]$</em> 的情况，一次性跳跃到正确的比对位置。</p>
<p>在进行模式匹配时，模式串在 $i$ 处失配意味着 $i + 1$ 与文本串对应位置不符，即 $i + 1$ 处的字符有问题（上图例子中的$b$）。所以如果再次跳回一个同样的错误字符，即 $j + 1$ 处等于 $i + 1$处的失配字符时，肯定还需要再重复回退一次，所以具体实现代码如下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">getNextval</span><span class="hljs-params">(string pattern)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = pattern.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextval</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">-1</span>;<br>    nextval[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span>(j != <span class="hljs-number">-1</span> &amp;&amp; pattern[i] != pattern[j + <span class="hljs-number">1</span>]) &#123;		<br>        <span class="hljs-comment">// 根据nextval的定义，求解数组和模式匹配中的while都可以改成if，因为至多只会执行一次</span><br>        	j = <span class="hljs-built_in">nextval</span>(j)；    <br>        &#125;<br>        <span class="hljs-keyword">if</span>(pattern[i] == pattern[j + <span class="hljs-number">1</span>]) &#123;<br>            j++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(j == <span class="hljs-number">-1</span> || pattern[i + <span class="hljs-number">1</span>] != pattern[j + <span class="hljs-number">1</span>]) &#123;<br>            nextval[i] = j;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            nextval[i] = nextval[j];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>至此，$nextval$ 数组虽然失去了其定义中最大前后缀的含义，但是其指向了<strong>每次回退时的真正最佳位置</strong>，减少了无效的回退操作。</p>
<h3 id="时间复杂度">时间复杂度</h3>
<p><code>O(n + m)</code> ： 其中 <code>n</code>为目标字符串text的长度， <code>m</code> 为模式串pattern的长度</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>计算next数组需要 <code>O(m)</code>；</p>
</li>
<li class="lvl-2">
<p>进行模式匹配需要 <code>O(n)</code>；</p>
</li>
</ul>
<h2 id="Morris-Traversal-线索二叉树">Morris Traversal / 线索二叉树</h2>
<blockquote>
<p><em>遇到 <a href="####%E5%89%8D/%E4%B8%AD/%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86">树的前中后序遍历</a> 相关的题目，要立刻想到尝试通过Morris遍历来对空间复杂度进行进一步优化。</em></p>
</blockquote>
<h3 id="基本思想-2">基本思想</h3>
<p>由Joseph Morris于1979年发明，利用二叉树节点中大量的空指针（不适用栈/递归），来将二叉树遍历的<strong>空间复杂度</strong>由线性降低至<strong>常数级</strong><code>O(1)</code>。思路与（中序）<strong>线索二叉树</strong>的构建基本一致。</p>
<p>普通的遍历方法本质上都用到了<strong>栈</strong>，问题在于访问过下层节点后如何返回上层，这是二叉树的结构决定的（并没有指回上层的指针）。Morris遍历利用二叉树中大量的空闲指针，使其指向上层节点，从而避免使用栈，通过指针完成下层到上层的移动。当然，构建这些新指针的过程必然也会导致对于整棵树的部分节点访问两次，但整体时间复杂度仍然保持在线性。</p>
<h3 id="算法实现">算法实现</h3>
<blockquote>
<p>首先理解指针移动的过程，然后按照不同遍历顺序在其应该输出的位置添加相应的代码。</p>
</blockquote>
<p>一次Morris遍历能够得到一个完整的Morris序列，根据Morris序列进行一些特定处理就能得到先序、中序和后序的序列。首先来看Morris遍历的实现：</p>
<p>当前节点为<code>curr</code>，初始时即为整颗树的<code>root</code>；同时定义另一个指针<code>mostRight</code>，该指针指向<code>curr</code>的<strong>中序序列前驱</strong>，即其<strong>左子树上最右的节点</strong>（如果有左子树）。</p>
<ol>
<li class="lvl-3">
<p>如果<code>curr</code>为<code>nullptr</code>，则退出循环，过程中止；</p>
</li>
<li class="lvl-3">
<p>如果<code>curr</code>没有左子树，则其向右移动，<code>curr = curr-&gt;right</code>；</p>
<blockquote>
<p><em>先序、中序遍历</em>在此处输出。</p>
<p>此时意味着没有左子树：</p>
<ul class="lvl-3">
<li class="lvl-2">
<p>先序序列：不管有没有左子树，按照“根左右”的顺序，都应该先对根节点进行输出；</p>
</li>
<li class="lvl-2">
<p>中序序列：按照“左根右”的顺序，没有左子树的情况下应该对根节点进行输出。</p>
</li>
</ul>
</blockquote>
</li>
<li class="lvl-3">
<p>如果<code>curr</code>有左子树，则定位<code>mostRight</code>，根据<code>mostRight</code>的右儿子指针来决定，此时因为其为左子树上最优的节点，所以其右子树只有以下两种可能：</p>
<ul class="lvl-2">
<li class="lvl-5">
<p>如果<code>mostRight</code>的<code>right</code>指针指向<code>nullptr</code>，则令其右指针指向<code>curr</code>，并让<code>curr</code>指针向左移动；</p>
<p>此时意味着<strong>第一次访问当前节点</strong>，其<strong>左子树还未被访问</strong>（无论其左子树是否为空，放入下一轮循环判断），所以当前指针向左移动；</p>
<blockquote>
<p><em>先序遍历</em>在此处输出。</p>
<p>按照先序序列中“根左右”的顺序，第一次访问该节点就应该对其输出。</p>
</blockquote>
</li>
<li class="lvl-5">
<p>如果<code>mostRight</code>的<code>right</code>指针指向<code>curr</code>，则还原其右指针，使其指回<code>nullptr</code>，并让<code>curr</code>指针向右移动；</p>
<p>此时意味着已经<strong>第二次访问当前节点</strong>，其<strong>左子树均已被访问</strong>，此时根据具体要求还原二叉树，并使当前指针向右移动。</p>
<blockquote>
<p><em>中序遍历</em>在此处输出。</p>
<p><em>后序遍历</em>在此处倒序输出从当前节点的左儿子<code>curr-&gt;left</code>到<code>mostRight</code>路径上的所有节点（不包含当前节点本身）。</p>
<p>此时意味着左子树全部已访问：</p>
<ul class="lvl-5">
<li class="lvl-2">
<p>中序遍历：按照“左根右“的顺序，左子树全部访问结束的情况下应该对根节点进行输出；</p>
</li>
<li class="lvl-2">
<p>后序遍历：按照”左右根“的顺序，</p>
</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li class="lvl-3">
<p><em>后序遍历</em>最后要将从根节点开始的最右侧路径加入结果中。</p>
</li>
</ol>
<p>综上即为Morris遍历的实现过程，可以看出具有左子树的节点都会访问两次，没有左子树的节点只会到达一次。整体实现过程与<strong>构建中序线索二叉树</strong>思路十分相似。最终<code>curr</code>的完整访问路线被称为Morris序列。</p>
<p>在以上过程中稍作修改，就能够得到二叉树的先序、中序和后序遍历序列。</p>
<h3 id="代码实现-2">代码实现</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; morris, preOrder, inOrder, postOrder;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">btTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    TreeNode *curr = root;    <span class="hljs-comment">// 直接用root也一样，这里可有可无，只是和解释保持一致</span><br>    TreeNode *mostRight = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">while</span>(curr) &#123;					<span class="hljs-comment">// curr为空即退出循环</span><br>        <span class="hljs-keyword">if</span>(curr-&gt;left) &#123;			<span class="hljs-comment">// 左子树不为空</span><br>            <span class="hljs-comment">// 定位mostRight</span><br>            mostRight = curr-&gt;left;<br>            <span class="hljs-keyword">while</span>(mostRight-&gt;right &amp;&amp; mostRight-&gt;right != curr) &#123;<br>                mostRight = mostRight-&gt;right;<br>            &#125;<br>            <br>            <span class="hljs-comment">// 第一次访问</span><br>            <span class="hljs-keyword">if</span>(mostRight-&gt;right == <span class="hljs-literal">nullptr</span>) &#123;<br>                mostRight-&gt;right = curr;<br>                <span class="hljs-comment">// morris.emplace_back(curr-&gt;val);</span><br>               <br>                <span class="hljs-comment">/*--</span><br><span class="hljs-comment">                	先序遍历在此处插入</span><br><span class="hljs-comment">                	preOrder.emplace_back(curr-&gt;val);</span><br><span class="hljs-comment">                --*/</span><br>                <br>                curr = curr-&gt;left;				<span class="hljs-comment">// 第一次访问意味着左子树还未访问</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(mostRight-&gt;right == curr) &#123;<br>                mostRight-&gt;right = <span class="hljs-literal">nullptr</span>;     <span class="hljs-comment">// 二叉树还原</span><br>                <span class="hljs-comment">// morris.emplace_back(curr-&gt;val);</span><br>                <br>                <span class="hljs-comment">/*--</span><br><span class="hljs-comment">                	中序遍历在此处插入</span><br><span class="hljs-comment">                	inOrder.emplace_back(curr-&gt;val);</span><br><span class="hljs-comment">                	</span><br><span class="hljs-comment">                	后序遍历在此处插入</span><br><span class="hljs-comment">                	addPath(postOrder, curr-&gt;left);</span><br><span class="hljs-comment">                --*/</span><br>                <br>                <br>                curr = curr-&gt;right;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;	<span class="hljs-comment">// 左子树为空</span><br>            <span class="hljs-comment">// morris.emplace_back(curr-&gt;val);</span><br>            <br>            <span class="hljs-comment">/*--</span><br><span class="hljs-comment">                	先序、中序遍历在此处插入</span><br><span class="hljs-comment">                	preOrder.emplace_back(curr-&gt;val);</span><br><span class="hljs-comment">                	inOrder.emplace_back(curr-&gt;val);</span><br><span class="hljs-comment">            --*/</span><br>            <br>            curr = curr-&gt;right;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/*--</span><br><span class="hljs-comment">    	后序遍历在此处插入</span><br><span class="hljs-comment">    	addPath(postOrder, root);</span><br><span class="hljs-comment">    --*/</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h1>Misc.</h1>
<blockquote>
<p>Tricks !</p>
</blockquote>
<h2 id="时间复杂度-数据规模-2">时间复杂度 - 数据规模</h2>
<table>
<thead>
<tr>
<th style="text-align:center">复杂度</th>
<th style="text-align:center">数量级</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$logn$</td>
<td style="text-align:center">long long 以内都可以</td>
</tr>
<tr>
<td style="text-align:center">$\sqrt{n}$</td>
<td style="text-align:center">$10^{12}$</td>
</tr>
<tr>
<td style="text-align:center"><em>$n$</em></td>
<td style="text-align:center"><em>$10^{6} \sim 10^{7}$</em></td>
</tr>
<tr>
<td style="text-align:center"><em>$nlogn$</em></td>
<td style="text-align:center"><em>$10^{5}$</em> $\sim$ $5*10^{5}$</td>
</tr>
<tr>
<td style="text-align:center"><em>$n^2$</em></td>
<td style="text-align:center"><em>1000</em>~5000</td>
</tr>
<tr>
<td style="text-align:center"><strong>$n^3$</strong></td>
<td style="text-align:center"><strong>100</strong>~500</td>
</tr>
<tr>
<td style="text-align:center">$n^4$</td>
<td style="text-align:center">50</td>
</tr>
<tr>
<td style="text-align:center"><strong>$2^n$</strong></td>
<td style="text-align:center"><strong>20~24</strong></td>
</tr>
<tr>
<td style="text-align:center">$3^n$</td>
<td style="text-align:center">14</td>
</tr>
<tr>
<td style="text-align:center">$n!$</td>
<td style="text-align:center">9 ~12</td>
</tr>
</tbody>
</table>
<h2 id="C-Tricks">C++ Tricks</h2>
<h3 id="指针、引用以及c-11中的循环写法">指针、引用以及c++11中的循环写法</h3>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lusirking/article/details/83988421">(14条消息) C++子类的构造函数后面加:冒号的作用_lusirking的博客-CSDN博客</a></p>
<h2 id="Golang-Tricks">Golang Tricks</h2>
<hr>
<blockquote>
<p>以下一些特殊题目的算法解法，统一放在最后这部分。</p>
</blockquote>
<h2 id="周期字符串判别问题">周期字符串判别问题</h2>
<p><strong>周期字符串判别问题</strong>有两种常见解法：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>双倍字符串方法</p>
</li>
<li class="lvl-2">
<p>KMP 方法</p>
</li>
</ul>
<p>本题的难点在于证明与推演，其解题思路与代码都比较简单。</p>
<h3 id="问题">问题</h3>
<p>判断一个字符串是否由其一个子串重复多次构成。</p>
<p>例如：字符串 <code>&quot;abcabc&quot;</code> 是由子串 <code>&quot;abc&quot;</code> 重复两次构成的。</p>
<h3 id="双倍字符串方法">双倍字符串方法</h3>
<p>把字符串翻倍，掐头去尾，如果原字符串在其中，那么原字符串就是周期串 。</p>
<p>假设字符串是 <code>s</code> ，把它的头尾字符分别染上黄色和蓝色：</p>
<p><img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205151303835.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>把字符串 <code>s</code> 接到自身后面，然后掐头去尾，形成新字符串 <code>s'</code>：</p>
<p><img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205151303981.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h5 id="匹配意味着周期性">匹配意味着周期性</h5>
<p>下面讨论原字符串 <code>s</code> 在新字符串 <code>s'</code> 中存在的情况。</p>
<p>一步一步对各部分涂色，使得相等的字符串颜色一样 。</p>
<p><img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205151304030.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>经过几轮的染色，可以看到最终 <code>s</code> 确实是一个周期串。</p>
<p>是否巧合？可以做一般性说明。</p>
<p>下图，不妨设右边匹配的少一些。对其中的任一字符 <code>A</code> ，可以按照如下的规则推演：</p>
<p><img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205151304895.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>如此，任一此区间上的字符 <code>A</code> 会在 <code>s</code> 中周期性出现。</p>
<p>即说明字符串 <code>s</code> 是周期串。</p>
<h5 id="周期性意味着匹配">周期性意味着匹配</h5>
<p>反过来，如果一个字符串 <code>s</code> 是周期串，那么它一定在对应的 <code>s'</code> 中吗？</p>
<p>任何一个周期串可以表达为： 由某个模式子串的重复多次构成 。</p>
<p><img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205151305541.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>将周期串 <code>s</code> 的头字符对齐在第一个模式串后面， 每次右移一个模式串的长度。</p>
<p>可知，<code>s</code> 会在 <code>s'</code> 中有匹配，且可以有多个匹配。</p>
<p><img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205151305963.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>图中可看出， 因为模式串重复 <code>n</code> 次，所以会有 <code>n</code> 次匹配 。</p>
<p>构造双倍串 <code>s'</code> 时，移除头尾字符， 正是为了剔除最左和最右的两次必然匹配。 只有中间的 <code>n</code> 次匹配才用到了周期串重复模式串的性质。</p>
<h5 id="结论">结论</h5>
<p>综上两方面说明了充分性和必要性，结论：</p>
<p>如果字符串在其掐头去尾的双倍字符串中，它就是周期串 。</p>
<h3 id="KMP-方法">KMP 方法</h3>
<p>假设要判断的字符串叫做 <code>s</code> ，将其尾巴字符标记为蓝色。</p>
<p>取 <code>q</code> 为不包含尾巴字符的前缀。</p>
<p><img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205151305388.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>取 <code>c</code> 为 <code>q</code> 的最长前后公共缀。</p>
<p>前后公共缀的意思是，它是既出现在字符串的最前面，也出现在字符串的最后面的真子串 。</p>
<p>举例来说，比如 <code>s</code> 是字符串串 <code>&quot;abcabcabc&quot;</code> ，<code>q</code> 则是 <code>&quot;abcabcab&quot;</code> 。</p>
<p><code>q</code> 的最长前后公共缀 <code>c</code> 则是 <code>&quot;abcab&quot;</code> 。</p>
<p><img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205151305522.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>将说明，<code>s</code> 是周期串等价于 <code>len(s)</code> 是 <code>len(q)-len(c)</code> 的倍数 。</p>
<h5 id="必要性说明">必要性说明</h5>
<p>假设字符串 <code>s</code> 是一个周期串，它由模式串 <code>p</code> 重复多次构成。</p>
<p><img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205151305620.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>现在， 取 <code>c1</code> 为 <code>q</code> 中剔去一个模式串 <code>p</code> 后的后缀 。</p>
<p><img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205151306852.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>显然，字符串 <code>c1</code> 是 <code>q</code> 的一个 <a target="_blank" rel="noopener" href="https://writings.sh/post/algorithm-repeated-string-pattern#what-is-common-prefix-and-suffix">前后公共缀</a>。</p>
<p>比如周期串 <code>&quot;abcabcabc&quot;</code> ，对应的 <code>c1</code> 是 <code>&quot;abcab&quot;</code> 。</p>
<p><img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205151306288.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>可以证明，<code>c1</code> 就是 <code>q</code> <strong>最长的</strong>前后公共缀 <code>c</code> ，详细可展开下面内容。</p>
<details open="" style="padding: 0px; margin: 0px;"><summary style="padding: 0px; margin: 0px; color: rgb(197, 142, 4); outline: 0px; cursor: pointer;"><span class="MathJax_Preview" style="padding: 0px; margin: 0px; color: inherit;"></span><span id="MathJax-Element-1-Frame" class="mjx-chtml MathJax_CHTML" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mstyle displaystyle=&quot;true&quot;><mi>c</mi><mn>1</mn></mstyle></math>" role="presentation" style="padding: 1px 0px; margin: 0px; outline: 0px; display: inline-block; line-height: 0; text-indent: 0px; text-align: left; text-transform: none; font-style: normal; font-weight: normal; font-size: 20.4px; letter-spacing: normal; overflow-wrap: normal; word-spacing: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; position: relative;"><span id="MJXc-Node-1" class="mjx-math" aria-hidden="true" style="padding: 0px; margin: 0px; display: inline-block; border-collapse: separate; border-spacing: 0px;"><span id="MJXc-Node-2" class="mjx-mrow" style="padding: 0px; margin: 0px; display: inline-block; text-align: left; box-sizing: content-box !important;"><span id="MJXc-Node-3" class="mjx-mstyle" style="padding: 0px; margin: 0px; display: inline-block; text-align: left; box-sizing: content-box !important;"><span id="MJXc-Node-4" class="mjx-mrow" style="padding: 0px; margin: 0px; display: inline-block; text-align: left; box-sizing: content-box !important;"><span id="MJXc-Node-5" class="mjx-mi" style="padding: 0px; margin: 0px; display: inline-block; text-align: left; box-sizing: content-box !important;"><span class="mjx-char MJXc-TeX-math-I" style="padding: 0.199em 0px 0.297em; margin: 0px; display: block; text-align: left; box-sizing: content-box !important; white-space: pre; font-family: MJXc-TeX-math-I, MJXc-TeX-math-Ix, MJXc-TeX-math-Iw;">c</span></span><span id="MJXc-Node-6" class="mjx-mn" style="padding: 0px; margin: 0px; display: inline-block; text-align: left; box-sizing: content-box !important;"><span class="mjx-char MJXc-TeX-main-R" style="padding: 0.395em 0px 0.346em; margin: 0px; display: block; text-align: left; box-sizing: content-box !important; white-space: pre; font-family: MJXc-TeX-main-R, MJXc-TeX-main-Rw;">1</span></span></span></span></span></span><span class="MJX_Assistive_MathML" role="presentation" style="padding: 1px 0px 0px !important; margin: 0px; top: 0px; left: 0px; clip: rect(1px, 1px, 1px, 1px); user-select: none; position: absolute !important; border: 0px !important; height: 1px !important; width: 1px !important; overflow: hidden !important; display: block !important;"><math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mi>c</mi><mn>1</mn></mstyle></math></span></span><span>&nbsp;</span>就是<span>&nbsp;</span><span class="MathJax_Preview" style="padding: 0px; margin: 0px; color: inherit;"></span><span id="MathJax-Element-2-Frame" class="mjx-chtml MathJax_CHTML" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mstyle displaystyle=&quot;true&quot;><mi>q</mi></mstyle></math>" role="presentation" style="padding: 1px 0px; margin: 0px; outline: 0px; display: inline-block; line-height: 0; text-indent: 0px; text-align: left; text-transform: none; font-style: normal; font-weight: normal; font-size: 20.4px; letter-spacing: normal; overflow-wrap: normal; word-spacing: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; position: relative;"><span id="MJXc-Node-7" class="mjx-math" aria-hidden="true" style="padding: 0px; margin: 0px; display: inline-block; border-collapse: separate; border-spacing: 0px;"><span id="MJXc-Node-8" class="mjx-mrow" style="padding: 0px; margin: 0px; display: inline-block; text-align: left; box-sizing: content-box !important;"><span id="MJXc-Node-9" class="mjx-mstyle" style="padding: 0px; margin: 0px; display: inline-block; text-align: left; box-sizing: content-box !important;"><span id="MJXc-Node-10" class="mjx-mrow" style="padding: 0px; margin: 0px; display: inline-block; text-align: left; box-sizing: content-box !important;"><span id="MJXc-Node-11" class="mjx-mi" style="padding: 0px; margin: 0px; display: inline-block; text-align: left; box-sizing: content-box !important;"><span class="mjx-char MJXc-TeX-math-I" style="padding: 0.199em 0.014em 0.493em 0px; margin: 0px; display: block; text-align: left; box-sizing: content-box !important; white-space: pre; font-family: MJXc-TeX-math-I, MJXc-TeX-math-Ix, MJXc-TeX-math-Iw;">q</span></span></span></span></span></span><span class="MJX_Assistive_MathML" role="presentation" style="padding: 1px 0px 0px !important; margin: 0px; top: 0px; left: 0px; clip: rect(1px, 1px, 1px, 1px); user-select: none; position: absolute !important; border: 0px !important; height: 1px !important; width: 1px !important; overflow: hidden !important; display: block !important;"><math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mi>q</mi></mstyle></math></span></span><span>&nbsp;</span>最长的前后公共缀<span>&nbsp;</span><span class="MathJax_Preview" style="padding: 0px; margin: 0px; color: inherit;"></span><span id="MathJax-Element-3-Frame" class="mjx-chtml MathJax_CHTML" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mstyle displaystyle=&quot;true&quot;><mi>c</mi></mstyle></math>" role="presentation" style="padding: 1px 0px; margin: 0px; outline: 0px; display: inline-block; line-height: 0; text-indent: 0px; text-align: left; text-transform: none; font-style: normal; font-weight: normal; font-size: 20.4px; letter-spacing: normal; overflow-wrap: normal; word-spacing: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; position: relative;"><span id="MJXc-Node-12" class="mjx-math" aria-hidden="true" style="padding: 0px; margin: 0px; display: inline-block; border-collapse: separate; border-spacing: 0px;"><span id="MJXc-Node-13" class="mjx-mrow" style="padding: 0px; margin: 0px; display: inline-block; text-align: left; box-sizing: content-box !important;"><span id="MJXc-Node-14" class="mjx-mstyle" style="padding: 0px; margin: 0px; display: inline-block; text-align: left; box-sizing: content-box !important;"><span id="MJXc-Node-15" class="mjx-mrow" style="padding: 0px; margin: 0px; display: inline-block; text-align: left; box-sizing: content-box !important;"><span id="MJXc-Node-16" class="mjx-mi" style="padding: 0px; margin: 0px; display: inline-block; text-align: left; box-sizing: content-box !important;"><span class="mjx-char MJXc-TeX-math-I" style="padding: 0.199em 0px 0.297em; margin: 0px; display: block; text-align: left; box-sizing: content-box !important; white-space: pre; font-family: MJXc-TeX-math-I, MJXc-TeX-math-Ix, MJXc-TeX-math-Iw;">c</span></span></span></span></span></span><span class="MJX_Assistive_MathML" role="presentation" style="padding: 1px 0px 0px !important; margin: 0px; top: 0px; left: 0px; clip: rect(1px, 1px, 1px, 1px); user-select: none; position: absolute !important; border: 0px !important; height: 1px !important; width: 1px !important; overflow: hidden !important; display: block !important;"><math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mi>c</mi></mstyle></math></span></span><span>&nbsp;</span>的详细说明</summary><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;">采用反证法，假设存在一个字符串<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">c'</code><span>&nbsp;</span>也是<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">q</code><span>&nbsp;</span>的前后公共缀，而且它比<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">c1</code><span>&nbsp;</span>长一位。</p><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;">另外，假设尾巴字符叫做<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">A</code><span>&nbsp;</span>。</p><figure style="padding: 0px; margin: 30px auto; width: 768px;"><img class="post-img lazyload max-width-100 medium-zoom-image" src="https://writings.sh/assets/images/posts/algorithm-repeated-string-pattern/repeated-string-pattern-kmp-5-1.jpeg" data-src="/assets/images/posts/algorithm-repeated-string-pattern/repeated-string-pattern-kmp-5-1.jpeg" alt="" data-loaded="true" style="padding: 0px; margin: 0px auto; display: block; max-width: 100%; cursor: zoom-in; transition: transform 0.3s cubic-bezier(0.2, 0, 0.2, 1) 0s !important;"></figure><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;"></p><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;">现在有两条性质：</p><ol style="padding: 0px 0px 0px 30px; margin: 15px 0px; list-style: decimal;"><li style="padding: 0px; margin: 0px;">周期性质：字符串<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">s</code><span>&nbsp;</span>的周期性。</li><li style="padding: 0px; margin: 0px;">前后公共缀性质：<code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">c'</code><span>&nbsp;</span>是<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">q</code><span>&nbsp;</span>的前后公共缀。</li></ol><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;">以下，反复利用此两条性质：</p><ol style="padding: 0px 0px 0px 30px; margin: 15px 0px; list-style: decimal;"><li style="padding: 0px; margin: 0px;"><p style="padding: 0px; margin: 0px 0px 15px; letter-spacing: 0.5px;">由于「前后公共缀性质」，<code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">q</code><span>&nbsp;</span>的第一个字符也是<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">A</code>。</p><figure style="padding: 0px; margin: 30px auto; width: 738px;"><img class="post-img lazyload max-width-100 medium-zoom-image" src="https://writings.sh/assets/images/posts/algorithm-repeated-string-pattern/repeated-string-pattern-kmp-5-2.jpeg-small.svg" data-src="/assets/images/posts/algorithm-repeated-string-pattern/repeated-string-pattern-kmp-5-2.jpeg" alt="" style="padding: 0px; margin: 0px auto; display: block; max-width: 100%; cursor: zoom-in; transition: transform 0.3s cubic-bezier(0.2, 0, 0.2, 1) 0s !important;"></figure><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;"></p></li><li style="padding: 0px; margin: 0px;"><p style="padding: 0px; margin: 0px 0px 15px; letter-spacing: 0.5px;">由于「周期性质」，后续的循环子串中的第一个字符也是<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">A</code><span>&nbsp;</span>。</p><figure style="padding: 0px; margin: 30px auto; width: 738px;"><img class="post-img lazyload max-width-100 medium-zoom-image" src="https://writings.sh/assets/images/posts/algorithm-repeated-string-pattern/repeated-string-pattern-kmp-5-3.jpeg-small.svg" data-src="/assets/images/posts/algorithm-repeated-string-pattern/repeated-string-pattern-kmp-5-3.jpeg" alt="" style="padding: 0px; margin: 0px auto; display: block; max-width: 100%; cursor: zoom-in; transition: transform 0.3s cubic-bezier(0.2, 0, 0.2, 1) 0s !important;"></figure><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;"></p></li><li style="padding: 0px; margin: 0px;"><p style="padding: 0px; margin: 0px 0px 15px; letter-spacing: 0.5px;">由于「前后公共缀性质」，<code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">q</code><span>&nbsp;</span>的第二个字符也是<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">A</code>。</p><figure style="padding: 0px; margin: 30px auto; width: 738px;"><img class="post-img lazyload max-width-100 medium-zoom-image" src="https://writings.sh/assets/images/posts/algorithm-repeated-string-pattern/repeated-string-pattern-kmp-5-4.jpeg-small.svg" data-src="/assets/images/posts/algorithm-repeated-string-pattern/repeated-string-pattern-kmp-5-4.jpeg" alt="" style="padding: 0px; margin: 0px auto; display: block; max-width: 100%; cursor: zoom-in; transition: transform 0.3s cubic-bezier(0.2, 0, 0.2, 1) 0s !important;"></figure><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;"></p></li><li style="padding: 0px; margin: 0px;"><p style="padding: 0px; margin: 0px 0px 15px; letter-spacing: 0.5px;">由于「周期性质」，后续的循环子串中的第二个字符也是<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">A</code><span>&nbsp;</span>。</p><figure style="padding: 0px; margin: 30px auto; width: 738px;"><img class="post-img lazyload max-width-100 medium-zoom-image" src="https://writings.sh/assets/images/posts/algorithm-repeated-string-pattern/repeated-string-pattern-kmp-5-5.jpeg-small.svg" data-src="/assets/images/posts/algorithm-repeated-string-pattern/repeated-string-pattern-kmp-5-5.jpeg" alt="" style="padding: 0px; margin: 0px auto; display: block; max-width: 100%; cursor: zoom-in; transition: transform 0.3s cubic-bezier(0.2, 0, 0.2, 1) 0s !important;"></figure><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;"></p></li><li style="padding: 0px; margin: 0px;"><p style="padding: 0px; margin: 0px 0px 15px; letter-spacing: 0.5px;">如上反复进行，最终，推断整个<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">q</code><span>&nbsp;</span>以及<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">s</code><span>&nbsp;</span>都由字符<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">A</code><span>&nbsp;</span>构成。</p><figure style="padding: 0px; margin: 30px auto; width: 738px;"><img class="post-img lazyload max-width-100 medium-zoom-image" src="https://writings.sh/assets/images/posts/algorithm-repeated-string-pattern/repeated-string-pattern-kmp-5-6.jpeg-small.svg" data-src="/assets/images/posts/algorithm-repeated-string-pattern/repeated-string-pattern-kmp-5-6.jpeg" alt="" style="padding: 0px; margin: 0px auto; display: block; max-width: 100%; cursor: zoom-in; transition: transform 0.3s cubic-bezier(0.2, 0, 0.2, 1) 0s !important;"></figure><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;"></p><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;">此时的模式串<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">p</code><span>&nbsp;</span>即单个字符<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">A</code><span>&nbsp;</span>。</p><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;">根据<span>&nbsp;</span><a target="_blank" rel="noopener" href="https://writings.sh/post/algorithm-repeated-string-pattern#kmp-c1-definition" style="padding: 0px; margin: 0px; color: rgb(197, 142, 4); text-decoration: none;">前面的定义</a><span>&nbsp;</span>可以知道，此时的<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">c1</code><span>&nbsp;</span>如上图，长度是<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">len(q)-1</code><span>&nbsp;</span>。</p><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;">前后公共缀是真子串，显然，不会存在比它更长的前后公共缀，造成矛盾。</p></li></ol><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;">因此，所定义的<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">c1</code><span>&nbsp;</span>就是<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">q</code><span>&nbsp;</span>的最长前后公共缀<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">c</code><span>&nbsp;</span>。</p></details>
<p>根据 <a target="_blank" rel="noopener" href="https://writings.sh/post/algorithm-repeated-string-pattern#kmp-c1-definition">前面的定义</a> ，可知周期长度是 <code>len(p) = len(q)-len(c)</code> 。</p>
<p>因为字符串 <code>s</code> 是周期串，所以其长度一定是周期长度的倍数。</p>
<p>必要性得到说明。</p>
<h5 id="充分性说明">充分性说明</h5>
<p>令 <code>d = len(q)-len(c)</code> ， 如果 <code>s</code> 的长度是 <code>d</code> 的倍数，是否 <code>s</code> 一定是周期串？</p>
<p>此时 <code>s</code> 一定可以每 <code>d</code> 个字符一份，切分为整数个小份串：</p>
<p><img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205151307596.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>同样假设尾巴字符是蓝色的 <code>A</code> ， 剔除尾巴字符后 <code>q</code> 和 其最长前后公共缀 <code>c</code> 如下所示：</p>
<p><img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205151307241.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>首先，显然 <code>len(c)+1</code> 是 <code>d</code> 的倍数。</p>
<details open="" style="padding: 0px; margin: 0px;"><summary style="padding: 0px; margin: 0px; color: rgb(197, 142, 4); outline: 0px; cursor: pointer;"><span class="MathJax_Preview" style="padding: 0px; margin: 0px; color: inherit;"></span><span id="MathJax-Element-4-Frame" class="mjx-chtml MathJax_CHTML" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mstyle displaystyle=&quot;true&quot;><mi>c</mi></mstyle></math>" role="presentation" style="padding: 1px 0px; margin: 0px; outline: 0px; display: inline-block; line-height: 0; text-indent: 0px; text-align: left; text-transform: none; font-style: normal; font-weight: normal; font-size: 20.4px; letter-spacing: normal; overflow-wrap: normal; word-spacing: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; position: relative;"><span id="MJXc-Node-17" class="mjx-math" aria-hidden="true" style="padding: 0px; margin: 0px; display: inline-block; border-collapse: separate; border-spacing: 0px;"><span id="MJXc-Node-18" class="mjx-mrow" style="padding: 0px; margin: 0px; display: inline-block; text-align: left; box-sizing: content-box !important;"><span id="MJXc-Node-19" class="mjx-mstyle" style="padding: 0px; margin: 0px; display: inline-block; text-align: left; box-sizing: content-box !important;"><span id="MJXc-Node-20" class="mjx-mrow" style="padding: 0px; margin: 0px; display: inline-block; text-align: left; box-sizing: content-box !important;"><span id="MJXc-Node-21" class="mjx-mi" style="padding: 0px; margin: 0px; display: inline-block; text-align: left; box-sizing: content-box !important;"><span class="mjx-char MJXc-TeX-math-I" style="padding: 0.199em 0px 0.297em; margin: 0px; display: block; text-align: left; box-sizing: content-box !important; white-space: pre; font-family: MJXc-TeX-math-I, MJXc-TeX-math-Ix, MJXc-TeX-math-Iw;">c</span></span></span></span></span></span><span class="MJX_Assistive_MathML" role="presentation" style="padding: 1px 0px 0px !important; margin: 0px; top: 0px; left: 0px; clip: rect(1px, 1px, 1px, 1px); user-select: none; position: absolute !important; border: 0px !important; height: 1px !important; width: 1px !important; overflow: hidden !important; display: block !important;"><math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mi>c</mi></mstyle></math></span></span><span>&nbsp;</span>的长度加一是<span>&nbsp;</span><span class="MathJax_Preview" style="padding: 0px; margin: 0px; color: inherit;"></span><span id="MathJax-Element-5-Frame" class="mjx-chtml MathJax_CHTML" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mstyle displaystyle=&quot;true&quot;><mi>d</mi></mstyle></math>" role="presentation" style="padding: 1px 0px; margin: 0px; outline: 0px; display: inline-block; line-height: 0; text-indent: 0px; text-align: left; text-transform: none; font-style: normal; font-weight: normal; font-size: 20.4px; letter-spacing: normal; overflow-wrap: normal; word-spacing: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; position: relative;"><span id="MJXc-Node-22" class="mjx-math" aria-hidden="true" style="padding: 0px; margin: 0px; display: inline-block; border-collapse: separate; border-spacing: 0px;"><span id="MJXc-Node-23" class="mjx-mrow" style="padding: 0px; margin: 0px; display: inline-block; text-align: left; box-sizing: content-box !important;"><span id="MJXc-Node-24" class="mjx-mstyle" style="padding: 0px; margin: 0px; display: inline-block; text-align: left; box-sizing: content-box !important;"><span id="MJXc-Node-25" class="mjx-mrow" style="padding: 0px; margin: 0px; display: inline-block; text-align: left; box-sizing: content-box !important;"><span id="MJXc-Node-26" class="mjx-mi" style="padding: 0px; margin: 0px; display: inline-block; text-align: left; box-sizing: content-box !important;"><span class="mjx-char MJXc-TeX-math-I" style="padding: 0.493em 0.003em 0.297em 0px; margin: 0px; display: block; text-align: left; box-sizing: content-box !important; white-space: pre; font-family: MJXc-TeX-math-I, MJXc-TeX-math-Ix, MJXc-TeX-math-Iw;">d</span></span></span></span></span></span><span class="MJX_Assistive_MathML" role="presentation" style="padding: 1px 0px 0px !important; margin: 0px; top: 0px; left: 0px; clip: rect(1px, 1px, 1px, 1px); user-select: none; position: absolute !important; border: 0px !important; height: 1px !important; width: 1px !important; overflow: hidden !important; display: block !important;"><math xmlns="http://www.w3.org/1998/Math/MathML"><mstyle displaystyle="true"><mi>d</mi></mstyle></math></span></span><span>&nbsp;</span>的倍数的说明</summary><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;">根据<span>&nbsp;</span><a target="_blank" rel="noopener" href="https://writings.sh/post/algorithm-repeated-string-pattern#kmp-d-definition" style="padding: 0px; margin: 0px; color: rgb(197, 142, 4); text-decoration: none;"><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">d</code><span>&nbsp;</span>的定义</a>， 得<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">len(c) + 1 = len(q) - d + 1</code><span>&nbsp;</span>。</p><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;">又因<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">len(q) = len(s) - 1</code><span>&nbsp;</span>，且<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">len(s)</code><span>&nbsp;</span>可以写作<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">len(s) = k*d</code><span>&nbsp;</span>。</p><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;">所以<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">len(c) + 1 = k*d - d = (k-1)*d</code><span>&nbsp;</span>，是<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">d</code><span>&nbsp;</span>的倍数。</p></details>
<p>因此，在下图中， <code>c</code> 必然上下对齐于某个 <a target="_blank" rel="noopener" href="https://writings.sh/post/algorithm-repeated-string-pattern#kmp-small-pattern-p">小份串</a> 的开头。</p>
<p>又因 <code>len(c)+1 = (k-1)*d</code> ，所以 <code>c</code> 就是 <code>q</code> 中剔除第一个小份串 <code>p1</code> 的后缀 。</p>
<p><img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205151307726.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>下面将说明，<code>s</code> 是一个周期串。</p>
<p>在最后一个小份串，从尾部取倒数第 <code>j</code> 个字符 <code>B</code> ，反复推演， 可以知道前面的所有小份串的相同位置，都是字符 <code>B</code> 。</p>
<p><img src="https://gcore.jsdelivr.net/gh/TAO1st/pics@master/202205151307501.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>上面的图中：</p>
<ol>
<li class="lvl-3">
<p>① 号推演，由于上面后缀和下面前缀相等。</p>
</li>
<li class="lvl-3">
<p>② 号推演，由于下面的小份串和上面的自身相等。</p>
</li>
<li class="lvl-3">
<p>如此，反复进行。</p>
</li>
</ol>
<p>对最后一个小份串上的所有字符， 都会在前面的小份串相同位置重复，那么 <code>s</code> 是一个周期串。</p>
<details open="" style="padding: 0px; margin: 0px;"><summary style="padding: 0px; margin: 0px; color: rgb(197, 142, 4); outline: 0px; cursor: pointer;">推演的一个细节处理</summary><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;">上面推演中的一个细节是，无法推演小份串的倒数第一个字符。</p><figure style="padding: 0px; margin: 30px auto; width: 768px;"><img class="post-img lazyload max-width-100 medium-zoom-image" src="https://writings.sh/assets/images/posts/algorithm-repeated-string-pattern/repeated-string-pattern-kmp-7-3.jpeg" data-src="/assets/images/posts/algorithm-repeated-string-pattern/repeated-string-pattern-kmp-7-3.jpeg" alt="" data-loaded="true" style="padding: 0px; margin: 0px auto; display: block; max-width: 100%; cursor: zoom-in; transition: transform 0.3s cubic-bezier(0.2, 0, 0.2, 1) 0s !important;"></figure><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;"></p><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;">原因在于，尾巴字符不在最长前后公共缀的范围内。</p><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;">细节处理就是，需要判断一次尾巴字符<span>&nbsp;</span><code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">A</code><span>&nbsp;</span>是否和 上一个小份串对应位置的字符相等。</p><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;">一旦此细节满足，即可完成整体推演过程，<code class="language-plaintext highlighter-rouge" style="padding: 1px 2px; margin: 0px 3px; font-family: Consolas, Menlo, monospace; display: inline-block; font-weight: 700; color: rgb(79, 50, 28);">s</code><span>&nbsp;</span>就一定是一个周期串。</p><figure style="padding: 0px; margin: 30px auto; width: 768px;"><img class="post-img lazyload max-width-100 medium-zoom-image" src="https://writings.sh/assets/images/posts/algorithm-repeated-string-pattern/repeated-string-pattern-kmp-7-4.jpeg" data-src="/assets/images/posts/algorithm-repeated-string-pattern/repeated-string-pattern-kmp-7-4.jpeg" alt="" data-loaded="true" style="padding: 0px; margin: 0px auto; display: block; max-width: 100%; cursor: zoom-in; transition: transform 0.3s cubic-bezier(0.2, 0, 0.2, 1) 0s !important;"></figure><p style="padding: 0px; margin: 15px 0px; letter-spacing: 0.5px;"></p></details>
<p>至此，充分性也说明完毕。</p>
<h5 id="KMP-算法求解">KMP 算法求解</h5>
<p>KMP 算法中的 Next 数组的含义就是前后公共缀的长度 ，即 <code>len(c) = next[n-1]</code> 。</p>
<p>由 KMP 算法预处理的时间复杂度 可知，此方法的时间复杂度是 <code>O(n)</code> ，空间复杂度是 <code>O(n)</code> 。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" class="category-chain-item">数据结构与算法</a>
  
  

      </span>
    
  
    
      <span class="category-chain">
        
  <a href="/categories/LeetCode/" class="category-chain-item">LeetCode</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
</div>


              

              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2019/06/30/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" title="环境配置">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">环境配置</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/1988/01/01/test/" title="test">
                        <span class="hidden-mobile">test</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>2022</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>TAO1st</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.1/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
