

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/avatar.png">
  <link rel="icon" href="/img/avatar.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#98a5ac">
  <meta name="author" content="tao1st">
  <meta name="keywords" content="">
  
    <meta name="description" content="Terminology: Object 此处的对象（Object）均指一块能存储数据并具有某种类型的内存空间。  1 变量及其基本类型 1.1 原始内置类型 Primitive Built-in Types C++中的原始类型大致可以分为两大类：   算数类型 arithmetic types   空类型 void 空类型没有关联的值，最常见的使用场景即 不返回值的函数返回值类型。 The vo">
<meta property="og:type" content="article">
<meta property="og:title" content="C++：变量与基本类型">
<meta property="og:url" content="https://tao1st.github.io/2021/01/21/C++_%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/index.html">
<meta property="og:site_name" content="tao1st.github.io">
<meta property="og:description" content="Terminology: Object 此处的对象（Object）均指一块能存储数据并具有某种类型的内存空间。  1 变量及其基本类型 1.1 原始内置类型 Primitive Built-in Types C++中的原始类型大致可以分为两大类：   算数类型 arithmetic types   空类型 void 空类型没有关联的值，最常见的使用场景即 不返回值的函数返回值类型。 The vo">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-01-21T15:12:40.000Z">
<meta property="article:modified_time" content="2023-02-25T08:02:57.008Z">
<meta property="article:author" content="tao1st">
<meta property="article:tag" content="复合类型(Compound Type)">
<meta property="article:tag" content="引用(reference)">
<meta property="article:tag" content="指针(pointer)">
<meta property="article:tag" content="const常量限定符">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>C++：变量与基本类型 - tao1st.github.io</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"tao1st.github.io","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":3},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>TAO1st</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/bk.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.5)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="C++：变量与基本类型"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2021-01-21 23:12" pubdate>
          2021年1月21日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          17k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          141 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">C++：变量与基本类型</h1>
            
            
              <div class="markdown-body">
                
                <blockquote>
<p>Terminology: Object</p>
<p>此处的对象（Object）均指一块能存储数据并具有某种类型的内存空间。</p>
</blockquote>
<h1>1 变量及其基本类型</h1>
<h2 id="1-1-原始内置类型-Primitive-Built-in-Types">1.1 原始内置类型 Primitive Built-in Types</h2>
<p>C++中的原始类型大致可以分为两大类：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>算数类型 arithmetic types</p>
</li>
<li class="lvl-2">
<p>空类型 void</p>
<p>空类型没有关联的值，最常见的使用场景即 不返回值的函数返回值类型。</p>
<p>The <code>void</code> type has <b>no associated values</b> and can be used in only a few circumstances, most commonly as <b>the return type for functions that do not return a value</b>.</p>
</li>
</ul>
<h3 id="算术类型-Arithmetic-Types">算术类型 Arithmetic Types</h3>
<p>算术类型分为 <b>整型（integral types）</b> 和 <b>浮点型（floating-point types）</b>。</p>
<p>常见算术类型的大小如下：</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Meaning</th>
<th>Minimum Size</th>
<th>WSL - Linux 64bit</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>bool</code></td>
<td>boolean</td>
<td>NA</td>
<td></td>
</tr>
<tr>
<td><code>char</code></td>
<td>character</td>
<td>8 bits</td>
<td></td>
</tr>
<tr>
<td><code>wchar_t</code></td>
<td>wide character</td>
<td>16 bits</td>
<td></td>
</tr>
<tr>
<td><code>char16_t</code></td>
<td>Unicode character</td>
<td>16 bits</td>
<td></td>
</tr>
<tr>
<td><code>char32_t</code></td>
<td>Unicode character</td>
<td>32 bits</td>
<td></td>
</tr>
<tr>
<td><code>short</code></td>
<td>short integer</td>
<td>16 bits</td>
<td>16 bits</td>
</tr>
<tr>
<td><code>int</code></td>
<td>integer</td>
<td>16 bits</td>
<td>32 bits</td>
</tr>
<tr>
<td><code>long</code></td>
<td>long integer</td>
<td>32 bits</td>
<td>64 bits</td>
</tr>
<tr>
<td><code>long long</code>(C++11)</td>
<td>long integer</td>
<td>64 bits</td>
<td>64 bits</td>
</tr>
<tr>
<td><code>float</code></td>
<td>single-precision floating-point</td>
<td>6 significant digits</td>
<td></td>
</tr>
<tr>
<td><code>double</code></td>
<td>double-precision floating-point</td>
<td>10 significant digits</td>
<td></td>
</tr>
<tr>
<td><code>long double</code></td>
<td>extended-precision floating-point</td>
<td>10 significant digits</td>
<td></td>
</tr>
</tbody>
</table>
<p>一些注意事项：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>注意字面值的默认类型：虽然 <code>long long</code> 为64位，但 <code>1 &lt;&lt; 63</code> 仍然报错，因为在表达式中，1仍然是 <code>int</code>。</p>
<p>因此改成 <code>(long long)1 &lt;&lt; 63</code> / <code>1LL &lt;&lt; 63</code> 便可以正常执行。</p>
</li>
<li class="lvl-2">
<p>通常 <b>溢出</b> 只会报 warning ，其实际值会按位截取。</p>
</li>
<li class="lvl-2">
<p>大整数优先 <code>long long</code>, 有的编译器 <code>long</code> 和 <code>int</code> 一样长。</p>
</li>
<li class="lvl-2">
<p>字符型分三种: <code>char</code>, <code>signed char</code>, <code>unsigned char</code></p>
<p>表现形式只有两种，带符号和无符号，实际表现取决于编译器。</p>
</li>
<li class="lvl-2">
<p>significant digits: 数字的有效位数。</p>
</li>
</ul>
<h3 id="类型转换-Type-Conversions">类型转换 Type Conversions</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>小心无符号整数和有符号整数同时出现在算数表达式中的情况，<b>有符号会被自动转换为无符号</b>。</p>
<p>这一点在条件判断语句（condition）中经常会引发错误。</p>
</li>
<li class="lvl-2">
<p>无符号数和有符号数的二进制码其实是一致的，只是输出时编译器对其判断不同（编译器对不同类型有不同的解析方式）。对于无符号数来说，输出的都是正数。</p>
</li>
<li class="lvl-2">
<p>强制转换。</p>
</li>
</ul>
<h3 id="字面值-Literals">字面值 Literals</h3>
<p>重点关注编译器如何设定字面值的默认类型。</p>
<h4 id="对基本类型字面值的默认操作">对基本类型字面值的默认操作</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>Integer (<code>int</code>, <code>long</code>)</p>
<ol>
<li class="lvl-5">
<p>显式声明进制（System of Numeration）</p>
<p><code>0</code> are interpreted as <b>octal</b>;</p>
<p><code>0x</code> are interpreted as <b>hexadecimal</b>;</p>
</li>
<li class="lvl-5">
<p>默认类型</p>
<p>Decimal: always be <b>signed</b> 十进制的字面值默认类型永远是有符号数</p>
<p>Octal and Hexadecimal: can be either <b>signed</b> or <b>unsigned</b></p>
<p>整型字面值类型默认为 <b>符合大小条件</b>（不会溢出）的情况下 <b>占用空间最小</b> 的类型。</p>
<p>特殊的，there are no literals of type <code>short</code>.</p>
</li>
</ol>
</li>
<li class="lvl-2">
<p>Floating-Point</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>基本形式为 <b>小数点（a decimal point）</b> 或 <b>科学计数法（an exponent specified using scientific notation）</b>。</p>
<p>Using scientific notation, the exponent is indicated by either <code>E</code> or <code>e</code>;</p>
</li>
<li class="lvl-4">
<p>浮点数默认类型为 <code>double</code>。</p>
</li>
</ul>
</li>
<li class="lvl-2">
<p>Character &amp; Character String: 编译器会在所有字符串字面量最后加上一个 <code>\0</code> 来表征字符串的结束，其实际所占空间也会相应+1。</p>
</li>
<li class="lvl-2">
<p>Boolean: <code>true</code> and <code>false</code></p>
</li>
<li class="lvl-2">
<p>Pointer:  <code>nullptr</code></p>
<p>Stop using <code>NULL</code> and change to <code>nullptr</code>.</p>
</li>
</ul>
<h4 id="转义字符-Escape-Sequences">转义字符 Escape Sequences</h4>
<p>转义序列的适用场景有两种：</p>
<ol>
<li class="lvl-3">
<p><b>Nonprintable characters</b>, such as backspace or control characters;</p>
<p>比如：<code>\t</code>，<code>\n</code></p>
</li>
<li class="lvl-3">
<p>保留字，those who have <b>special meaning</b> in the language;</p>
<p>比如想要输出反斜杠本身，<code>\\</code></p>
</li>
</ol>
<p>Generalized escape sequence: using ASCII to decide the actual content 使用转义来显式输出ASCII码指定的字符：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>\x</code> followed by one or more hexadecimal digits;</p>
</li>
<li class="lvl-2">
<p><code>\</code> followed by up to three octal digits;</p>
</li>
</ul>
<h4 id="显式声明字面值的类型-Specifying-the-Type-of-a-Literal">显式声明字面值的类型 Specifying the Type of a Literal</h4>
<p>通过增加前缀与后缀来修改字面值的类型，例如 <code>12345u</code> 将类型从默认的整型转为无符号整型。<br>
Override the default type by supplying a <strong>suffix</strong> or <strong>prefix</strong> as listed below:</p>
<p><b>Integer</b> Literals:</p>
<table>
<thead>
<tr>
<th style="text-align:center">Suffix</th>
<th style="text-align:center">Minimum Type</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>u</code> or <code>U</code></td>
<td style="text-align:center">unsigned</td>
</tr>
<tr>
<td style="text-align:center"><code>l</code> or <code>L</code></td>
<td style="text-align:center">long</td>
</tr>
<tr>
<td style="text-align:center"><code>ll</code> or <code>LL</code></td>
<td style="text-align:center">long long</td>
</tr>
</tbody>
</table>
<p><b>Character</b> and <b>Character String</b> Literals:</p>
<table>
<thead>
<tr>
<th style="text-align:center">Prefix</th>
<th style="text-align:center">Meaning</th>
<th style="text-align:center">Type</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>u</code></td>
<td style="text-align:center">Unicode 16 character</td>
<td style="text-align:center">char16_t</td>
</tr>
<tr>
<td style="text-align:center"><code>U</code></td>
<td style="text-align:center">Unicode 32 character</td>
<td style="text-align:center">char32_t</td>
</tr>
<tr>
<td style="text-align:center"><code>L</code></td>
<td style="text-align:center">wide character</td>
<td style="text-align:center">wchar_t</td>
</tr>
<tr>
<td style="text-align:center"><code>u8</code></td>
<td style="text-align:center">utf-8(string literals only)</td>
<td style="text-align:center">char</td>
</tr>
</tbody>
</table>
<h2 id="1-2-变量-Variables">1.2 变量 Variables</h2>
<blockquote>
<p>A variable provided us with <b>named storage</b> that our programs can manipulate. Variable’s <b>type</b> determines everything about it.</p>
<p>变量就相当于提供了一个有 <b>名字</b> 的 <b>存储空间</b> 以供程序操控。其 <b>类型</b> 决定了我们能对这个存储空间所作的操作。</p>
</blockquote>
<div class="tips">
<p><b>Static Typing(静态类型)</b></p>
<p>C++ is a <b>statically typed language</b>, which means that <b>types are checked at compile time</b>. The process by which types are checked is referred to as <b>type checking</b>.</p>
<p>As we’ve seen, the type of an object constrains the operations that the object can perform. <b>In C++, the compiler checks whether the operations we write are supported by the types we use.</b> If we try to do things that the type does not support, the compiler generates an error message and does not produce an executable file.</p>
<p>As our programs get more complicated, we’ll see that static type checking can help find bugs. However, a consequence of static checking is that the type of every entity we use must be known to the compiler. As one example, we must <b>declare the type of a variable before we can use that variable.</b></p>
<p>区别于那些定义变量时无需添加类型说明符（type specifier）的语言，理解静态类型。静态类型即在 <b>编译阶段</b> 检查类型。</p>
<p>相对应的，变量在定义后不会被限制死为某一固定类型，允许其有不同的数据类型的语言即为 <b>动态类型（dynamically typing）</b>。一个典型的例子就是 <b>JavaScript</b>。</p>
</div>
<h3 id="变量的定义-Definition">变量的定义 Definition</h3>
<p>变量的定义分为两部分，<b>类型说明符（Type Specifier）</b> + 若干个 <b>声明符（declarator）</b> 。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>类型说明符（Type Specifier）：表征变量的 <b>基本类型（Base Type）</b></p>
</li>
<li class="lvl-2">
<p>声明符（Declarator）：通常内容即 <b>变量名</b></p>
<p>声明符部分还会包含 <b>类型修饰符</b>，如 指针（<code>*</code>）、引用（<code>&amp;</code>）的复合修饰。</p>
</li>
</ul>
<h3 id="类型说明符-Type-Specifier">类型说明符 Type Specifier</h3>
<p>类型说明符一般就是声明类的基本类型。</p>
<p>有时类型说明符比较复杂，比如<code>long long</code>，我们希望将其简化，可以对其起别名。</p>
<h4 id="类型别名-Type-Alias">类型别名 Type Alias</h4>
<p>两种起别名的方式：</p>
<ol>
<li class="lvl-3">
<p>typedef</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">double</span> db;       <span class="hljs-comment">// db is a synonym for double</span><br><span class="hljs-keyword">typedef</span> db w1, w2;       <span class="hljs-comment">// w1, w2 are synonyms for double</span><br><span class="hljs-keyword">typedef</span> db *d;           <span class="hljs-comment">// d is a synonym for double*</span><br>                         <span class="hljs-comment">// the declarators can include type modifiers</span><br></code></pre></td></tr></table></figure>
<p>typedef 定义数组：<code>typedef &lt;元素类型&gt; &lt;数组名&gt; [&lt;数组大小/常量表达式&gt;]</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 16			      <span class="hljs-comment">// define 是宏定义语句，结尾无需分号；而 typedef 是类型别名定义，属于常规语句，需要加分号结尾 </span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> matrix[N][N];     <span class="hljs-comment">// 定义了一个名为 matrix 的 int 数组</span><br><br>matrix m;					  <span class="hljs-comment">// 等价 int m[N][N];</span><br>m[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure>
</li>
<li class="lvl-3">
<p>using</p>
<p>C++11 新特性：alias declaration</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> SI = Sales_item;    <span class="hljs-comment">// SI is a synonym for Sales_item</span><br></code></pre></td></tr></table></figure>
</li>
</ol>
<div class="warning">
<p>起别名时要注意复合类型（compound types）的情况：容易出现理解错误。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> *pchar;    <span class="hljs-comment">// pchar is a sysnonym for char*</span><br>						<span class="hljs-comment">// since type modifiers are part of declarators</span><br><span class="hljs-type">const</span> pchar cstr = <span class="hljs-number">0</span>;   <span class="hljs-comment">// const modifies the given type(pchar), so cstr is a const pointer to char</span><br></code></pre></td></tr></table></figure>
</div>
<hr>
<p>C++11中还给了一些更灵活的类型说明符：<b>auto</b> 与 <b>decltype</b>。</p>
<h4 id="auto">auto</h4>
<p>C++11引入， <code>auto</code>是一个类型说明符（Type Specifier）。</p>
<p><code>auto</code> tells the compiler to deduce the type from the initializer. By implication, a variable that uses auto as its type specifier <b>must have an initializer</b>.</p>
<p>编译器自动根据字面值来推断变量类型，显然 <code>auto</code> 定义的变量 <b>必须有初始值</b>。</p>
<h4 id="decltype">decltype</h4>
<p>decltype的含义是 “declared type”。</p>
<p>获得表达式或函数返回值类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">f</span>()) sum = x;        <span class="hljs-comment">// 给出函数f的返回类型</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> ci = <span class="hljs-number">0</span>, &amp;cj = ci;<br><span class="hljs-keyword">decltype</span>(ci) x = <span class="hljs-number">0</span>;            <span class="hljs-comment">// x的类型为const int</span><br><span class="hljs-keyword">decltype</span>(cj) y = x;            <span class="hljs-comment">// y的类型为绑定const int的引用</span><br>                               <span class="hljs-comment">// 此处引用不再作为所指对象的同义词，而是获取了其引用类型</span><br></code></pre></td></tr></table></figure>
<h3 id="声明符-Declarator">声明符 Declarator</h3>
<h4 id="标识符-Identifiers">标识符 Identifiers</h4>
<p>声明符（Declarator）：通常内容即 <b>变量名</b>，由标识符组成。标识符不能出现的情况：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>__</code> two consecutive underscores;</p>
</li>
<li class="lvl-2">
<p><code>_A</code> begin with an underscore followed immediately by an uppercase letter;</p>
</li>
<li class="lvl-2">
<p>在函数体外定义的变量标识符最好不要用下划线作为开头，以便于下划线指明内部变量的含义。</p>
<p>即，下划线开头定义的变量通常用作类或函数的内部变量。</p>
</li>
</ul>
<p>Some generally accepted conventions for naming variables:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>标识符要体现实际含义；</p>
</li>
<li class="lvl-2">
<p>驼峰式命名或者下划线分割单词；</p>
</li>
<li class="lvl-2">
<p>变量名通常均为小写字母；</p>
</li>
<li class="lvl-2">
<p>用户自定义的类名通常以大写字母开头，比如 <code>Sales_item</code>;</p>
</li>
<li class="lvl-2">
<p>同上，下划线开头定义的变量通常用作类或函数的内部变量。</p>
</li>
</ul>
<h4 id="类型修饰符-Type-Modifier">类型修饰符 Type Modifier</h4>
<p>声明符部分还会包含 <b>类型修饰符</b>，如 指针（<code>*</code>）、引用（<code>&amp;</code>）的复合修饰。</p>
<p>具体内容见下一节。重点在于记住 <b>类型修饰符（指针与引用）是声明符的一部分，与类型说明符无关。</b></p>
<h3 id="变量的初始化-Initialization">变量的初始化 Initialization</h3>
<h4 id="初始化-与-赋值">初始化 与 赋值</h4>
<p>初始化（Initialization）与赋值（Assignment）在C++中是两种完全不同的操作：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><b>Initialization</b>: happens when a variable is given a value when it is created;</p>
<p>即创建时第一次赋给变量一个值；</p>
</li>
<li class="lvl-2">
<p><b>Assignment</b>: obliterates an object’s current value and replaces that value with a new one.</p>
<p>即在已创建的情况下，除去原有的值并赋予新值。</p>
</li>
</ul>
<h4 id="初始化的默认值-Default-Initialization">初始化的默认值 Default Initialization</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>内置类型如果没有在初始化时显式赋值，其默认值取决于其初始化语句所在的位置：</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>位于函数体外：初始化为 0 ；</p>
</li>
<li class="lvl-4">
<p>位于函数体内：无初始化值，即未定义，其将会有一个未知值。</p>
<p>编译器并不会对这种情况报错，只会在某些使用场景下给出警告。这是一个合法但十分危险的行为！</p>
</li>
</ul>
</li>
<li class="lvl-2">
<p>类的对象如果没有被显式的初始化，则其值由类本身确定。</p>
<p>即类中要考虑值的初始化问题，而不应该交给编译器决定。</p>
</li>
</ul>
<h4 id="列表初始化-Initialization-List（C-11）">列表初始化 Initialization List（C++11）</h4>
<p>Part of C<ins>11, use <b>curly braces</b> for initialization.<br>
C</ins>11引入的一种全新的变量初始化方式，使用花括号：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>Normal Initialization</p>
<ul class="lvl-2">
<li class="lvl-4"><code>int i = 0;</code></li>
<li class="lvl-4"><code>int i(0);</code></li>
</ul>
</li>
<li class="lvl-2">
<p>List Initialization:</p>
<ul class="lvl-2">
<li class="lvl-4"><code>int i = &#123;0&#125;;</code></li>
<li class="lvl-4"><code>int i&#123;0&#125;;</code></li>
</ul>
</li>
</ul>
<p>One thing we have to care about is that: the compiler will not let us list initialize variables of built-in type if the initializer might lead to <b>the loss of information</b>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">double</span> pi = <span class="hljs-number">3.1415926</span>;<br><span class="hljs-type">int</span> a&#123;pi&#125;, b = &#123;pi&#125;;              <span class="hljs-comment">// error: narrowing conversion required 会失去信息！</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">c</span><span class="hljs-params">(pi)</span>, d </span>= pi;                <span class="hljs-comment">// ok but value will be truncated</span><br></code></pre></td></tr></table></figure>
<h3 id="变量的声明-Declaration">变量的声明 Declaration</h3>
<blockquote>
<p>为了支持分离式编译（separate compilation），C++ 要将 声明（declarations） 与 定义（definitions） 两种操作区分开。</p>
<p>To use a variable in more than one file requires declarations that are separate from the variable’s definition. To use the same variable in multiple files, we must define that variable in one—and only one—file. Other files that use that variable must declare—but not define—that variable.</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>Declaration: <b>makes a name known to the program</b>, specifies the type and name of a variable;</p>
<p>To obtain a declaration that is not also a definition, we add the <code>extern</code> keyword and do not provide an explicit initializer.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> i;      <span class="hljs-comment">// declares but does not define i</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;  <span class="hljs-comment">// definition, the initializer overrides the extern.</span><br>                   <span class="hljs-comment">// It is an error to provide an initializer on an extern 【inside a function】.</span><br></code></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p>Definition: creates the associated entity, which allocates storage and may provide the variable with an initial value.</p>
</li>
</ul>
<h3 id="变量的作用域-Scope">变量的作用域 Scope</h3>
<p>Most scopes in C++ are delimited by curly braces <code>&#123;&#125;</code>.</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>Global Scope: defined outside a function;</p>
</li>
<li class="lvl-2">
<p>Block Scope: defined inside a function;</p>
</li>
<li class="lvl-2">
<p>Nested Scopes: Names declared in the outer scope can also be redefined in an inner scope. Legit but NOT recommended.</p>
</li>
<li class="lvl-2">
<p>Scope Operator <code>::</code></p>
<p>Scope operator can override the default scoping rules.</p>
<p>The global scope has no name. Hence, when the scope operator has an empty left-hand side, it is a request to fetch the name on the right-hand side from the global scope.</p>
</li>
</ul>
<h1>2 复合类型 Compound Type</h1>
<blockquote>
<p>复合类型指 <b>基于其他基本类型定义的类型</b>。</p>
<p>本文介绍其中两种，<strong>引用</strong>和<strong>指针</strong>。</p>
</blockquote>
<h2 id="2-1-引用-References">2.1 引用 References</h2>
<blockquote>
<p>此处的引用均指 <b>左值引用（lvalue reference）</b> 。</p>
<p>C++11引入了一种新的引用：<b>右值引用（rvalue reference）</b> ，不在此处讨论范围内。</p>
</blockquote>
<p>有关引用的一些基本规则：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>引用就是个 <b>别名</b>。</p>
<p>A reference is just an Alias.</p>
</li>
<li class="lvl-2">
<p>引用必须初始化。且一经初始化 <b>无法绑定到其他变量上</b>。</p>
<p>一切对引用的操作实际就是对其绑定的对象操作。</p>
<p>When we define a reference, we do not copy the initializer’s value but bind the reference to its initializer(an object).</p>
<p>Once initialized, a reference remains bound to its initial object. There is NO WAY TO REBIND a reference to refer to a different object.</p>
<p>Since there is no way to rebind a reference, reference must be initialized.</p>
</li>
<li class="lvl-2">
<p>不能定义引用的引用，引用并不占用任何实际的内存（不是一个狭义的对象）。</p>
<p>References are not objects, we may not define a reference to a reference.</p>
</li>
<li class="lvl-2">
<p>在几乎所有情况下，引用声明类型 和 绑定数据类型 必须一致。</p>
<p>Generally speaking, <i>the type of a reference</i> and <i>the object to which the reference</i> refers must match exactly.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">double</span> d = <span class="hljs-number">3.14</span>;<br><span class="hljs-type">int</span> &amp;r = d;          <span class="hljs-comment">// error: initializer must be an int object</span><br></code></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p>引用必须绑定对象，不能将引用绑定到任何字面值。</p>
<p>A reference may be bound only to an object, not to a literal or to the result of a more general expression.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> &amp;r = <span class="hljs-number">10</span>;         <span class="hljs-comment">// error: initializer must be an object</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2-2-指针-Pointers">2.2 指针 Pointers</h2>
<h3 id="指针相关的操作符-Operator">指针相关的操作符 Operator</h3>
<blockquote>
<p>在声明中使用和在表达式中使用具有不同的含义。</p>
</blockquote>
<h4 id="address-of-operator-取地址"><code>&amp;</code> address-of operator 取地址</h4>
<p>Take the address of an object.</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>在声明中：属于 声明符/类型修饰符（Type Modifier） 的一部分（即变量名的一部分），说明其在声明一个绑定至基类类型（Base Type / Type Specifier）的引用；</p>
</li>
<li class="lvl-2">
<p>在表达式中：取地址运算符，获得其后对象的地址。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Multiple meanings:</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> &amp;r = i;               <span class="hljs-comment">// part of a declaration, &amp; is a type modifier, r is a reference</span><br><span class="hljs-type">int</span> *p = &amp;i;              <span class="hljs-comment">// used in an expression as the address-of operator</span><br></code></pre></td></tr></table></figure>
<h4 id="dereference-operator-解引用"><code>*</code> dereference operator 解引用</h4>
<p>Access the object.</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>在声明中：属于 声明符/类型修饰符（Type Modifier） 的一部分（即变量名的一部分），说明其在声明一个指向基类类型（Base Type / Type Specifier）的指针；</p>
</li>
<li class="lvl-2">
<p>在表达式中：解引用，读取后面指针变量指向的地址空间。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Multiple meanings:</span><br><span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> *p = &amp;i;               <span class="hljs-comment">// part of a declaration, * is a type modifier, p is a pointer</span><br>*p = j;                    <span class="hljs-comment">// used in an expression as the dereference operator</span><br></code></pre></td></tr></table></figure>
<h3 id="空指针-Null-Pointer">空指针 Null Pointer</h3>
<p>Several ways to obtain a null pointer:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> *p1 = <span class="hljs-literal">nullptr</span>;         <span class="hljs-comment">// recommended, introduced by C++11</span><br><span class="hljs-type">int</span> *p2 = <span class="hljs-number">0</span>;			   <span class="hljs-comment">// 显式赋 0 时得到的也是空指针</span><br><span class="hljs-type">int</span> *p3 = <span class="hljs-literal">NULL</span>;            <span class="hljs-comment">// not recommended</span><br><span class="hljs-comment">// Modern C++ programs generally should avoid using NULL and use nullptr instead.</span><br><span class="hljs-type">int</span> *p4 = <span class="hljs-literal">nullptr</span>;<br></code></pre></td></tr></table></figure>
<blockquote>
<p><code>NULL</code> is a preprocessor variable used in older programs, which the <code>cstdlib</code> header defines as 0.</p>
</blockquote>
<h3 id="指向任意类型的指针-Void-Pointer">指向任意类型的指针 Void* Pointer</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>The type <code>void*</code> is a special pointer type that can <strong>hold the address of any object</strong>.</p>
<p>指向任意类型的指针。</p>
</li>
<li class="lvl-2">
<p>We can <strong>not</strong> use a <code>void*</code> to operate on the object it addresses—we don’t know that object’s type, and the type determines what operations we can perform on the object.</p>
<p>Thus, we use a <code>void*</code> pointer to deal with memory <strong>as memory</strong>, rather than using the pointer to access the object stored in that memory.</p>
<p>无法通过指针操作其对象，因为数据类型不确定。</p>
</li>
</ul>
<h3 id="一些指针的特殊操作-Pointer-Operations">一些指针的特殊操作 Pointer Operations</h3>
<h4 id="Wild-Pointer-野指针">Wild Pointer 野指针</h4>
<blockquote>
<p>Distinguish <b>a invalid/wild pointer</b> from <b>a null pointer</b>.</p>
<p>The first one means we do NOT know where it points to. The latter one means it is not bound to any object.</p>
</blockquote>
<p>避免野指针，错误无法被编译器发现，会引发完全未知的结果。因此，对所有指针都进行初始化以防止野指针出现。</p>
<p>It is an error to copy or otherwise try to access the value of an invalid pointer. As when we use an uninitialized variable, this error is one that <b>the compiler is unlikely to detect</b>. The result of accessing an invalid pointer is undefined.<br>
Advice: Initialize all Pointers.</p>
<h4 id="Assign-an-int-variable-to-a-pointer-Illegal">Assign an int variable to a pointer - Illegal</h4>
<p>It is <b>ILLEGAL</b> to assign an int variable to a pointer, even if the variable’s value happens to be 0.<br>
不能把 <code>int</code> 变量赋给指针值当作地址（即使其值恰好为 0 也不行）。指针只能接受地址（取地址符或常量）或空值（<code>nullptr</code>）。</p>
<h4 id="Use-a-pointer-in-a-condition">Use a pointer in a condition</h4>
<p>So long as the pointer has a valid value, we can use a pointer in a <strong>condition</strong>.<br>
可以将指针作为条件表达式中作为判断，根据其实际值进行判断即可。</p>
<h2 id="2-3-复合类型的声明-Compound-Type-Declarations">2.3 复合类型的声明 Compound Type Declarations</h2>
<h3 id="普通声明">普通声明</h3>
<p>类型修饰符是声明符的一部分，即 <code>*</code> 和 <code>&amp;</code> 是修饰变量名的，而非修饰基本类型。这也意味着 <b>一句</b> 变量定义可以定义多个多种类型的变量（普通类型、指针类型、引用类型）。<br>
The <b>type modifiers</b> (<code>*</code> or <code>&amp;</code>) are part of a declarator.</p>
<h3 id="指向指针的指针-Pointers-to-Pointers">指向指针的指针 Pointers to Pointers</h3>
<p>根据数量判断指针级别。<br>
Indicate each pointer level by its own <code>*</code>.</p>
<h3 id="指针变量的引用-References-to-Pointers">指针变量的引用 References to Pointers</h3>
<p>A reference is not an object. Hence, we may NOT have a pointer to a reference.<br>
Since a pointer is an object, we can define a reference to a pointer.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> *p = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-type">int</span> *&amp;r = p;              <span class="hljs-comment">// r is a reference to the pointer p</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>Read the definition <b>right to left</b> (backwards).</p>
<p>从右向左读，离变量名越近影响越直接。</p>
</blockquote>
<h1>3 常量与常量表达式 Constant</h1>
<h2 id="3-1-常量的基本概念">3.1 常量的基本概念</h2>
<h3 id="const-限定词">const 限定词</h3>
<p>加上 const 限定词（Qualifier）的变量即为常量变量，特点有：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>值不能被改变。任何修改其值的行为都会引发错误；</p>
</li>
<li class="lvl-2">
<p>必须初始化，即定义时必须赋初值；</p>
</li>
<li class="lvl-2">
<p>常量能够实现大部分其数据类型能够实现的功能，唯一的限制就是这些功能必须不改变其内容；</p>
</li>
<li class="lvl-2">
<p>编译器会在编译过程中把用到常量的地方都替换成其对应的值。</p>
</li>
</ul>
<h3 id="const-的作用域">const 的作用域</h3>
<p>默认状态下，const 对象仅在当前文件内有效（defined as local to the file）。</p>
<p>想要在多个文件之间共享同一个 const 对象，就要给变量（无论是声明和定义）添加为 <code>extern</code> 关键字。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// file1.cc defines and intializes</span><br><span class="hljs-comment">// the extern signifies that this variable is not local to this file</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> bufSize = <span class="hljs-number">500</span>; <br><span class="hljs-comment">// file2.cc delcares</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> bufSize;<br></code></pre></td></tr></table></figure>
<h2 id="3-2-复合常量-compound-const">3.2 复合常量 compound const</h2>
<blockquote>
<p>复合 const 较复杂，一定要理解方法：</p>
<ul class="lvl-1">
<li class="lvl-2">
<p><code>const</code> 意味着变量的值不能修改，也意味着必须初始化；</p>
</li>
<li class="lvl-2">
<p><b>常量引用</b> 意味着什么？</p>
<p>并不意味着引用是常量，因为引用本身不是一个对象。常量引用只是对引用可参与的操作做出了限定。</p>
</li>
<li class="lvl-2">
<p><b>常量指针</b> 和 <b>指向常量的指针</b> 意味着什么？</p>
</li>
<li class="lvl-2">
<p><b>从右向左 </b>分析各个限定符对变量名的影响。</p>
</li>
</ul>
</blockquote>
<h3 id="常量引用-References-to-const">常量引用 References to const</h3>
<div class="tips">
<p>我们常把 <b>绑定到常量类型的引用</b> 简称为 <b>常量引用</b>（abbreviate the phrase <b>“reference to const”</b> as <b>“const reference”</b>）。<br>
C++ programmers tend to abbreviate the phrase “reference to const” as “const reference.” This abbreviation makes sense—if you remember that it is an abbreviation.</p>
<p>实际并不存在所谓的“常量引用”，因为引用本身根本不是个对象，更无所谓常量与否；<br>
Technically speaking, there are no const references. A reference is not an object, so we cannot make a reference itself const.</p>
<p>考虑到 引用在初始化后不可绑定到其他对象上 的特性，引用本身在某种意义上来说就是一个常量（只是意义上相似）；<br>
Indeed, because there is no way to make a reference refer to a different object, in some sense all references are const.</p>
</div>
<h4 id="常量引用的概念与特性">常量引用的概念与特性</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><b>常量引用</b> 即绑定到常量类型的引用。</p>
</li>
<li class="lvl-2">
<p>常量引用是对 <b>引用可参与的操作</b> 做出了限定，意味着 <b>无法通过该引用对其绑定的对象进行修改</b>。</p>
</li>
<li class="lvl-2">
<p>常量引用 与 引用能够能够改变绑定对象 二者是完全无关的。毕竟引用本来一经初始化就不能更改绑定。</p>
<p>Whether a reference refers to a const or non-const type affects what we can do with that reference, not whether we can alter the binding of the reference itself.</p>
</li>
<li class="lvl-2">
<p>常量引用允许绑定到非常量对象上。只会限制常量可参与的操作，即无法通过常量引用修改其绑定的非常量对象，但仍然可以通过其他方式修改。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;ci = i;			<span class="hljs-comment">// 正确，但不能通过 ci 来修改 i</span><br></code></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p>只有常量引用才能绑定到一个常量对象上。即，<b>普通引用绑定到常量对象上是非法的</b>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> c = <span class="hljs-number">0</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;r1 = c;        <span class="hljs-comment">// correct</span><br><span class="hljs-type">int</span> &amp;r2 = c;              <span class="hljs-comment">// error: non-const reference can not bind to a const object</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="常量引用的初始化">常量引用的初始化</h4>
<p>通常情况下，引用的类型 必须和 其绑定的对象类型 一致。<br>
Normally, the type of a reference must match the type of the object to which it refers.</p>
<p>这里有一种例外情况：常量引用的初始化语句中，允许使用 <b>任意表达式</b> 作为初始值，只要该表达式的结果能够转换为引用的类型即可。<br>
One of the exception is that we can initialize a reference to <code>const</code> from <b>any expression</b> that <b>can be converted to the type of the reference</b>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">double</span> dval = <span class="hljs-number">3.14</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;cri = dval;			<span class="hljs-comment">// correct 绑定至不同类型</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;crl = <span class="hljs-number">42</span>;		    <span class="hljs-comment">// correct 绑定至字面值</span><br></code></pre></td></tr></table></figure>
<p>之所以能够实现这种例外，是因为编译器创建了一个<b>临时量</b>。<br>
When we bind a <code>const</code> reference to an object of a <strong>different type</strong>, it is actually bound to a <strong>temporary object.</strong> A temporary object is an unnamed object created by the compiler when it needs a place to store a result from evaluating an expression.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 上述两种转换的内部实现</span><br><span class="hljs-comment">// const int &amp;cri = dval;</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> temp = dval;				<span class="hljs-comment">// type conversion</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;cri = temp;				<span class="hljs-comment">// bind to the temp object</span><br><br><span class="hljs-comment">// const int &amp;crl = 42;</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> temp = <span class="hljs-number">42</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;crl = temp;<br></code></pre></td></tr></table></figure>
<div class="tips">
<p><b>非常量引用绑定至不同类型的对象</b></p>
<p>假设我们定义了一个非常量引用，并试图将其绑定至不同的类型。比如 <code>int &amp;ri = dval</code> （<code>int</code> 引用绑定至<code>double</code> 对象），我们可以分析此时的特点：</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>既然是一个非常量引用，我们一定希望通过该引用来改变其绑定的对象；</p>
</li>
<li class="lvl-2">
<p>因为存在类型转换，所以该引用实际上是绑定至一个 <b>临时量</b>；</p>
</li>
</ul>
<p>这种情况下，我们显然无法通过 <code>ri</code> 来访问 <code>dval</code> ，因为 <code>ri</code> 实际绑定至了一个临时量！这并没有任何的实际意义，所以这种行为被归为非法。</p>
</div>
<h3 id="常量与指针-const-and-pointer">常量与指针 const and pointer</h3>
<p>指针与引用不同。引用并非对象，没有实际存储的内容，仅仅作为一个别名存在。而指针本身也是一个对象，所以指针与常量的结合有两种情况：</p>
<ol>
<li class="lvl-3">
<p><b>指向常量对象的指针</b>：类似于常量引用，限制了其能够参与的操作，即不能通过复合类型修改其指向的实际对象。</p>
</li>
<li class="lvl-3">
<p><b>常量指针</b>：指针本身是一个常量。指针变量的值不能修改，即指针只能指向一块地址空间而不能改变。</p>
</li>
</ol>
<h4 id="指向常量对象的指针-pointer-to-const">指向常量对象的指针 pointer to const</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>普通指针不可指向常量对象；</p>
</li>
<li class="lvl-2">
<p>指向常量类型的指针可以令其指向非常量对象，但不能通过该指针修改该对象。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> *p = &amp;i;			<span class="hljs-comment">// error: 普通指针不可指向常量对象</span><br><span class="hljs-comment">// 从右向左读，const 是修饰基本类型 int 的，即定义一个 普通指针 指向 const int 类型对象</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *cp1 = &amp;i;	<span class="hljs-comment">// correct: 常量指针指向常量对象</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *cp2 = &amp;j;	<span class="hljs-comment">// correct: 指向非常量对象，但不能通过该指针修改该对象</span><br>*cp1 = <span class="hljs-number">2</span>;				<span class="hljs-comment">// error: 试图通过指向常量的指针来修改其指向值是非法的，无论其指向变量是否为常量</span><br></code></pre></td></tr></table></figure>
<h4 id="常量指针-const-pointer">常量指针 const pointer</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>常量指针本身的值无法修改，即其指向一个固定地址；</p>
</li>
<li class="lvl-2">
<p>虽然常量指针本身的值是固定的，但是可以通过该常量指针对变量的值进行修改。</p>
</li>
<li class="lvl-2">
<p>常量指针的写法：<code>*const</code> ，显然与其他不同，const写在了其修饰对象的后面。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> *<span class="hljs-type">const</span> p = &amp;i;         <span class="hljs-comment">// read from right to left</span><br>                           <span class="hljs-comment">// const修饰指针，指明该指针为常量指针，并指向 int 类型</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *<span class="hljs-type">const</span> q = &amp;j;   <span class="hljs-comment">// 双层嵌套：一个常量指针，且指向常量对象。</span><br>						   <span class="hljs-comment">// 既不能修改该指针的指向，也不能通过该指针修改其指向对象</span><br></code></pre></td></tr></table></figure>
<h4 id="顶层与底层">顶层与底层</h4>
<p>显然，对于指针来说，const 存在两种情况，我们将其定义为顶层与底层：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>Top-level const：</p>
<p>顾名思义，const 修饰指针本身。即指针本身就是个常量，而不关心其指向变量是否为常量。</p>
<p>扩展到普通情况，即任意对象其本身为常量。</p>
<p>More generally, top-level <code>const</code> indicates that an object itself is <code>const</code>.</p>
<p>我们可以说，任意的对象都能被声明为顶层 const，因为顶层的含义形容的就是自身。</p>
<p>Top-level <code>const</code> can appear in any object type.</p>
</li>
<li class="lvl-2">
<p>Low-level const：</p>
<p>与之对应的，底层 const 只能修饰复合类型，因为底层的含义是其指向或绑定的对象为常量。</p>
<p>显然：</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>指针：既可以是顶层又可以是底层 const，一个特殊情况。</p>
</li>
<li class="lvl-4">
<p>引用：因为引用本身不是个对象，所以引用只能出现底层 const 的情况。</p>
<p>值得注意的是，不要误会底层 const 的引用一定会绑定一个常量对象。因为常量引用仍然可以指向普通对象，只是不能通过常量引用来修改。</p>
</li>
</ul>
</li>
<li class="lvl-2">
<p>顶层与底层的影响：</p>
<p>对赋值时拷贝有所影响。</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>顶层：对象本身是常量并不影响我们拷贝其值来进行赋值，因为拷贝操作并不会修改对象的值。</p>
</li>
<li class="lvl-4">
<p>底层：底层在拷贝的时候要注意，因为底层会影响顶层复合类型对其能够进行的操作，所以其底层对象必须类型能够匹配或者能够合理转换：常量可以转为非常量，反之不可。</p>
<p>比如：</p>
<ul class="lvl-4">
<li class="lvl-6">
<p>非常量引用不能绑定至一个常量对象上，因为常量对象无法转换为非常量；</p>
</li>
<li class="lvl-6">
<p>常量引用可以绑定到一个普通对象上，只是不能通过该常量引用对其进行修改。即拷贝赋值时普通对象转换为常量对象。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3-3-常量表达式-const-expression">3.3 常量表达式 const expression</h2>
<h3 id="基本概念-2">基本概念</h3>
<p>一个表达式满足如下两个特点即为常量表达式：</p>
<ol>
<li class="lvl-3">
<p>值不会改变</p>
</li>
<li class="lvl-3">
<p>编译过程就能得到计算结果</p>
</li>
</ol>
<p>一个对象或表达式是不是常量表达式由它的数据类型（type）和初始值（initializer）共同决定：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>字面值：a <strong>literal</strong> is a constant expression</p>
</li>
<li class="lvl-2">
<p>初值由常量表达式给定的常量对象：a <strong><code>const</code> object</strong> that is initialized from a constant expression is also a constant expression</p>
</li>
<li class="lvl-2">
<p>由上述两种对象进行运算组成的表达式也是常量表达式。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;                 <span class="hljs-comment">// i is a constant expression</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>;             <span class="hljs-comment">// j is a constant expression</span><br><br><span class="hljs-type">int</span> k = <span class="hljs-number">3</span>;                       <span class="hljs-comment">// k is not because of its 【type】</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> q = <span class="hljs-built_in">get_size</span>()         <span class="hljs-comment">// q is not because of its 【initializer】</span><br></code></pre></td></tr></table></figure>
<h3 id="constexpr-类型">constexpr 类型</h3>
<blockquote>
<p>我们希望一个定义一个常量，但有的时候初始值较为复杂，右侧表达式难以判断是否为常量表达式。如果右侧不是，编译器显然会报错。</p>
<p>C++增加了一个新的机制，我们可以将该变量定义为常量表达式类型，右侧值是否为常量表达式则交给编译器去判断。</p>
<p>Generally, it is a good idea to use <code>constexpr</code> for variables that you intend to use as constant expressions.</p>
</blockquote>
<p>C++11: ask the <strong>compiler</strong> to verify that a variable is a constant expression by declaring the variable in a <code>constexpr</code> declaration.</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>Variables declared as <code>constexpr</code> are</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>implicitly <code>const</code></p>
</li>
<li class="lvl-4">
<p>must be initialized by constant expressions</p>
<p>We can not use an ordinary function as an initializer for a <code>constexpr</code> variable.</p>
<p>However, C++11 define certain functions as <code>constexpr</code>. We can use <code>constexpr</code> functions in the initializer of a <code>constexpr</code> variable.</p>
</li>
</ul>
</li>
<li class="lvl-2">
<p>Generally, it is a good idea to use <code>constexpr</code> for variables that you intend to use as constant expressions.</p>
</li>
</ul>
<h3 id="Literal-type-字面类型">Literal type 字面类型</h3>
<blockquote>
<p>详见后，仅略了解</p>
</blockquote>
<p>Because a constant expression is one that can be evaluated at compile time, there are limits on the types that we can use in a <code>constexpr</code> declaration. The types we can use in a <code>constexpr</code> are known as “<strong>literal types</strong>” because they are simple enough to have literal values.</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>We can initialize a <code>constexpr</code> pointer only from <strong>the <code>nullptr</code> literal$$_{[1]}$$</strong>, <strong>the literal 0$$_{[2]}$$</strong> or <strong>an object that remains at a fixed address$$_{[3]}$$</strong>.</p>
</li>
<li class="lvl-2">
<p>Variables defined <strong>inside a function</strong> ordinarily are not stored at a fixed address. Hence, we cannot use a<code>constexpr</code> pointer to point to such variables.</p>
<p>On the other hand, the address of an object defined outside of any function is a constant expression, and so may be used to initialize a <code>constexpr</code> pointer.</p>
</li>
<li class="lvl-2">
<p><code>constexpr</code> pointer is a <strong>exception</strong>. The <code>constexpr</code> imposes a top-level <code>const</code> on the subject.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> *q = <span class="hljs-literal">nullptr</span>;        <span class="hljs-comment">// q is a constexpr point</span><br></code></pre></td></tr></table></figure>
</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/C-C/" class="category-chain-item">C/C++</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B-Compound-Type/">#复合类型(Compound Type)</a>
      
        <a href="/tags/%E5%BC%95%E7%94%A8-reference/">#引用(reference)</a>
      
        <a href="/tags/%E6%8C%87%E9%92%88-pointer/">#指针(pointer)</a>
      
        <a href="/tags/const%E5%B8%B8%E9%87%8F%E9%99%90%E5%AE%9A%E7%AC%A6/">#const常量限定符</a>
      
    </div>
  
</div>


              

              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/02/15/Command-line_Environment/" title="Command-line Environment">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Command-line Environment</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/12/04/git-book/" title="Git-Book">
                        <span class="hidden-mobile">Git-Book</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>2022</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>TAO1st</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.1/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
